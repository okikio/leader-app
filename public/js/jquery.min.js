/*! jQuery v3.3.1 | (c) JS Foundation and other contributors | jquery.org/license */ ! function(e, t) { "use strict"; "object" == typeof module && "object" == typeof module.exports ? module.exports = e.document ? t(e, !0) : function(e) { if (!e.document) throw new Error("jQuery requires a window with a document"); return t(e) } : t(e) }("undefined" != typeof window ? window : this, function(e, t) { "use strict"; var n = [],
        r = e.document,
        i = Object.getPrototypeOf,
        o = n.slice,
        a = n.concat,
        s = n.push,
        u = n.indexOf,
        l = {},
        c = l.toString,
        f = l.hasOwnProperty,
        p = f.toString,
        d = p.call(Object),
        h = {},
        g = function e(t) { return "function" == typeof t && "number" != typeof t.nodeType },
        y = function e(t) { return null != t && t === t.window },
        v = { type: !0, src: !0, noModule: !0 };

    function m(e, t, n) { var i, o = (t = t || r).createElement("script"); if (o.text = e, n)
            for (i in v) n[i] && (o[i] = n[i]);
        t.head.appendChild(o).parentNode.removeChild(o) }

    function x(e) { return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? l[c.call(e)] || "object" : typeof e } var b = "3.3.1",
        w = function(e, t) { return new w.fn.init(e, t) },
        T = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
    w.fn = w.prototype = { jquery: "3.3.1", constructor: w, length: 0, toArray: function() { return o.call(this) }, get: function(e) { return null == e ? o.call(this) : e < 0 ? this[e + this.length] : this[e] }, pushStack: function(e) { var t = w.merge(this.constructor(), e); return t.prevObject = this, t }, each: function(e) { return w.each(this, e) }, map: function(e) { return this.pushStack(w.map(this, function(t, n) { return e.call(t, n, t) })) }, slice: function() { return this.pushStack(o.apply(this, arguments)) }, first: function() { return this.eq(0) }, last: function() { return this.eq(-1) }, eq: function(e) { var t = this.length,
                n = +e + (e < 0 ? t : 0); return this.pushStack(n >= 0 && n < t ? [this[n]] : []) }, end: function() { return this.prevObject || this.constructor() }, push: s, sort: n.sort, splice: n.splice }, w.extend = w.fn.extend = function() { var e, t, n, r, i, o, a = arguments[0] || {},
            s = 1,
            u = arguments.length,
            l = !1; for ("boolean" == typeof a && (l = a, a = arguments[s] || {}, s++), "object" == typeof a || g(a) || (a = {}), s === u && (a = this, s--); s < u; s++)
            if (null != (e = arguments[s]))
                for (t in e) n = a[t], a !== (r = e[t]) && (l && r && (w.isPlainObject(r) || (i = Array.isArray(r))) ? (i ? (i = !1, o = n && Array.isArray(n) ? n : []) : o = n && w.isPlainObject(n) ? n : {}, a[t] = w.extend(l, o, r)) : void 0 !== r && (a[t] = r)); return a }, w.extend({ expando: "jQuery" + ("3.3.1" + Math.random()).replace(/\D/g, ""), isReady: !0, error: function(e) { throw new Error(e) }, noop: function() {}, isPlainObject: function(e) { var t, n; return !(!e || "[object Object]" !== c.call(e)) && (!(t = i(e)) || "function" == typeof(n = f.call(t, "constructor") && t.constructor) && p.call(n) === d) }, isEmptyObject: function(e) { var t; for (t in e) return !1; return !0 }, globalEval: function(e) { m(e) }, each: function(e, t) { var n, r = 0; if (C(e)) { for (n = e.length; r < n; r++)
                    if (!1 === t.call(e[r], r, e[r])) break } else
                for (r in e)
                    if (!1 === t.call(e[r], r, e[r])) break; return e }, trim: function(e) { return null == e ? "" : (e + "").replace(T, "") }, makeArray: function(e, t) { var n = t || []; return null != e && (C(Object(e)) ? w.merge(n, "string" == typeof e ? [e] : e) : s.call(n, e)), n }, inArray: function(e, t, n) { return null == t ? -1 : u.call(t, e, n) }, merge: function(e, t) { for (var n = +t.length, r = 0, i = e.length; r < n; r++) e[i++] = t[r]; return e.length = i, e }, grep: function(e, t, n) { for (var r, i = [], o = 0, a = e.length, s = !n; o < a; o++)(r = !t(e[o], o)) !== s && i.push(e[o]); return i }, map: function(e, t, n) { var r, i, o = 0,
                s = []; if (C(e))
                for (r = e.length; o < r; o++) null != (i = t(e[o], o, n)) && s.push(i);
            else
                for (o in e) null != (i = t(e[o], o, n)) && s.push(i); return a.apply([], s) }, guid: 1, support: h }), "function" == typeof Symbol && (w.fn[Symbol.iterator] = n[Symbol.iterator]), w.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(e, t) { l["[object " + t + "]"] = t.toLowerCase() });

    function C(e) { var t = !!e && "length" in e && e.length,
            n = x(e); return !g(e) && !y(e) && ("array" === n || 0 === t || "number" == typeof t && t > 0 && t - 1 in e) } var E = function(e) { var t, n, r, i, o, a, s, u, l, c, f, p, d, h, g, y, v, m, x, b = "sizzle" + 1 * new Date,
            w = e.document,
            T = 0,
            C = 0,
            E = ae(),
            k = ae(),
            S = ae(),
            D = function(e, t) { return e === t && (f = !0), 0 },
            N = {}.hasOwnProperty,
            A = [],
            j = A.pop,
            q = A.push,
            L = A.push,
            H = A.slice,
            O = function(e, t) { for (var n = 0, r = e.length; n < r; n++)
                    if (e[n] === t) return n; return -1 },
            P = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
            M = "[\\x20\\t\\r\\n\\f]",
            R = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
            I = "\\[" + M + "*(" + R + ")(?:" + M + "*([*^$|!~]?=)" + M + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + R + "))|)" + M + "*\\]",
            W = ":(" + R + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + I + ")*)|.*)\\)|)",
            $ = new RegExp(M + "+", "g"),
            B = new RegExp("^" + M + "+|((?:^|[^\\\\])(?:\\\\.)*)" + M + "+$", "g"),
            F = new RegExp("^" + M + "*," + M + "*"),
            _ = new RegExp("^" + M + "*([>+~]|" + M + ")" + M + "*"),
            z = new RegExp("=" + M + "*([^\\]'\"]*?)" + M + "*\\]", "g"),
            X = new RegExp(W),
            U = new RegExp("^" + R + "$"),
            V = { ID: new RegExp("^#(" + R + ")"), CLASS: new RegExp("^\\.(" + R + ")"), TAG: new RegExp("^(" + R + "|[*])"), ATTR: new RegExp("^" + I), PSEUDO: new RegExp("^" + W), CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + M + "*(even|odd|(([+-]|)(\\d*)n|)" + M + "*(?:([+-]|)" + M + "*(\\d+)|))" + M + "*\\)|)", "i"), bool: new RegExp("^(?:" + P + ")$", "i"), needsContext: new RegExp("^" + M + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + M + "*((?:-\\d)?\\d*)" + M + "*\\)|)(?=[^-]|$)", "i") },
            G = /^(?:input|select|textarea|button)$/i,
            Y = /^h\d$/i,
            Q = /^[^{]+\{\s*\[native \w/,
            J = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
            K = /[+~]/,
            Z = new RegExp("\\\\([\\da-f]{1,6}" + M + "?|(" + M + ")|.)", "ig"),
            ee = function(e, t, n) { var r = "0x" + t - 65536; return r !== r || n ? t : r < 0 ? String.fromCharCode(r + 65536) : String.fromCharCode(r >> 10 | 55296, 1023 & r | 56320) },
            te = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
            ne = function(e, t) { return t ? "\0" === e ? "ï¿½" : e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " " : "\\" + e },
            re = function() { p() },
            ie = me(function(e) { return !0 === e.disabled && ("form" in e || "label" in e) }, { dir: "parentNode", next: "legend" }); try { L.apply(A = H.call(w.childNodes), w.childNodes), A[w.childNodes.length].nodeType } catch (e) { L = { apply: A.length ? function(e, t) { q.apply(e, H.call(t)) } : function(e, t) { var n = e.length,
                        r = 0; while (e[n++] = t[r++]);
                    e.length = n - 1 } } }

        function oe(e, t, r, i) { var o, s, l, c, f, h, v, m = t && t.ownerDocument,
                T = t ? t.nodeType : 9; if (r = r || [], "string" != typeof e || !e || 1 !== T && 9 !== T && 11 !== T) return r; if (!i && ((t ? t.ownerDocument || t : w) !== d && p(t), t = t || d, g)) { if (11 !== T && (f = J.exec(e)))
                    if (o = f[1]) { if (9 === T) { if (!(l = t.getElementById(o))) return r; if (l.id === o) return r.push(l), r } else if (m && (l = m.getElementById(o)) && x(t, l) && l.id === o) return r.push(l), r }
                else { if (f[2]) return L.apply(r, t.getElementsByTagName(e)), r; if ((o = f[3]) && n.getElementsByClassName && t.getElementsByClassName) return L.apply(r, t.getElementsByClassName(o)), r } if (n.qsa && !S[e + " "] && (!y || !y.test(e))) { if (1 !== T) m = t, v = e;
                    else if ("object" !== t.nodeName.toLowerCase()) {
                        (c = t.getAttribute("id")) ? c = c.replace(te, ne): t.setAttribute("id", c = b), s = (h = a(e)).length; while (s--) h[s] = "#" + c + " " + ve(h[s]);
                        v = h.join(","), m = K.test(e) && ge(t.parentNode) || t } if (v) try { return L.apply(r, m.querySelectorAll(v)), r }
                    catch (e) {} finally { c === b && t.removeAttribute("id") } } } return u(e.replace(B, "$1"), t, r, i) }

        function ae() { var e = [];

            function t(n, i) { return e.push(n + " ") > r.cacheLength && delete t[e.shift()], t[n + " "] = i } return t }

        function se(e) { return e[b] = !0, e }

        function ue(e) { var t = d.createElement("fieldset"); try { return !!e(t) } catch (e) { return !1 } finally { t.parentNode && t.parentNode.removeChild(t), t = null } }

        function le(e, t) { var n = e.split("|"),
                i = n.length; while (i--) r.attrHandle[n[i]] = t }

        function ce(e, t) { var n = t && e,
                r = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex; if (r) return r; if (n)
                while (n = n.nextSibling)
                    if (n === t) return -1; return e ? 1 : -1 }

        function fe(e) { return function(t) { return "input" === t.nodeName.toLowerCase() && t.type === e } }

        function pe(e) { return function(t) { var n = t.nodeName.toLowerCase(); return ("input" === n || "button" === n) && t.type === e } }

        function de(e) { return function(t) { return "form" in t ? t.parentNode && !1 === t.disabled ? "label" in t ? "label" in t.parentNode ? t.parentNode.disabled === e : t.disabled === e : t.isDisabled === e || t.isDisabled !== !e && ie(t) === e : t.disabled === e : "label" in t && t.disabled === e } }

        function he(e) { return se(function(t) { return t = +t, se(function(n, r) { var i, o = e([], n.length, t),
                        a = o.length; while (a--) n[i = o[a]] && (n[i] = !(r[i] = n[i])) }) }) }

        function ge(e) { return e && "undefined" != typeof e.getElementsByTagName && e } n = oe.support = {}, o = oe.isXML = function(e) { var t = e && (e.ownerDocument || e).documentElement; return !!t && "HTML" !== t.nodeName }, p = oe.setDocument = function(e) { var t, i, a = e ? e.ownerDocument || e : w; return a !== d && 9 === a.nodeType && a.documentElement ? (d = a, h = d.documentElement, g = !o(d), w !== d && (i = d.defaultView) && i.top !== i && (i.addEventListener ? i.addEventListener("unload", re, !1) : i.attachEvent && i.attachEvent("onunload", re)), n.attributes = ue(function(e) { return e.className = "i", !e.getAttribute("className") }), n.getElementsByTagName = ue(function(e) { return e.appendChild(d.createComment("")), !e.getElementsByTagName("*").length }), n.getElementsByClassName = Q.test(d.getElementsByClassName), n.getById = ue(function(e) { return h.appendChild(e).id = b, !d.getElementsByName || !d.getElementsByName(b).length }), n.getById ? (r.filter.ID = function(e) { var t = e.replace(Z, ee); return function(e) { return e.getAttribute("id") === t } }, r.find.ID = function(e, t) { if ("undefined" != typeof t.getElementById && g) { var n = t.getElementById(e); return n ? [n] : [] } }) : (r.filter.ID = function(e) { var t = e.replace(Z, ee); return function(e) { var n = "undefined" != typeof e.getAttributeNode && e.getAttributeNode("id"); return n && n.value === t } }, r.find.ID = function(e, t) { if ("undefined" != typeof t.getElementById && g) { var n, r, i, o = t.getElementById(e); if (o) { if ((n = o.getAttributeNode("id")) && n.value === e) return [o];
                        i = t.getElementsByName(e), r = 0; while (o = i[r++])
                            if ((n = o.getAttributeNode("id")) && n.value === e) return [o] } return [] } }), r.find.TAG = n.getElementsByTagName ? function(e, t) { return "undefined" != typeof t.getElementsByTagName ? t.getElementsByTagName(e) : n.qsa ? t.querySelectorAll(e) : void 0 } : function(e, t) { var n, r = [],
                    i = 0,
                    o = t.getElementsByTagName(e); if ("*" === e) { while (n = o[i++]) 1 === n.nodeType && r.push(n); return r } return o }, r.find.CLASS = n.getElementsByClassName && function(e, t) { if ("undefined" != typeof t.getElementsByClassName && g) return t.getElementsByClassName(e) }, v = [], y = [], (n.qsa = Q.test(d.querySelectorAll)) && (ue(function(e) { h.appendChild(e).innerHTML = "<a id='" + b + "'></a><select id='" + b + "-\r\\' msallowcapture=''><option selected=''></option></select>", e.querySelectorAll("[msallowcapture^='']").length && y.push("[*^$]=" + M + "*(?:''|\"\")"), e.querySelectorAll("[selected]").length || y.push("\\[" + M + "*(?:value|" + P + ")"), e.querySelectorAll("[id~=" + b + "-]").length || y.push("~="), e.querySelectorAll(":checked").length || y.push(":checked"), e.querySelectorAll("a#" + b + "+*").length || y.push(".#.+[+~]") }), ue(function(e) { e.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>"; var t = d.createElement("input");
                t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && y.push("name" + M + "*[*^$|!~]?="), 2 !== e.querySelectorAll(":enabled").length && y.push(":enabled", ":disabled"), h.appendChild(e).disabled = !0, 2 !== e.querySelectorAll(":disabled").length && y.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), y.push(",.*:") })), (n.matchesSelector = Q.test(m = h.matches || h.webkitMatchesSelector || h.mozMatchesSelector || h.oMatchesSelector || h.msMatchesSelector)) && ue(function(e) { n.disconnectedMatch = m.call(e, "*"), m.call(e, "[s!='']:x"), v.push("!=", W) }), y = y.length && new RegExp(y.join("|")), v = v.length && new RegExp(v.join("|")), t = Q.test(h.compareDocumentPosition), x = t || Q.test(h.contains) ? function(e, t) { var n = 9 === e.nodeType ? e.documentElement : e,
                    r = t && t.parentNode; return e === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r))) } : function(e, t) { if (t)
                    while (t = t.parentNode)
                        if (t === e) return !0; return !1 }, D = t ? function(e, t) { if (e === t) return f = !0, 0; var r = !e.compareDocumentPosition - !t.compareDocumentPosition; return r || (1 & (r = (e.ownerDocument || e) === (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !n.sortDetached && t.compareDocumentPosition(e) === r ? e === d || e.ownerDocument === w && x(w, e) ? -1 : t === d || t.ownerDocument === w && x(w, t) ? 1 : c ? O(c, e) - O(c, t) : 0 : 4 & r ? -1 : 1) } : function(e, t) { if (e === t) return f = !0, 0; var n, r = 0,
                    i = e.parentNode,
                    o = t.parentNode,
                    a = [e],
                    s = [t]; if (!i || !o) return e === d ? -1 : t === d ? 1 : i ? -1 : o ? 1 : c ? O(c, e) - O(c, t) : 0; if (i === o) return ce(e, t);
                n = e; while (n = n.parentNode) a.unshift(n);
                n = t; while (n = n.parentNode) s.unshift(n); while (a[r] === s[r]) r++; return r ? ce(a[r], s[r]) : a[r] === w ? -1 : s[r] === w ? 1 : 0 }, d) : d }, oe.matches = function(e, t) { return oe(e, null, null, t) }, oe.matchesSelector = function(e, t) { if ((e.ownerDocument || e) !== d && p(e), t = t.replace(z, "='$1']"), n.matchesSelector && g && !S[t + " "] && (!v || !v.test(t)) && (!y || !y.test(t))) try { var r = m.call(e, t); if (r || n.disconnectedMatch || e.document && 11 !== e.document.nodeType) return r }
            catch (e) {} return oe(t, d, null, [e]).length > 0 }, oe.contains = function(e, t) { return (e.ownerDocument || e) !== d && p(e), x(e, t) }, oe.attr = function(e, t) {
            (e.ownerDocument || e) !== d && p(e); var i = r.attrHandle[t.toLowerCase()],
                o = i && N.call(r.attrHandle, t.toLowerCase()) ? i(e, t, !g) : void 0; return void 0 !== o ? o : n.attributes || !g ? e.getAttribute(t) : (o = e.getAttributeNode(t)) && o.specified ? o.value : null }, oe.escape = function(e) { return (e + "").replace(te, ne) }, oe.error = function(e) { throw new Error("Syntax error, unrecognized expression: " + e) }, oe.uniqueSort = function(e) { var t, r = [],
                i = 0,
                o = 0; if (f = !n.detectDuplicates, c = !n.sortStable && e.slice(0), e.sort(D), f) { while (t = e[o++]) t === e[o] && (i = r.push(o)); while (i--) e.splice(r[i], 1) } return c = null, e }, i = oe.getText = function(e) { var t, n = "",
                r = 0,
                o = e.nodeType; if (o) { if (1 === o || 9 === o || 11 === o) { if ("string" == typeof e.textContent) return e.textContent; for (e = e.firstChild; e; e = e.nextSibling) n += i(e) } else if (3 === o || 4 === o) return e.nodeValue } else
                while (t = e[r++]) n += i(t); return n }, (r = oe.selectors = { cacheLength: 50, createPseudo: se, match: V, attrHandle: {}, find: {}, relative: { ">": { dir: "parentNode", first: !0 }, " ": { dir: "parentNode" }, "+": { dir: "previousSibling", first: !0 }, "~": { dir: "previousSibling" } }, preFilter: { ATTR: function(e) { return e[1] = e[1].replace(Z, ee), e[3] = (e[3] || e[4] || e[5] || "").replace(Z, ee), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4) }, CHILD: function(e) { return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || oe.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && oe.error(e[0]), e }, PSEUDO: function(e) { var t, n = !e[6] && e[2]; return V.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : n && X.test(n) && (t = a(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3)) } }, filter: { TAG: function(e) { var t = e.replace(Z, ee).toLowerCase(); return "*" === e ? function() { return !0 } : function(e) { return e.nodeName && e.nodeName.toLowerCase() === t } }, CLASS: function(e) { var t = E[e + " "]; return t || (t = new RegExp("(^|" + M + ")" + e + "(" + M + "|$)")) && E(e, function(e) { return t.test("string" == typeof e.className && e.className || "undefined" != typeof e.getAttribute && e.getAttribute("class") || "") }) }, ATTR: function(e, t, n) { return function(r) { var i = oe.attr(r, e); return null == i ? "!=" === t : !t || (i += "", "=" === t ? i === n : "!=" === t ? i !== n : "^=" === t ? n && 0 === i.indexOf(n) : "*=" === t ? n && i.indexOf(n) > -1 : "$=" === t ? n && i.slice(-n.length) === n : "~=" === t ? (" " + i.replace($, " ") + " ").indexOf(n) > -1 : "|=" === t && (i === n || i.slice(0, n.length + 1) === n + "-")) } }, CHILD: function(e, t, n, r, i) { var o = "nth" !== e.slice(0, 3),
                        a = "last" !== e.slice(-4),
                        s = "of-type" === t; return 1 === r && 0 === i ? function(e) { return !!e.parentNode } : function(t, n, u) { var l, c, f, p, d, h, g = o !== a ? "nextSibling" : "previousSibling",
                            y = t.parentNode,
                            v = s && t.nodeName.toLowerCase(),
                            m = !u && !s,
                            x = !1; if (y) { if (o) { while (g) { p = t; while (p = p[g])
                                        if (s ? p.nodeName.toLowerCase() === v : 1 === p.nodeType) return !1;
                                    h = g = "only" === e && !h && "nextSibling" } return !0 } if (h = [a ? y.firstChild : y.lastChild], a && m) { x = (d = (l = (c = (f = (p = y)[b] || (p[b] = {}))[p.uniqueID] || (f[p.uniqueID] = {}))[e] || [])[0] === T && l[1]) && l[2], p = d && y.childNodes[d]; while (p = ++d && p && p[g] || (x = d = 0) || h.pop())
                                    if (1 === p.nodeType && ++x && p === t) { c[e] = [T, d, x]; break } } else if (m && (x = d = (l = (c = (f = (p = t)[b] || (p[b] = {}))[p.uniqueID] || (f[p.uniqueID] = {}))[e] || [])[0] === T && l[1]), !1 === x)
                                while (p = ++d && p && p[g] || (x = d = 0) || h.pop())
                                    if ((s ? p.nodeName.toLowerCase() === v : 1 === p.nodeType) && ++x && (m && ((c = (f = p[b] || (p[b] = {}))[p.uniqueID] || (f[p.uniqueID] = {}))[e] = [T, x]), p === t)) break; return (x -= i) === r || x % r == 0 && x / r >= 0 } } }, PSEUDO: function(e, t) { var n, i = r.pseudos[e] || r.setFilters[e.toLowerCase()] || oe.error("unsupported pseudo: " + e); return i[b] ? i(t) : i.length > 1 ? (n = [e, e, "", t], r.setFilters.hasOwnProperty(e.toLowerCase()) ? se(function(e, n) { var r, o = i(e, t),
                            a = o.length; while (a--) e[r = O(e, o[a])] = !(n[r] = o[a]) }) : function(e) { return i(e, 0, n) }) : i } }, pseudos: { not: se(function(e) { var t = [],
                        n = [],
                        r = s(e.replace(B, "$1")); return r[b] ? se(function(e, t, n, i) { var o, a = r(e, null, i, []),
                            s = e.length; while (s--)(o = a[s]) && (e[s] = !(t[s] = o)) }) : function(e, i, o) { return t[0] = e, r(t, null, o, n), t[0] = null, !n.pop() } }), has: se(function(e) { return function(t) { return oe(e, t).length > 0 } }), contains: se(function(e) { return e = e.replace(Z, ee),
                        function(t) { return (t.textContent || t.innerText || i(t)).indexOf(e) > -1 } }), lang: se(function(e) { return U.test(e || "") || oe.error("unsupported lang: " + e), e = e.replace(Z, ee).toLowerCase(),
                        function(t) { var n;
                            do { if (n = g ? t.lang : t.getAttribute("xml:lang") || t.getAttribute("lang")) return (n = n.toLowerCase()) === e || 0 === n.indexOf(e + "-") } while ((t = t.parentNode) && 1 === t.nodeType); return !1 } }), target: function(t) { var n = e.location && e.location.hash; return n && n.slice(1) === t.id }, root: function(e) { return e === h }, focus: function(e) { return e === d.activeElement && (!d.hasFocus || d.hasFocus()) && !!(e.type || e.href || ~e.tabIndex) }, enabled: de(!1), disabled: de(!0), checked: function(e) { var t = e.nodeName.toLowerCase(); return "input" === t && !!e.checked || "option" === t && !!e.selected }, selected: function(e) { return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected }, empty: function(e) { for (e = e.firstChild; e; e = e.nextSibling)
                        if (e.nodeType < 6) return !1; return !0 }, parent: function(e) { return !r.pseudos.empty(e) }, header: function(e) { return Y.test(e.nodeName) }, input: function(e) { return G.test(e.nodeName) }, button: function(e) { var t = e.nodeName.toLowerCase(); return "input" === t && "button" === e.type || "button" === t }, text: function(e) { var t; return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase()) }, first: he(function() { return [0] }), last: he(function(e, t) { return [t - 1] }), eq: he(function(e, t, n) { return [n < 0 ? n + t : n] }), even: he(function(e, t) { for (var n = 0; n < t; n += 2) e.push(n); return e }), odd: he(function(e, t) { for (var n = 1; n < t; n += 2) e.push(n); return e }), lt: he(function(e, t, n) { for (var r = n < 0 ? n + t : n; --r >= 0;) e.push(r); return e }), gt: he(function(e, t, n) { for (var r = n < 0 ? n + t : n; ++r < t;) e.push(r); return e }) } }).pseudos.nth = r.pseudos.eq; for (t in { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 }) r.pseudos[t] = fe(t); for (t in { submit: !0, reset: !0 }) r.pseudos[t] = pe(t);

        function ye() {} ye.prototype = r.filters = r.pseudos, r.setFilters = new ye, a = oe.tokenize = function(e, t) { var n, i, o, a, s, u, l, c = k[e + " "]; if (c) return t ? 0 : c.slice(0);
            s = e, u = [], l = r.preFilter; while (s) { n && !(i = F.exec(s)) || (i && (s = s.slice(i[0].length) || s), u.push(o = [])), n = !1, (i = _.exec(s)) && (n = i.shift(), o.push({ value: n, type: i[0].replace(B, " ") }), s = s.slice(n.length)); for (a in r.filter) !(i = V[a].exec(s)) || l[a] && !(i = l[a](i)) || (n = i.shift(), o.push({ value: n, type: a, matches: i }), s = s.slice(n.length)); if (!n) break } return t ? s.length : s ? oe.error(e) : k(e, u).slice(0) };

        function ve(e) { for (var t = 0, n = e.length, r = ""; t < n; t++) r += e[t].value; return r }

        function me(e, t, n) { var r = t.dir,
                i = t.next,
                o = i || r,
                a = n && "parentNode" === o,
                s = C++; return t.first ? function(t, n, i) { while (t = t[r])
                    if (1 === t.nodeType || a) return e(t, n, i); return !1 } : function(t, n, u) { var l, c, f, p = [T, s]; if (u) { while (t = t[r])
                        if ((1 === t.nodeType || a) && e(t, n, u)) return !0 } else
                    while (t = t[r])
                        if (1 === t.nodeType || a)
                            if (f = t[b] || (t[b] = {}), c = f[t.uniqueID] || (f[t.uniqueID] = {}), i && i === t.nodeName.toLowerCase()) t = t[r] || t;
                            else { if ((l = c[o]) && l[0] === T && l[1] === s) return p[2] = l[2]; if (c[o] = p, p[2] = e(t, n, u)) return !0 } return !1 } }

        function xe(e) { return e.length > 1 ? function(t, n, r) { var i = e.length; while (i--)
                    if (!e[i](t, n, r)) return !1; return !0 } : e[0] }

        function be(e, t, n) { for (var r = 0, i = t.length; r < i; r++) oe(e, t[r], n); return n }

        function we(e, t, n, r, i) { for (var o, a = [], s = 0, u = e.length, l = null != t; s < u; s++)(o = e[s]) && (n && !n(o, r, i) || (a.push(o), l && t.push(s))); return a }

        function Te(e, t, n, r, i, o) { return r && !r[b] && (r = Te(r)), i && !i[b] && (i = Te(i, o)), se(function(o, a, s, u) { var l, c, f, p = [],
                    d = [],
                    h = a.length,
                    g = o || be(t || "*", s.nodeType ? [s] : s, []),
                    y = !e || !o && t ? g : we(g, p, e, s, u),
                    v = n ? i || (o ? e : h || r) ? [] : a : y; if (n && n(y, v, s, u), r) { l = we(v, d), r(l, [], s, u), c = l.length; while (c--)(f = l[c]) && (v[d[c]] = !(y[d[c]] = f)) } if (o) { if (i || e) { if (i) { l = [], c = v.length; while (c--)(f = v[c]) && l.push(y[c] = f);
                            i(null, v = [], l, u) } c = v.length; while (c--)(f = v[c]) && (l = i ? O(o, f) : p[c]) > -1 && (o[l] = !(a[l] = f)) } } else v = we(v === a ? v.splice(h, v.length) : v), i ? i(null, a, v, u) : L.apply(a, v) }) }

        function Ce(e) { for (var t, n, i, o = e.length, a = r.relative[e[0].type], s = a || r.relative[" "], u = a ? 1 : 0, c = me(function(e) { return e === t }, s, !0), f = me(function(e) { return O(t, e) > -1 }, s, !0), p = [function(e, n, r) { var i = !a && (r || n !== l) || ((t = n).nodeType ? c(e, n, r) : f(e, n, r)); return t = null, i }]; u < o; u++)
                if (n = r.relative[e[u].type]) p = [me(xe(p), n)];
                else { if ((n = r.filter[e[u].type].apply(null, e[u].matches))[b]) { for (i = ++u; i < o; i++)
                            if (r.relative[e[i].type]) break; return Te(u > 1 && xe(p), u > 1 && ve(e.slice(0, u - 1).concat({ value: " " === e[u - 2].type ? "*" : "" })).replace(B, "$1"), n, u < i && Ce(e.slice(u, i)), i < o && Ce(e = e.slice(i)), i < o && ve(e)) } p.push(n) }
            return xe(p) }

        function Ee(e, t) { var n = t.length > 0,
                i = e.length > 0,
                o = function(o, a, s, u, c) { var f, h, y, v = 0,
                        m = "0",
                        x = o && [],
                        b = [],
                        w = l,
                        C = o || i && r.find.TAG("*", c),
                        E = T += null == w ? 1 : Math.random() || .1,
                        k = C.length; for (c && (l = a === d || a || c); m !== k && null != (f = C[m]); m++) { if (i && f) { h = 0, a || f.ownerDocument === d || (p(f), s = !g); while (y = e[h++])
                                if (y(f, a || d, s)) { u.push(f); break }
                            c && (T = E) } n && ((f = !y && f) && v--, o && x.push(f)) } if (v += m, n && m !== v) { h = 0; while (y = t[h++]) y(x, b, a, s); if (o) { if (v > 0)
                                while (m--) x[m] || b[m] || (b[m] = j.call(u));
                            b = we(b) } L.apply(u, b), c && !o && b.length > 0 && v + t.length > 1 && oe.uniqueSort(u) } return c && (T = E, l = w), x }; return n ? se(o) : o } return s = oe.compile = function(e, t) { var n, r = [],
                i = [],
                o = S[e + " "]; if (!o) { t || (t = a(e)), n = t.length; while (n--)(o = Ce(t[n]))[b] ? r.push(o) : i.push(o);
                (o = S(e, Ee(i, r))).selector = e } return o }, u = oe.select = function(e, t, n, i) { var o, u, l, c, f, p = "function" == typeof e && e,
                d = !i && a(e = p.selector || e); if (n = n || [], 1 === d.length) { if ((u = d[0] = d[0].slice(0)).length > 2 && "ID" === (l = u[0]).type && 9 === t.nodeType && g && r.relative[u[1].type]) { if (!(t = (r.find.ID(l.matches[0].replace(Z, ee), t) || [])[0])) return n;
                    p && (t = t.parentNode), e = e.slice(u.shift().value.length) } o = V.needsContext.test(e) ? 0 : u.length; while (o--) { if (l = u[o], r.relative[c = l.type]) break; if ((f = r.find[c]) && (i = f(l.matches[0].replace(Z, ee), K.test(u[0].type) && ge(t.parentNode) || t))) { if (u.splice(o, 1), !(e = i.length && ve(u))) return L.apply(n, i), n; break } } } return (p || s(e, d))(i, t, !g, n, !t || K.test(e) && ge(t.parentNode) || t), n }, n.sortStable = b.split("").sort(D).join("") === b, n.detectDuplicates = !!f, p(), n.sortDetached = ue(function(e) { return 1 & e.compareDocumentPosition(d.createElement("fieldset")) }), ue(function(e) { return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href") }) || le("type|href|height|width", function(e, t, n) { if (!n) return e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2) }), n.attributes && ue(function(e) { return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value") }) || le("value", function(e, t, n) { if (!n && "input" === e.nodeName.toLowerCase()) return e.defaultValue }), ue(function(e) { return null == e.getAttribute("disabled") }) || le(P, function(e, t, n) { var r; if (!n) return !0 === e[t] ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value : null }), oe }(e);
    w.find = E, w.expr = E.selectors, w.expr[":"] = w.expr.pseudos, w.uniqueSort = w.unique = E.uniqueSort, w.text = E.getText, w.isXMLDoc = E.isXML, w.contains = E.contains, w.escapeSelector = E.escape; var k = function(e, t, n) { var r = [],
                i = void 0 !== n; while ((e = e[t]) && 9 !== e.nodeType)
                if (1 === e.nodeType) { if (i && w(e).is(n)) break;
                    r.push(e) }
            return r },
        S = function(e, t) { for (var n = []; e; e = e.nextSibling) 1 === e.nodeType && e !== t && n.push(e); return n },
        D = w.expr.match.needsContext;

    function N(e, t) { return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase() } var A = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;

    function j(e, t, n) { return g(t) ? w.grep(e, function(e, r) { return !!t.call(e, r, e) !== n }) : t.nodeType ? w.grep(e, function(e) { return e === t !== n }) : "string" != typeof t ? w.grep(e, function(e) { return u.call(t, e) > -1 !== n }) : w.filter(t, e, n) } w.filter = function(e, t, n) { var r = t[0]; return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === r.nodeType ? w.find.matchesSelector(r, e) ? [r] : [] : w.find.matches(e, w.grep(t, function(e) { return 1 === e.nodeType })) }, w.fn.extend({ find: function(e) { var t, n, r = this.length,
                i = this; if ("string" != typeof e) return this.pushStack(w(e).filter(function() { for (t = 0; t < r; t++)
                    if (w.contains(i[t], this)) return !0 })); for (n = this.pushStack([]), t = 0; t < r; t++) w.find(e, i[t], n); return r > 1 ? w.uniqueSort(n) : n }, filter: function(e) { return this.pushStack(j(this, e || [], !1)) }, not: function(e) { return this.pushStack(j(this, e || [], !0)) }, is: function(e) { return !!j(this, "string" == typeof e && D.test(e) ? w(e) : e || [], !1).length } }); var q, L = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
    (w.fn.init = function(e, t, n) { var i, o; if (!e) return this; if (n = n || q, "string" == typeof e) { if (!(i = "<" === e[0] && ">" === e[e.length - 1] && e.length >= 3 ? [null, e, null] : L.exec(e)) || !i[1] && t) return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e); if (i[1]) { if (t = t instanceof w ? t[0] : t, w.merge(this, w.parseHTML(i[1], t && t.nodeType ? t.ownerDocument || t : r, !0)), A.test(i[1]) && w.isPlainObject(t))
                    for (i in t) g(this[i]) ? this[i](t[i]) : this.attr(i, t[i]); return this } return (o = r.getElementById(i[2])) && (this[0] = o, this.length = 1), this } return e.nodeType ? (this[0] = e, this.length = 1, this) : g(e) ? void 0 !== n.ready ? n.ready(e) : e(w) : w.makeArray(e, this) }).prototype = w.fn, q = w(r); var H = /^(?:parents|prev(?:Until|All))/,
        O = { children: !0, contents: !0, next: !0, prev: !0 };
    w.fn.extend({ has: function(e) { var t = w(e, this),
                n = t.length; return this.filter(function() { for (var e = 0; e < n; e++)
                    if (w.contains(this, t[e])) return !0 }) }, closest: function(e, t) { var n, r = 0,
                i = this.length,
                o = [],
                a = "string" != typeof e && w(e); if (!D.test(e))
                for (; r < i; r++)
                    for (n = this[r]; n && n !== t; n = n.parentNode)
                        if (n.nodeType < 11 && (a ? a.index(n) > -1 : 1 === n.nodeType && w.find.matchesSelector(n, e))) { o.push(n); break }
            return this.pushStack(o.length > 1 ? w.uniqueSort(o) : o) }, index: function(e) { return e ? "string" == typeof e ? u.call(w(e), this[0]) : u.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1 }, add: function(e, t) { return this.pushStack(w.uniqueSort(w.merge(this.get(), w(e, t)))) }, addBack: function(e) { return this.add(null == e ? this.prevObject : this.prevObject.filter(e)) } });

    function P(e, t) { while ((e = e[t]) && 1 !== e.nodeType); return e } w.each({ parent: function(e) { var t = e.parentNode; return t && 11 !== t.nodeType ? t : null }, parents: function(e) { return k(e, "parentNode") }, parentsUntil: function(e, t, n) { return k(e, "parentNode", n) }, next: function(e) { return P(e, "nextSibling") }, prev: function(e) { return P(e, "previousSibling") }, nextAll: function(e) { return k(e, "nextSibling") }, prevAll: function(e) { return k(e, "previousSibling") }, nextUntil: function(e, t, n) { return k(e, "nextSibling", n) }, prevUntil: function(e, t, n) { return k(e, "previousSibling", n) }, siblings: function(e) { return S((e.parentNode || {}).firstChild, e) }, children: function(e) { return S(e.firstChild) }, contents: function(e) { return N(e, "iframe") ? e.contentDocument : (N(e, "template") && (e = e.content || e), w.merge([], e.childNodes)) } }, function(e, t) { w.fn[e] = function(n, r) { var i = w.map(this, t, n); return "Until" !== e.slice(-5) && (r = n), r && "string" == typeof r && (i = w.filter(r, i)), this.length > 1 && (O[e] || w.uniqueSort(i), H.test(e) && i.reverse()), this.pushStack(i) } }); var M = /[^\x20\t\r\n\f]+/g;

    function R(e) { var t = {}; return w.each(e.match(M) || [], function(e, n) { t[n] = !0 }), t } w.Callbacks = function(e) { e = "string" == typeof e ? R(e) : w.extend({}, e); var t, n, r, i, o = [],
            a = [],
            s = -1,
            u = function() { for (i = i || e.once, r = t = !0; a.length; s = -1) { n = a.shift(); while (++s < o.length) !1 === o[s].apply(n[0], n[1]) && e.stopOnFalse && (s = o.length, n = !1) } e.memory || (n = !1), t = !1, i && (o = n ? [] : "") },
            l = { add: function() { return o && (n && !t && (s = o.length - 1, a.push(n)), function t(n) { w.each(n, function(n, r) { g(r) ? e.unique && l.has(r) || o.push(r) : r && r.length && "string" !== x(r) && t(r) }) }(arguments), n && !t && u()), this }, remove: function() { return w.each(arguments, function(e, t) { var n; while ((n = w.inArray(t, o, n)) > -1) o.splice(n, 1), n <= s && s-- }), this }, has: function(e) { return e ? w.inArray(e, o) > -1 : o.length > 0 }, empty: function() { return o && (o = []), this }, disable: function() { return i = a = [], o = n = "", this }, disabled: function() { return !o }, lock: function() { return i = a = [], n || t || (o = n = ""), this }, locked: function() { return !!i }, fireWith: function(e, n) { return i || (n = [e, (n = n || []).slice ? n.slice() : n], a.push(n), t || u()), this }, fire: function() { return l.fireWith(this, arguments), this }, fired: function() { return !!r } }; return l };

    function I(e) { return e }

    function W(e) { throw e }

    function $(e, t, n, r) { var i; try { e && g(i = e.promise) ? i.call(e).done(t).fail(n) : e && g(i = e.then) ? i.call(e, t, n) : t.apply(void 0, [e].slice(r)) } catch (e) { n.apply(void 0, [e]) } } w.extend({ Deferred: function(t) { var n = [
                    ["notify", "progress", w.Callbacks("memory"), w.Callbacks("memory"), 2],
                    ["resolve", "done", w.Callbacks("once memory"), w.Callbacks("once memory"), 0, "resolved"],
                    ["reject", "fail", w.Callbacks("once memory"), w.Callbacks("once memory"), 1, "rejected"]
                ],
                r = "pending",
                i = { state: function() { return r }, always: function() { return o.done(arguments).fail(arguments), this }, "catch": function(e) { return i.then(null, e) }, pipe: function() { var e = arguments; return w.Deferred(function(t) { w.each(n, function(n, r) { var i = g(e[r[4]]) && e[r[4]];
                                o[r[1]](function() { var e = i && i.apply(this, arguments);
                                    e && g(e.promise) ? e.promise().progress(t.notify).done(t.resolve).fail(t.reject) : t[r[0] + "With"](this, i ? [e] : arguments) }) }), e = null }).promise() }, then: function(t, r, i) { var o = 0;

                        function a(t, n, r, i) { return function() { var s = this,
                                    u = arguments,
                                    l = function() { var e, l; if (!(t < o)) { if ((e = r.apply(s, u)) === n.promise()) throw new TypeError("Thenable self-resolution");
                                            l = e && ("object" == typeof e || "function" == typeof e) && e.then, g(l) ? i ? l.call(e, a(o, n, I, i), a(o, n, W, i)) : (o++, l.call(e, a(o, n, I, i), a(o, n, W, i), a(o, n, I, n.notifyWith))) : (r !== I && (s = void 0, u = [e]), (i || n.resolveWith)(s, u)) } },
                                    c = i ? l : function() { try { l() } catch (e) { w.Deferred.exceptionHook && w.Deferred.exceptionHook(e, c.stackTrace), t + 1 >= o && (r !== W && (s = void 0, u = [e]), n.rejectWith(s, u)) } };
                                t ? c() : (w.Deferred.getStackHook && (c.stackTrace = w.Deferred.getStackHook()), e.setTimeout(c)) } } return w.Deferred(function(e) { n[0][3].add(a(0, e, g(i) ? i : I, e.notifyWith)), n[1][3].add(a(0, e, g(t) ? t : I)), n[2][3].add(a(0, e, g(r) ? r : W)) }).promise() }, promise: function(e) { return null != e ? w.extend(e, i) : i } },
                o = {}; return w.each(n, function(e, t) { var a = t[2],
                    s = t[5];
                i[t[1]] = a.add, s && a.add(function() { r = s }, n[3 - e][2].disable, n[3 - e][3].disable, n[0][2].lock, n[0][3].lock), a.add(t[3].fire), o[t[0]] = function() { return o[t[0] + "With"](this === o ? void 0 : this, arguments), this }, o[t[0] + "With"] = a.fireWith }), i.promise(o), t && t.call(o, o), o }, when: function(e) { var t = arguments.length,
                n = t,
                r = Array(n),
                i = o.call(arguments),
                a = w.Deferred(),
                s = function(e) { return function(n) { r[e] = this, i[e] = arguments.length > 1 ? o.call(arguments) : n, --t || a.resolveWith(r, i) } }; if (t <= 1 && ($(e, a.done(s(n)).resolve, a.reject, !t), "pending" === a.state() || g(i[n] && i[n].then))) return a.then(); while (n--) $(i[n], s(n), a.reject); return a.promise() } }); var B = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
    w.Deferred.exceptionHook = function(t, n) { e.console && e.console.warn && t && B.test(t.name) && e.console.warn("jQuery.Deferred exception: " + t.message, t.stack, n) }, w.readyException = function(t) { e.setTimeout(function() { throw t }) }; var F = w.Deferred();
    w.fn.ready = function(e) { return F.then(e)["catch"](function(e) { w.readyException(e) }), this }, w.extend({ isReady: !1, readyWait: 1, ready: function(e) {
            (!0 === e ? --w.readyWait : w.isReady) || (w.isReady = !0, !0 !== e && --w.readyWait > 0 || F.resolveWith(r, [w])) } }), w.ready.then = F.then;

    function _() { r.removeEventListener("DOMContentLoaded", _), e.removeEventListener("load", _), w.ready() } "complete" === r.readyState || "loading" !== r.readyState && !r.documentElement.doScroll ? e.setTimeout(w.ready) : (r.addEventListener("DOMContentLoaded", _), e.addEventListener("load", _)); var z = function(e, t, n, r, i, o, a) { var s = 0,
                u = e.length,
                l = null == n; if ("object" === x(n)) { i = !0; for (s in n) z(e, t, s, n[s], !0, o, a) } else if (void 0 !== r && (i = !0, g(r) || (a = !0), l && (a ? (t.call(e, r), t = null) : (l = t, t = function(e, t, n) { return l.call(w(e), n) })), t))
                for (; s < u; s++) t(e[s], n, a ? r : r.call(e[s], s, t(e[s], n))); return i ? e : l ? t.call(e) : u ? t(e[0], n) : o },
        X = /^-ms-/,
        U = /-([a-z])/g;

    function V(e, t) { return t.toUpperCase() }

    function G(e) { return e.replace(X, "ms-").replace(U, V) } var Y = function(e) { return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType };

    function Q() { this.expando = w.expando + Q.uid++ } Q.uid = 1, Q.prototype = { cache: function(e) { var t = e[this.expando]; return t || (t = {}, Y(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, { value: t, configurable: !0 }))), t }, set: function(e, t, n) { var r, i = this.cache(e); if ("string" == typeof t) i[G(t)] = n;
            else
                for (r in t) i[G(r)] = t[r]; return i }, get: function(e, t) { return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][G(t)] }, access: function(e, t, n) { return void 0 === t || t && "string" == typeof t && void 0 === n ? this.get(e, t) : (this.set(e, t, n), void 0 !== n ? n : t) }, remove: function(e, t) { var n, r = e[this.expando]; if (void 0 !== r) { if (void 0 !== t) { n = (t = Array.isArray(t) ? t.map(G) : (t = G(t)) in r ? [t] : t.match(M) || []).length; while (n--) delete r[t[n]] }(void 0 === t || w.isEmptyObject(r)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando]) } }, hasData: function(e) { var t = e[this.expando]; return void 0 !== t && !w.isEmptyObject(t) } }; var J = new Q,
        K = new Q,
        Z = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
        ee = /[A-Z]/g;

    function te(e) { return "true" === e || "false" !== e && ("null" === e ? null : e === +e + "" ? +e : Z.test(e) ? JSON.parse(e) : e) }

    function ne(e, t, n) { var r; if (void 0 === n && 1 === e.nodeType)
            if (r = "data-" + t.replace(ee, "-$&").toLowerCase(), "string" == typeof(n = e.getAttribute(r))) { try { n = te(n) } catch (e) {} K.set(e, t, n) }
        else n = void 0; return n } w.extend({ hasData: function(e) { return K.hasData(e) || J.hasData(e) }, data: function(e, t, n) { return K.access(e, t, n) }, removeData: function(e, t) { K.remove(e, t) }, _data: function(e, t, n) { return J.access(e, t, n) }, _removeData: function(e, t) { J.remove(e, t) } }), w.fn.extend({ data: function(e, t) { var n, r, i, o = this[0],
                a = o && o.attributes; if (void 0 === e) { if (this.length && (i = K.get(o), 1 === o.nodeType && !J.get(o, "hasDataAttrs"))) { n = a.length; while (n--) a[n] && 0 === (r = a[n].name).indexOf("data-") && (r = G(r.slice(5)), ne(o, r, i[r]));
                    J.set(o, "hasDataAttrs", !0) } return i } return "object" == typeof e ? this.each(function() { K.set(this, e) }) : z(this, function(t) { var n; if (o && void 0 === t) { if (void 0 !== (n = K.get(o, e))) return n; if (void 0 !== (n = ne(o, e))) return n } else this.each(function() { K.set(this, e, t) }) }, null, t, arguments.length > 1, null, !0) }, removeData: function(e) { return this.each(function() { K.remove(this, e) }) } }), w.extend({ queue: function(e, t, n) { var r; if (e) return t = (t || "fx") + "queue", r = J.get(e, t), n && (!r || Array.isArray(n) ? r = J.access(e, t, w.makeArray(n)) : r.push(n)), r || [] }, dequeue: function(e, t) { t = t || "fx"; var n = w.queue(e, t),
                r = n.length,
                i = n.shift(),
                o = w._queueHooks(e, t),
                a = function() { w.dequeue(e, t) }; "inprogress" === i && (i = n.shift(), r--), i && ("fx" === t && n.unshift("inprogress"), delete o.stop, i.call(e, a, o)), !r && o && o.empty.fire() }, _queueHooks: function(e, t) { var n = t + "queueHooks"; return J.get(e, n) || J.access(e, n, { empty: w.Callbacks("once memory").add(function() { J.remove(e, [t + "queue", n]) }) }) } }), w.fn.extend({ queue: function(e, t) { var n = 2; return "string" != typeof e && (t = e, e = "fx", n--), arguments.length < n ? w.queue(this[0], e) : void 0 === t ? this : this.each(function() { var n = w.queue(this, e, t);
                w._queueHooks(this, e), "fx" === e && "inprogress" !== n[0] && w.dequeue(this, e) }) }, dequeue: function(e) { return this.each(function() { w.dequeue(this, e) }) }, clearQueue: function(e) { return this.queue(e || "fx", []) }, promise: function(e, t) { var n, r = 1,
                i = w.Deferred(),
                o = this,
                a = this.length,
                s = function() {--r || i.resolveWith(o, [o]) }; "string" != typeof e && (t = e, e = void 0), e = e || "fx"; while (a--)(n = J.get(o[a], e + "queueHooks")) && n.empty && (r++, n.empty.add(s)); return s(), i.promise(t) } }); var re = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
        ie = new RegExp("^(?:([+-])=|)(" + re + ")([a-z%]*)$", "i"),
        oe = ["Top", "Right", "Bottom", "Left"],
        ae = function(e, t) { return "none" === (e = t || e).style.display || "" === e.style.display && w.contains(e.ownerDocument, e) && "none" === w.css(e, "display") },
        se = function(e, t, n, r) { var i, o, a = {}; for (o in t) a[o] = e.style[o], e.style[o] = t[o];
            i = n.apply(e, r || []); for (o in t) e.style[o] = a[o]; return i };

    function ue(e, t, n, r) { var i, o, a = 20,
            s = r ? function() { return r.cur() } : function() { return w.css(e, t, "") },
            u = s(),
            l = n && n[3] || (w.cssNumber[t] ? "" : "px"),
            c = (w.cssNumber[t] || "px" !== l && +u) && ie.exec(w.css(e, t)); if (c && c[3] !== l) { u /= 2, l = l || c[3], c = +u || 1; while (a--) w.style(e, t, c + l), (1 - o) * (1 - (o = s() / u || .5)) <= 0 && (a = 0), c /= o;
            c *= 2, w.style(e, t, c + l), n = n || [] } return n && (c = +c || +u || 0, i = n[1] ? c + (n[1] + 1) * n[2] : +n[2], r && (r.unit = l, r.start = c, r.end = i)), i } var le = {};

    function ce(e) { var t, n = e.ownerDocument,
            r = e.nodeName,
            i = le[r]; return i || (t = n.body.appendChild(n.createElement(r)), i = w.css(t, "display"), t.parentNode.removeChild(t), "none" === i && (i = "block"), le[r] = i, i) }

    function fe(e, t) { for (var n, r, i = [], o = 0, a = e.length; o < a; o++)(r = e[o]).style && (n = r.style.display, t ? ("none" === n && (i[o] = J.get(r, "display") || null, i[o] || (r.style.display = "")), "" === r.style.display && ae(r) && (i[o] = ce(r))) : "none" !== n && (i[o] = "none", J.set(r, "display", n))); for (o = 0; o < a; o++) null != i[o] && (e[o].style.display = i[o]); return e } w.fn.extend({ show: function() { return fe(this, !0) }, hide: function() { return fe(this) }, toggle: function(e) { return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function() { ae(this) ? w(this).show() : w(this).hide() }) } }); var pe = /^(?:checkbox|radio)$/i,
        de = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i,
        he = /^$|^module$|\/(?:java|ecma)script/i,
        ge = { option: [1, "<select multiple='multiple'>", "</select>"], thead: [1, "<table>", "</table>"], col: [2, "<table><colgroup>", "</colgroup></table>"], tr: [2, "<table><tbody>", "</tbody></table>"], td: [3, "<table><tbody><tr>", "</tr></tbody></table>"], _default: [0, "", ""] };
    ge.optgroup = ge.option, ge.tbody = ge.tfoot = ge.colgroup = ge.caption = ge.thead, ge.th = ge.td;

    function ye(e, t) { var n; return n = "undefined" != typeof e.getElementsByTagName ? e.getElementsByTagName(t || "*") : "undefined" != typeof e.querySelectorAll ? e.querySelectorAll(t || "*") : [], void 0 === t || t && N(e, t) ? w.merge([e], n) : n }

    function ve(e, t) { for (var n = 0, r = e.length; n < r; n++) J.set(e[n], "globalEval", !t || J.get(t[n], "globalEval")) } var me = /<|&#?\w+;/;

    function xe(e, t, n, r, i) { for (var o, a, s, u, l, c, f = t.createDocumentFragment(), p = [], d = 0, h = e.length; d < h; d++)
            if ((o = e[d]) || 0 === o)
                if ("object" === x(o)) w.merge(p, o.nodeType ? [o] : o);
                else if (me.test(o)) { a = a || f.appendChild(t.createElement("div")), s = (de.exec(o) || ["", ""])[1].toLowerCase(), u = ge[s] || ge._default, a.innerHTML = u[1] + w.htmlPrefilter(o) + u[2], c = u[0]; while (c--) a = a.lastChild;
            w.merge(p, a.childNodes), (a = f.firstChild).textContent = "" } else p.push(t.createTextNode(o));
        f.textContent = "", d = 0; while (o = p[d++])
            if (r && w.inArray(o, r) > -1) i && i.push(o);
            else if (l = w.contains(o.ownerDocument, o), a = ye(f.appendChild(o), "script"), l && ve(a), n) { c = 0; while (o = a[c++]) he.test(o.type || "") && n.push(o) } return f }! function() { var e = r.createDocumentFragment().appendChild(r.createElement("div")),
            t = r.createElement("input");
        t.setAttribute("type", "radio"), t.setAttribute("checked", "checked"), t.setAttribute("name", "t"), e.appendChild(t), h.checkClone = e.cloneNode(!0).cloneNode(!0).lastChild.checked, e.innerHTML = "<textarea>x</textarea>", h.noCloneChecked = !!e.cloneNode(!0).lastChild.defaultValue }(); var be = r.documentElement,
        we = /^key/,
        Te = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
        Ce = /^([^.]*)(?:\.(.+)|)/;

    function Ee() { return !0 }

    function ke() { return !1 }

    function Se() { try { return r.activeElement } catch (e) {} }

    function De(e, t, n, r, i, o) { var a, s; if ("object" == typeof t) { "string" != typeof n && (r = r || n, n = void 0); for (s in t) De(e, s, n, r, t[s], o); return e } if (null == r && null == i ? (i = n, r = n = void 0) : null == i && ("string" == typeof n ? (i = r, r = void 0) : (i = r, r = n, n = void 0)), !1 === i) i = ke;
        else if (!i) return e; return 1 === o && (a = i, (i = function(e) { return w().off(e), a.apply(this, arguments) }).guid = a.guid || (a.guid = w.guid++)), e.each(function() { w.event.add(this, t, i, r, n) }) } w.event = { global: {}, add: function(e, t, n, r, i) { var o, a, s, u, l, c, f, p, d, h, g, y = J.get(e); if (y) { n.handler && (n = (o = n).handler, i = o.selector), i && w.find.matchesSelector(be, i), n.guid || (n.guid = w.guid++), (u = y.events) || (u = y.events = {}), (a = y.handle) || (a = y.handle = function(t) { return "undefined" != typeof w && w.event.triggered !== t.type ? w.event.dispatch.apply(e, arguments) : void 0 }), l = (t = (t || "").match(M) || [""]).length; while (l--) d = g = (s = Ce.exec(t[l]) || [])[1], h = (s[2] || "").split(".").sort(), d && (f = w.event.special[d] || {}, d = (i ? f.delegateType : f.bindType) || d, f = w.event.special[d] || {}, c = w.extend({ type: d, origType: g, data: r, handler: n, guid: n.guid, selector: i, needsContext: i && w.expr.match.needsContext.test(i), namespace: h.join(".") }, o), (p = u[d]) || ((p = u[d] = []).delegateCount = 0, f.setup && !1 !== f.setup.call(e, r, h, a) || e.addEventListener && e.addEventListener(d, a)), f.add && (f.add.call(e, c), c.handler.guid || (c.handler.guid = n.guid)), i ? p.splice(p.delegateCount++, 0, c) : p.push(c), w.event.global[d] = !0) } }, remove: function(e, t, n, r, i) { var o, a, s, u, l, c, f, p, d, h, g, y = J.hasData(e) && J.get(e); if (y && (u = y.events)) { l = (t = (t || "").match(M) || [""]).length; while (l--)
                    if (s = Ce.exec(t[l]) || [], d = g = s[1], h = (s[2] || "").split(".").sort(), d) { f = w.event.special[d] || {}, p = u[d = (r ? f.delegateType : f.bindType) || d] || [], s = s[2] && new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)"), a = o = p.length; while (o--) c = p[o], !i && g !== c.origType || n && n.guid !== c.guid || s && !s.test(c.namespace) || r && r !== c.selector && ("**" !== r || !c.selector) || (p.splice(o, 1), c.selector && p.delegateCount--, f.remove && f.remove.call(e, c));
                        a && !p.length && (f.teardown && !1 !== f.teardown.call(e, h, y.handle) || w.removeEvent(e, d, y.handle), delete u[d]) }
                else
                    for (d in u) w.event.remove(e, d + t[l], n, r, !0);
                w.isEmptyObject(u) && J.remove(e, "handle events") } }, dispatch: function(e) { var t = w.event.fix(e),
                n, r, i, o, a, s, u = new Array(arguments.length),
                l = (J.get(this, "events") || {})[t.type] || [],
                c = w.event.special[t.type] || {}; for (u[0] = t, n = 1; n < arguments.length; n++) u[n] = arguments[n]; if (t.delegateTarget = this, !c.preDispatch || !1 !== c.preDispatch.call(this, t)) { s = w.event.handlers.call(this, t, l), n = 0; while ((o = s[n++]) && !t.isPropagationStopped()) { t.currentTarget = o.elem, r = 0; while ((a = o.handlers[r++]) && !t.isImmediatePropagationStopped()) t.rnamespace && !t.rnamespace.test(a.namespace) || (t.handleObj = a, t.data = a.data, void 0 !== (i = ((w.event.special[a.origType] || {}).handle || a.handler).apply(o.elem, u)) && !1 === (t.result = i) && (t.preventDefault(), t.stopPropagation())) } return c.postDispatch && c.postDispatch.call(this, t), t.result } }, handlers: function(e, t) { var n, r, i, o, a, s = [],
                u = t.delegateCount,
                l = e.target; if (u && l.nodeType && !("click" === e.type && e.button >= 1))
                for (; l !== this; l = l.parentNode || this)
                    if (1 === l.nodeType && ("click" !== e.type || !0 !== l.disabled)) { for (o = [], a = {}, n = 0; n < u; n++) void 0 === a[i = (r = t[n]).selector + " "] && (a[i] = r.needsContext ? w(i, this).index(l) > -1 : w.find(i, this, null, [l]).length), a[i] && o.push(r);
                        o.length && s.push({ elem: l, handlers: o }) }
            return l = this, u < t.length && s.push({ elem: l, handlers: t.slice(u) }), s }, addProp: function(e, t) { Object.defineProperty(w.Event.prototype, e, { enumerable: !0, configurable: !0, get: g(t) ? function() { if (this.originalEvent) return t(this.originalEvent) } : function() { if (this.originalEvent) return this.originalEvent[e] }, set: function(t) { Object.defineProperty(this, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) } }) }, fix: function(e) { return e[w.expando] ? e : new w.Event(e) }, special: { load: { noBubble: !0 }, focus: { trigger: function() { if (this !== Se() && this.focus) return this.focus(), !1 }, delegateType: "focusin" }, blur: { trigger: function() { if (this === Se() && this.blur) return this.blur(), !1 }, delegateType: "focusout" }, click: { trigger: function() { if ("checkbox" === this.type && this.click && N(this, "input")) return this.click(), !1 }, _default: function(e) { return N(e.target, "a") } }, beforeunload: { postDispatch: function(e) { void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result) } } } }, w.removeEvent = function(e, t, n) { e.removeEventListener && e.removeEventListener(t, n) }, w.Event = function(e, t) { if (!(this instanceof w.Event)) return new w.Event(e, t);
        e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? Ee : ke, this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, t && w.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[w.expando] = !0 }, w.Event.prototype = { constructor: w.Event, isDefaultPrevented: ke, isPropagationStopped: ke, isImmediatePropagationStopped: ke, isSimulated: !1, preventDefault: function() { var e = this.originalEvent;
            this.isDefaultPrevented = Ee, e && !this.isSimulated && e.preventDefault() }, stopPropagation: function() { var e = this.originalEvent;
            this.isPropagationStopped = Ee, e && !this.isSimulated && e.stopPropagation() }, stopImmediatePropagation: function() { var e = this.originalEvent;
            this.isImmediatePropagationStopped = Ee, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation() } }, w.each({ altKey: !0, bubbles: !0, cancelable: !0, changedTouches: !0, ctrlKey: !0, detail: !0, eventPhase: !0, metaKey: !0, pageX: !0, pageY: !0, shiftKey: !0, view: !0, "char": !0, charCode: !0, key: !0, keyCode: !0, button: !0, buttons: !0, clientX: !0, clientY: !0, offsetX: !0, offsetY: !0, pointerId: !0, pointerType: !0, screenX: !0, screenY: !0, targetTouches: !0, toElement: !0, touches: !0, which: function(e) { var t = e.button; return null == e.which && we.test(e.type) ? null != e.charCode ? e.charCode : e.keyCode : !e.which && void 0 !== t && Te.test(e.type) ? 1 & t ? 1 : 2 & t ? 3 : 4 & t ? 2 : 0 : e.which } }, w.event.addProp), w.each({ mouseenter: "mouseover", mouseleave: "mouseout", pointerenter: "pointerover", pointerleave: "pointerout" }, function(e, t) { w.event.special[e] = { delegateType: t, bindType: t, handle: function(e) { var n, r = this,
                    i = e.relatedTarget,
                    o = e.handleObj; return i && (i === r || w.contains(r, i)) || (e.type = o.origType, n = o.handler.apply(this, arguments), e.type = t), n } } }), w.fn.extend({ on: function(e, t, n, r) { return De(this, e, t, n, r) }, one: function(e, t, n, r) { return De(this, e, t, n, r, 1) }, off: function(e, t, n) { var r, i; if (e && e.preventDefault && e.handleObj) return r = e.handleObj, w(e.delegateTarget).off(r.namespace ? r.origType + "." + r.namespace : r.origType, r.selector, r.handler), this; if ("object" == typeof e) { for (i in e) this.off(i, t, e[i]); return this } return !1 !== t && "function" != typeof t || (n = t, t = void 0), !1 === n && (n = ke), this.each(function() { w.event.remove(this, e, n, t) }) } }); var Ne = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
        Ae = /<script|<style|<link/i,
        je = /checked\s*(?:[^=]|=\s*.checked.)/i,
        qe = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

    function Le(e, t) { return N(e, "table") && N(11 !== t.nodeType ? t : t.firstChild, "tr") ? w(e).children("tbody")[0] || e : e }

    function He(e) { return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e }

    function Oe(e) { return "true/" === (e.type || "").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute("type"), e }

    function Pe(e, t) { var n, r, i, o, a, s, u, l; if (1 === t.nodeType) { if (J.hasData(e) && (o = J.access(e), a = J.set(t, o), l = o.events)) { delete a.handle, a.events = {}; for (i in l)
                    for (n = 0, r = l[i].length; n < r; n++) w.event.add(t, i, l[i][n]) } K.hasData(e) && (s = K.access(e), u = w.extend({}, s), K.set(t, u)) } }

    function Me(e, t) { var n = t.nodeName.toLowerCase(); "input" === n && pe.test(e.type) ? t.checked = e.checked : "input" !== n && "textarea" !== n || (t.defaultValue = e.defaultValue) }

    function Re(e, t, n, r) { t = a.apply([], t); var i, o, s, u, l, c, f = 0,
            p = e.length,
            d = p - 1,
            y = t[0],
            v = g(y); if (v || p > 1 && "string" == typeof y && !h.checkClone && je.test(y)) return e.each(function(i) { var o = e.eq(i);
            v && (t[0] = y.call(this, i, o.html())), Re(o, t, n, r) }); if (p && (i = xe(t, e[0].ownerDocument, !1, e, r), o = i.firstChild, 1 === i.childNodes.length && (i = o), o || r)) { for (u = (s = w.map(ye(i, "script"), He)).length; f < p; f++) l = i, f !== d && (l = w.clone(l, !0, !0), u && w.merge(s, ye(l, "script"))), n.call(e[f], l, f); if (u)
                for (c = s[s.length - 1].ownerDocument, w.map(s, Oe), f = 0; f < u; f++) l = s[f], he.test(l.type || "") && !J.access(l, "globalEval") && w.contains(c, l) && (l.src && "module" !== (l.type || "").toLowerCase() ? w._evalUrl && w._evalUrl(l.src) : m(l.textContent.replace(qe, ""), c, l)) } return e }

    function Ie(e, t, n) { for (var r, i = t ? w.filter(t, e) : e, o = 0; null != (r = i[o]); o++) n || 1 !== r.nodeType || w.cleanData(ye(r)), r.parentNode && (n && w.contains(r.ownerDocument, r) && ve(ye(r, "script")), r.parentNode.removeChild(r)); return e } w.extend({ htmlPrefilter: function(e) { return e.replace(Ne, "<$1></$2>") }, clone: function(e, t, n) { var r, i, o, a, s = e.cloneNode(!0),
                u = w.contains(e.ownerDocument, e); if (!(h.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || w.isXMLDoc(e)))
                for (a = ye(s), r = 0, i = (o = ye(e)).length; r < i; r++) Me(o[r], a[r]); if (t)
                if (n)
                    for (o = o || ye(e), a = a || ye(s), r = 0, i = o.length; r < i; r++) Pe(o[r], a[r]);
                else Pe(e, s); return (a = ye(s, "script")).length > 0 && ve(a, !u && ye(e, "script")), s }, cleanData: function(e) { for (var t, n, r, i = w.event.special, o = 0; void 0 !== (n = e[o]); o++)
                if (Y(n)) { if (t = n[J.expando]) { if (t.events)
                            for (r in t.events) i[r] ? w.event.remove(n, r) : w.removeEvent(n, r, t.handle);
                        n[J.expando] = void 0 } n[K.expando] && (n[K.expando] = void 0) } } }), w.fn.extend({ detach: function(e) { return Ie(this, e, !0) }, remove: function(e) { return Ie(this, e) }, text: function(e) { return z(this, function(e) { return void 0 === e ? w.text(this) : this.empty().each(function() { 1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e) }) }, null, e, arguments.length) }, append: function() { return Re(this, arguments, function(e) { 1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || Le(this, e).appendChild(e) }) }, prepend: function() { return Re(this, arguments, function(e) { if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) { var t = Le(this, e);
                    t.insertBefore(e, t.firstChild) } }) }, before: function() { return Re(this, arguments, function(e) { this.parentNode && this.parentNode.insertBefore(e, this) }) }, after: function() { return Re(this, arguments, function(e) { this.parentNode && this.parentNode.insertBefore(e, this.nextSibling) }) }, empty: function() { for (var e, t = 0; null != (e = this[t]); t++) 1 === e.nodeType && (w.cleanData(ye(e, !1)), e.textContent = ""); return this }, clone: function(e, t) { return e = null != e && e, t = null == t ? e : t, this.map(function() { return w.clone(this, e, t) }) }, html: function(e) { return z(this, function(e) { var t = this[0] || {},
                    n = 0,
                    r = this.length; if (void 0 === e && 1 === t.nodeType) return t.innerHTML; if ("string" == typeof e && !Ae.test(e) && !ge[(de.exec(e) || ["", ""])[1].toLowerCase()]) { e = w.htmlPrefilter(e); try { for (; n < r; n++) 1 === (t = this[n] || {}).nodeType && (w.cleanData(ye(t, !1)), t.innerHTML = e);
                        t = 0 } catch (e) {} } t && this.empty().append(e) }, null, e, arguments.length) }, replaceWith: function() { var e = []; return Re(this, arguments, function(t) { var n = this.parentNode;
                w.inArray(this, e) < 0 && (w.cleanData(ye(this)), n && n.replaceChild(t, this)) }, e) } }), w.each({ appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith" }, function(e, t) { w.fn[e] = function(e) { for (var n, r = [], i = w(e), o = i.length - 1, a = 0; a <= o; a++) n = a === o ? this : this.clone(!0), w(i[a])[t](n), s.apply(r, n.get()); return this.pushStack(r) } }); var We = new RegExp("^(" + re + ")(?!px)[a-z%]+$", "i"),
        $e = function(t) { var n = t.ownerDocument.defaultView; return n && n.opener || (n = e), n.getComputedStyle(t) },
        Be = new RegExp(oe.join("|"), "i");! function() {
        function t() { if (c) { l.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", c.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", be.appendChild(l).appendChild(c); var t = e.getComputedStyle(c);
                i = "1%" !== t.top, u = 12 === n(t.marginLeft), c.style.right = "60%", s = 36 === n(t.right), o = 36 === n(t.width), c.style.position = "absolute", a = 36 === c.offsetWidth || "absolute", be.removeChild(l), c = null } }

        function n(e) { return Math.round(parseFloat(e)) } var i, o, a, s, u, l = r.createElement("div"),
            c = r.createElement("div");
        c.style && (c.style.backgroundClip = "content-box", c.cloneNode(!0).style.backgroundClip = "", h.clearCloneStyle = "content-box" === c.style.backgroundClip, w.extend(h, { boxSizingReliable: function() { return t(), o }, pixelBoxStyles: function() { return t(), s }, pixelPosition: function() { return t(), i }, reliableMarginLeft: function() { return t(), u }, scrollboxSize: function() { return t(), a } })) }();

    function Fe(e, t, n) { var r, i, o, a, s = e.style; return (n = n || $e(e)) && ("" !== (a = n.getPropertyValue(t) || n[t]) || w.contains(e.ownerDocument, e) || (a = w.style(e, t)), !h.pixelBoxStyles() && We.test(a) && Be.test(t) && (r = s.width, i = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = r, s.minWidth = i, s.maxWidth = o)), void 0 !== a ? a + "" : a }

    function _e(e, t) { return { get: function() { if (!e()) return (this.get = t).apply(this, arguments);
                delete this.get } } } var ze = /^(none|table(?!-c[ea]).+)/,
        Xe = /^--/,
        Ue = { position: "absolute", visibility: "hidden", display: "block" },
        Ve = { letterSpacing: "0", fontWeight: "400" },
        Ge = ["Webkit", "Moz", "ms"],
        Ye = r.createElement("div").style;

    function Qe(e) { if (e in Ye) return e; var t = e[0].toUpperCase() + e.slice(1),
            n = Ge.length; while (n--)
            if ((e = Ge[n] + t) in Ye) return e }

    function Je(e) { var t = w.cssProps[e]; return t || (t = w.cssProps[e] = Qe(e) || e), t }

    function Ke(e, t, n) { var r = ie.exec(t); return r ? Math.max(0, r[2] - (n || 0)) + (r[3] || "px") : t }

    function Ze(e, t, n, r, i, o) { var a = "width" === t ? 1 : 0,
            s = 0,
            u = 0; if (n === (r ? "border" : "content")) return 0; for (; a < 4; a += 2) "margin" === n && (u += w.css(e, n + oe[a], !0, i)), r ? ("content" === n && (u -= w.css(e, "padding" + oe[a], !0, i)), "margin" !== n && (u -= w.css(e, "border" + oe[a] + "Width", !0, i))) : (u += w.css(e, "padding" + oe[a], !0, i), "padding" !== n ? u += w.css(e, "border" + oe[a] + "Width", !0, i) : s += w.css(e, "border" + oe[a] + "Width", !0, i)); return !r && o >= 0 && (u += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - o - u - s - .5))), u }

    function et(e, t, n) { var r = $e(e),
            i = Fe(e, t, r),
            o = "border-box" === w.css(e, "boxSizing", !1, r),
            a = o; if (We.test(i)) { if (!n) return i;
            i = "auto" } return a = a && (h.boxSizingReliable() || i === e.style[t]), ("auto" === i || !parseFloat(i) && "inline" === w.css(e, "display", !1, r)) && (i = e["offset" + t[0].toUpperCase() + t.slice(1)], a = !0), (i = parseFloat(i) || 0) + Ze(e, t, n || (o ? "border" : "content"), a, r, i) + "px" } w.extend({ cssHooks: { opacity: { get: function(e, t) { if (t) { var n = Fe(e, "opacity"); return "" === n ? "1" : n } } } }, cssNumber: { animationIterationCount: !0, columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0 }, cssProps: {}, style: function(e, t, n, r) { if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) { var i, o, a, s = G(t),
                    u = Xe.test(t),
                    l = e.style; if (u || (t = Je(s)), a = w.cssHooks[t] || w.cssHooks[s], void 0 === n) return a && "get" in a && void 0 !== (i = a.get(e, !1, r)) ? i : l[t]; "string" == (o = typeof n) && (i = ie.exec(n)) && i[1] && (n = ue(e, t, i), o = "number"), null != n && n === n && ("number" === o && (n += i && i[3] || (w.cssNumber[s] ? "" : "px")), h.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (l[t] = "inherit"), a && "set" in a && void 0 === (n = a.set(e, n, r)) || (u ? l.setProperty(t, n) : l[t] = n)) } }, css: function(e, t, n, r) { var i, o, a, s = G(t); return Xe.test(t) || (t = Je(s)), (a = w.cssHooks[t] || w.cssHooks[s]) && "get" in a && (i = a.get(e, !0, n)), void 0 === i && (i = Fe(e, t, r)), "normal" === i && t in Ve && (i = Ve[t]), "" === n || n ? (o = parseFloat(i), !0 === n || isFinite(o) ? o || 0 : i) : i } }), w.each(["height", "width"], function(e, t) { w.cssHooks[t] = { get: function(e, n, r) { if (n) return !ze.test(w.css(e, "display")) || e.getClientRects().length && e.getBoundingClientRect().width ? et(e, t, r) : se(e, Ue, function() { return et(e, t, r) }) }, set: function(e, n, r) { var i, o = $e(e),
                    a = "border-box" === w.css(e, "boxSizing", !1, o),
                    s = r && Ze(e, t, r, a, o); return a && h.scrollboxSize() === o.position && (s -= Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - parseFloat(o[t]) - Ze(e, t, "border", !1, o) - .5)), s && (i = ie.exec(n)) && "px" !== (i[3] || "px") && (e.style[t] = n, n = w.css(e, t)), Ke(e, n, s) } } }), w.cssHooks.marginLeft = _e(h.reliableMarginLeft, function(e, t) { if (t) return (parseFloat(Fe(e, "marginLeft")) || e.getBoundingClientRect().left - se(e, { marginLeft: 0 }, function() { return e.getBoundingClientRect().left })) + "px" }), w.each({ margin: "", padding: "", border: "Width" }, function(e, t) { w.cssHooks[e + t] = { expand: function(n) { for (var r = 0, i = {}, o = "string" == typeof n ? n.split(" ") : [n]; r < 4; r++) i[e + oe[r] + t] = o[r] || o[r - 2] || o[0]; return i } }, "margin" !== e && (w.cssHooks[e + t].set = Ke) }), w.fn.extend({ css: function(e, t) { return z(this, function(e, t, n) { var r, i, o = {},
                    a = 0; if (Array.isArray(t)) { for (r = $e(e), i = t.length; a < i; a++) o[t[a]] = w.css(e, t[a], !1, r); return o } return void 0 !== n ? w.style(e, t, n) : w.css(e, t) }, e, t, arguments.length > 1) } });

    function tt(e, t, n, r, i) { return new tt.prototype.init(e, t, n, r, i) } w.Tween = tt, tt.prototype = { constructor: tt, init: function(e, t, n, r, i, o) { this.elem = e, this.prop = n, this.easing = i || w.easing._default, this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = o || (w.cssNumber[n] ? "" : "px") }, cur: function() { var e = tt.propHooks[this.prop]; return e && e.get ? e.get(this) : tt.propHooks._default.get(this) }, run: function(e) { var t, n = tt.propHooks[this.prop]; return this.options.duration ? this.pos = t = w.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : tt.propHooks._default.set(this), this } }, tt.prototype.init.prototype = tt.prototype, tt.propHooks = { _default: { get: function(e) { var t; return 1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop] ? e.elem[e.prop] : (t = w.css(e.elem, e.prop, "")) && "auto" !== t ? t : 0 }, set: function(e) { w.fx.step[e.prop] ? w.fx.step[e.prop](e) : 1 !== e.elem.nodeType || null == e.elem.style[w.cssProps[e.prop]] && !w.cssHooks[e.prop] ? e.elem[e.prop] = e.now : w.style(e.elem, e.prop, e.now + e.unit) } } }, tt.propHooks.scrollTop = tt.propHooks.scrollLeft = { set: function(e) { e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now) } }, w.easing = { linear: function(e) { return e }, swing: function(e) { return .5 - Math.cos(e * Math.PI) / 2 }, _default: "swing" }, w.fx = tt.prototype.init, w.fx.step = {}; var nt, rt, it = /^(?:toggle|show|hide)$/,
        ot = /queueHooks$/;

    function at() { rt && (!1 === r.hidden && e.requestAnimationFrame ? e.requestAnimationFrame(at) : e.setTimeout(at, w.fx.interval), w.fx.tick()) }

    function st() { return e.setTimeout(function() { nt = void 0 }), nt = Date.now() }

    function ut(e, t) { var n, r = 0,
            i = { height: e }; for (t = t ? 1 : 0; r < 4; r += 2 - t) i["margin" + (n = oe[r])] = i["padding" + n] = e; return t && (i.opacity = i.width = e), i }

    function lt(e, t, n) { for (var r, i = (pt.tweeners[t] || []).concat(pt.tweeners["*"]), o = 0, a = i.length; o < a; o++)
            if (r = i[o].call(n, t, e)) return r }

    function ct(e, t, n) { var r, i, o, a, s, u, l, c, f = "width" in t || "height" in t,
            p = this,
            d = {},
            h = e.style,
            g = e.nodeType && ae(e),
            y = J.get(e, "fxshow");
        n.queue || (null == (a = w._queueHooks(e, "fx")).unqueued && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = function() { a.unqueued || s() }), a.unqueued++, p.always(function() { p.always(function() { a.unqueued--, w.queue(e, "fx").length || a.empty.fire() }) })); for (r in t)
            if (i = t[r], it.test(i)) { if (delete t[r], o = o || "toggle" === i, i === (g ? "hide" : "show")) { if ("show" !== i || !y || void 0 === y[r]) continue;
                    g = !0 } d[r] = y && y[r] || w.style(e, r) }
        if ((u = !w.isEmptyObject(t)) || !w.isEmptyObject(d)) { f && 1 === e.nodeType && (n.overflow = [h.overflow, h.overflowX, h.overflowY], null == (l = y && y.display) && (l = J.get(e, "display")), "none" === (c = w.css(e, "display")) && (l ? c = l : (fe([e], !0), l = e.style.display || l, c = w.css(e, "display"), fe([e]))), ("inline" === c || "inline-block" === c && null != l) && "none" === w.css(e, "float") && (u || (p.done(function() { h.display = l }), null == l && (c = h.display, l = "none" === c ? "" : c)), h.display = "inline-block")), n.overflow && (h.overflow = "hidden", p.always(function() { h.overflow = n.overflow[0], h.overflowX = n.overflow[1], h.overflowY = n.overflow[2] })), u = !1; for (r in d) u || (y ? "hidden" in y && (g = y.hidden) : y = J.access(e, "fxshow", { display: l }), o && (y.hidden = !g), g && fe([e], !0), p.done(function() { g || fe([e]), J.remove(e, "fxshow"); for (r in d) w.style(e, r, d[r]) })), u = lt(g ? y[r] : 0, r, p), r in y || (y[r] = u.start, g && (u.end = u.start, u.start = 0)) } }

    function ft(e, t) { var n, r, i, o, a; for (n in e)
            if (r = G(n), i = t[r], o = e[n], Array.isArray(o) && (i = o[1], o = e[n] = o[0]), n !== r && (e[r] = o, delete e[n]), (a = w.cssHooks[r]) && "expand" in a) { o = a.expand(o), delete e[r]; for (n in o) n in e || (e[n] = o[n], t[n] = i) }
        else t[r] = i }

    function pt(e, t, n) { var r, i, o = 0,
            a = pt.prefilters.length,
            s = w.Deferred().always(function() { delete u.elem }),
            u = function() { if (i) return !1; for (var t = nt || st(), n = Math.max(0, l.startTime + l.duration - t), r = 1 - (n / l.duration || 0), o = 0, a = l.tweens.length; o < a; o++) l.tweens[o].run(r); return s.notifyWith(e, [l, r, n]), r < 1 && a ? n : (a || s.notifyWith(e, [l, 1, 0]), s.resolveWith(e, [l]), !1) },
            l = s.promise({ elem: e, props: w.extend({}, t), opts: w.extend(!0, { specialEasing: {}, easing: w.easing._default }, n), originalProperties: t, originalOptions: n, startTime: nt || st(), duration: n.duration, tweens: [], createTween: function(t, n) { var r = w.Tween(e, l.opts, t, n, l.opts.specialEasing[t] || l.opts.easing); return l.tweens.push(r), r }, stop: function(t) { var n = 0,
                        r = t ? l.tweens.length : 0; if (i) return this; for (i = !0; n < r; n++) l.tweens[n].run(1); return t ? (s.notifyWith(e, [l, 1, 0]), s.resolveWith(e, [l, t])) : s.rejectWith(e, [l, t]), this } }),
            c = l.props; for (ft(c, l.opts.specialEasing); o < a; o++)
            if (r = pt.prefilters[o].call(l, e, c, l.opts)) return g(r.stop) && (w._queueHooks(l.elem, l.opts.queue).stop = r.stop.bind(r)), r; return w.map(c, lt, l), g(l.opts.start) && l.opts.start.call(e, l), l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always), w.fx.timer(w.extend(u, { elem: e, anim: l, queue: l.opts.queue })), l } w.Animation = w.extend(pt, { tweeners: { "*": [function(e, t) { var n = this.createTween(e, t); return ue(n.elem, e, ie.exec(t), n), n }] }, tweener: function(e, t) { g(e) ? (t = e, e = ["*"]) : e = e.match(M); for (var n, r = 0, i = e.length; r < i; r++) n = e[r], pt.tweeners[n] = pt.tweeners[n] || [], pt.tweeners[n].unshift(t) }, prefilters: [ct], prefilter: function(e, t) { t ? pt.prefilters.unshift(e) : pt.prefilters.push(e) } }), w.speed = function(e, t, n) { var r = e && "object" == typeof e ? w.extend({}, e) : { complete: n || !n && t || g(e) && e, duration: e, easing: n && t || t && !g(t) && t }; return w.fx.off ? r.duration = 0 : "number" != typeof r.duration && (r.duration in w.fx.speeds ? r.duration = w.fx.speeds[r.duration] : r.duration = w.fx.speeds._default), null != r.queue && !0 !== r.queue || (r.queue = "fx"), r.old = r.complete, r.complete = function() { g(r.old) && r.old.call(this), r.queue && w.dequeue(this, r.queue) }, r }, w.fn.extend({ fadeTo: function(e, t, n, r) { return this.filter(ae).css("opacity", 0).show().end().animate({ opacity: t }, e, n, r) }, animate: function(e, t, n, r) { var i = w.isEmptyObject(e),
                    o = w.speed(t, n, r),
                    a = function() { var t = pt(this, w.extend({}, e), o);
                        (i || J.get(this, "finish")) && t.stop(!0) }; return a.finish = a, i || !1 === o.queue ? this.each(a) : this.queue(o.queue, a) }, stop: function(e, t, n) { var r = function(e) { var t = e.stop;
                    delete e.stop, t(n) }; return "string" != typeof e && (n = t, t = e, e = void 0), t && !1 !== e && this.queue(e || "fx", []), this.each(function() { var t = !0,
                        i = null != e && e + "queueHooks",
                        o = w.timers,
                        a = J.get(this); if (i) a[i] && a[i].stop && r(a[i]);
                    else
                        for (i in a) a[i] && a[i].stop && ot.test(i) && r(a[i]); for (i = o.length; i--;) o[i].elem !== this || null != e && o[i].queue !== e || (o[i].anim.stop(n), t = !1, o.splice(i, 1));!t && n || w.dequeue(this, e) }) }, finish: function(e) { return !1 !== e && (e = e || "fx"), this.each(function() { var t, n = J.get(this),
                        r = n[e + "queue"],
                        i = n[e + "queueHooks"],
                        o = w.timers,
                        a = r ? r.length : 0; for (n.finish = !0, w.queue(this, e, []), i && i.stop && i.stop.call(this, !0), t = o.length; t--;) o[t].elem === this && o[t].queue === e && (o[t].anim.stop(!0), o.splice(t, 1)); for (t = 0; t < a; t++) r[t] && r[t].finish && r[t].finish.call(this);
                    delete n.finish }) } }), w.each(["toggle", "show", "hide"], function(e, t) { var n = w.fn[t];
            w.fn[t] = function(e, r, i) { return null == e || "boolean" == typeof e ? n.apply(this, arguments) : this.animate(ut(t, !0), e, r, i) } }), w.each({ slideDown: ut("show"), slideUp: ut("hide"), slideToggle: ut("toggle"), fadeIn: { opacity: "show" }, fadeOut: { opacity: "hide" }, fadeToggle: { opacity: "toggle" } }, function(e, t) { w.fn[e] = function(e, n, r) { return this.animate(t, e, n, r) } }), w.timers = [], w.fx.tick = function() { var e, t = 0,
                n = w.timers; for (nt = Date.now(); t < n.length; t++)(e = n[t])() || n[t] !== e || n.splice(t--, 1);
            n.length || w.fx.stop(), nt = void 0 }, w.fx.timer = function(e) { w.timers.push(e), w.fx.start() }, w.fx.interval = 13, w.fx.start = function() { rt || (rt = !0, at()) }, w.fx.stop = function() { rt = null }, w.fx.speeds = { slow: 600, fast: 200, _default: 400 }, w.fn.delay = function(t, n) { return t = w.fx ? w.fx.speeds[t] || t : t, n = n || "fx", this.queue(n, function(n, r) { var i = e.setTimeout(n, t);
                r.stop = function() { e.clearTimeout(i) } }) },
        function() { var e = r.createElement("input"),
                t = r.createElement("select").appendChild(r.createElement("option"));
            e.type = "checkbox", h.checkOn = "" !== e.value, h.optSelected = t.selected, (e = r.createElement("input")).value = "t", e.type = "radio", h.radioValue = "t" === e.value }(); var dt, ht = w.expr.attrHandle;
    w.fn.extend({ attr: function(e, t) { return z(this, w.attr, e, t, arguments.length > 1) }, removeAttr: function(e) { return this.each(function() { w.removeAttr(this, e) }) } }), w.extend({ attr: function(e, t, n) { var r, i, o = e.nodeType; if (3 !== o && 8 !== o && 2 !== o) return "undefined" == typeof e.getAttribute ? w.prop(e, t, n) : (1 === o && w.isXMLDoc(e) || (i = w.attrHooks[t.toLowerCase()] || (w.expr.match.bool.test(t) ? dt : void 0)), void 0 !== n ? null === n ? void w.removeAttr(e, t) : i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : (e.setAttribute(t, n + ""), n) : i && "get" in i && null !== (r = i.get(e, t)) ? r : null == (r = w.find.attr(e, t)) ? void 0 : r) }, attrHooks: { type: { set: function(e, t) { if (!h.radioValue && "radio" === t && N(e, "input")) { var n = e.value; return e.setAttribute("type", t), n && (e.value = n), t } } } }, removeAttr: function(e, t) { var n, r = 0,
                i = t && t.match(M); if (i && 1 === e.nodeType)
                while (n = i[r++]) e.removeAttribute(n) } }), dt = { set: function(e, t, n) { return !1 === t ? w.removeAttr(e, n) : e.setAttribute(n, n), n } }, w.each(w.expr.match.bool.source.match(/\w+/g), function(e, t) { var n = ht[t] || w.find.attr;
        ht[t] = function(e, t, r) { var i, o, a = t.toLowerCase(); return r || (o = ht[a], ht[a] = i, i = null != n(e, t, r) ? a : null, ht[a] = o), i } }); var gt = /^(?:input|select|textarea|button)$/i,
        yt = /^(?:a|area)$/i;
    w.fn.extend({ prop: function(e, t) { return z(this, w.prop, e, t, arguments.length > 1) }, removeProp: function(e) { return this.each(function() { delete this[w.propFix[e] || e] }) } }), w.extend({ prop: function(e, t, n) { var r, i, o = e.nodeType; if (3 !== o && 8 !== o && 2 !== o) return 1 === o && w.isXMLDoc(e) || (t = w.propFix[t] || t, i = w.propHooks[t]), void 0 !== n ? i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : e[t] = n : i && "get" in i && null !== (r = i.get(e, t)) ? r : e[t] }, propHooks: { tabIndex: { get: function(e) { var t = w.find.attr(e, "tabindex"); return t ? parseInt(t, 10) : gt.test(e.nodeName) || yt.test(e.nodeName) && e.href ? 0 : -1 } } }, propFix: { "for": "htmlFor", "class": "className" } }), h.optSelected || (w.propHooks.selected = { get: function(e) { var t = e.parentNode; return t && t.parentNode && t.parentNode.selectedIndex, null }, set: function(e) { var t = e.parentNode;
            t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex) } }), w.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() { w.propFix[this.toLowerCase()] = this });

    function vt(e) { return (e.match(M) || []).join(" ") }

    function mt(e) { return e.getAttribute && e.getAttribute("class") || "" }

    function xt(e) { return Array.isArray(e) ? e : "string" == typeof e ? e.match(M) || [] : [] } w.fn.extend({ addClass: function(e) { var t, n, r, i, o, a, s, u = 0; if (g(e)) return this.each(function(t) { w(this).addClass(e.call(this, t, mt(this))) }); if ((t = xt(e)).length)
                while (n = this[u++])
                    if (i = mt(n), r = 1 === n.nodeType && " " + vt(i) + " ") { a = 0; while (o = t[a++]) r.indexOf(" " + o + " ") < 0 && (r += o + " ");
                        i !== (s = vt(r)) && n.setAttribute("class", s) }
            return this }, removeClass: function(e) { var t, n, r, i, o, a, s, u = 0; if (g(e)) return this.each(function(t) { w(this).removeClass(e.call(this, t, mt(this))) }); if (!arguments.length) return this.attr("class", ""); if ((t = xt(e)).length)
                while (n = this[u++])
                    if (i = mt(n), r = 1 === n.nodeType && " " + vt(i) + " ") { a = 0; while (o = t[a++])
                            while (r.indexOf(" " + o + " ") > -1) r = r.replace(" " + o + " ", " ");
                        i !== (s = vt(r)) && n.setAttribute("class", s) }
            return this }, toggleClass: function(e, t) { var n = typeof e,
                r = "string" === n || Array.isArray(e); return "boolean" == typeof t && r ? t ? this.addClass(e) : this.removeClass(e) : g(e) ? this.each(function(n) { w(this).toggleClass(e.call(this, n, mt(this), t), t) }) : this.each(function() { var t, i, o, a; if (r) { i = 0, o = w(this), a = xt(e); while (t = a[i++]) o.hasClass(t) ? o.removeClass(t) : o.addClass(t) } else void 0 !== e && "boolean" !== n || ((t = mt(this)) && J.set(this, "__className__", t), this.setAttribute && this.setAttribute("class", t || !1 === e ? "" : J.get(this, "__className__") || "")) }) }, hasClass: function(e) { var t, n, r = 0;
            t = " " + e + " "; while (n = this[r++])
                if (1 === n.nodeType && (" " + vt(mt(n)) + " ").indexOf(t) > -1) return !0; return !1 } }); var bt = /\r/g;
    w.fn.extend({ val: function(e) { var t, n, r, i = this[0]; { if (arguments.length) return r = g(e), this.each(function(n) { var i;
                    1 === this.nodeType && (null == (i = r ? e.call(this, n, w(this).val()) : e) ? i = "" : "number" == typeof i ? i += "" : Array.isArray(i) && (i = w.map(i, function(e) { return null == e ? "" : e + "" })), (t = w.valHooks[this.type] || w.valHooks[this.nodeName.toLowerCase()]) && "set" in t && void 0 !== t.set(this, i, "value") || (this.value = i)) }); if (i) return (t = w.valHooks[i.type] || w.valHooks[i.nodeName.toLowerCase()]) && "get" in t && void 0 !== (n = t.get(i, "value")) ? n : "string" == typeof(n = i.value) ? n.replace(bt, "") : null == n ? "" : n } } }), w.extend({ valHooks: { option: { get: function(e) { var t = w.find.attr(e, "value"); return null != t ? t : vt(w.text(e)) } }, select: { get: function(e) { var t, n, r, i = e.options,
                        o = e.selectedIndex,
                        a = "select-one" === e.type,
                        s = a ? null : [],
                        u = a ? o + 1 : i.length; for (r = o < 0 ? u : a ? o : 0; r < u; r++)
                        if (((n = i[r]).selected || r === o) && !n.disabled && (!n.parentNode.disabled || !N(n.parentNode, "optgroup"))) { if (t = w(n).val(), a) return t;
                            s.push(t) }
                    return s }, set: function(e, t) { var n, r, i = e.options,
                        o = w.makeArray(t),
                        a = i.length; while (a--)((r = i[a]).selected = w.inArray(w.valHooks.option.get(r), o) > -1) && (n = !0); return n || (e.selectedIndex = -1), o } } } }), w.each(["radio", "checkbox"], function() { w.valHooks[this] = { set: function(e, t) { if (Array.isArray(t)) return e.checked = w.inArray(w(e).val(), t) > -1 } }, h.checkOn || (w.valHooks[this].get = function(e) { return null === e.getAttribute("value") ? "on" : e.value }) }), h.focusin = "onfocusin" in e; var wt = /^(?:focusinfocus|focusoutblur)$/,
        Tt = function(e) { e.stopPropagation() };
    w.extend(w.event, { trigger: function(t, n, i, o) { var a, s, u, l, c, p, d, h, v = [i || r],
                m = f.call(t, "type") ? t.type : t,
                x = f.call(t, "namespace") ? t.namespace.split(".") : []; if (s = h = u = i = i || r, 3 !== i.nodeType && 8 !== i.nodeType && !wt.test(m + w.event.triggered) && (m.indexOf(".") > -1 && (m = (x = m.split(".")).shift(), x.sort()), c = m.indexOf(":") < 0 && "on" + m, t = t[w.expando] ? t : new w.Event(m, "object" == typeof t && t), t.isTrigger = o ? 2 : 3, t.namespace = x.join("."), t.rnamespace = t.namespace ? new RegExp("(^|\\.)" + x.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, t.result = void 0, t.target || (t.target = i), n = null == n ? [t] : w.makeArray(n, [t]), d = w.event.special[m] || {}, o || !d.trigger || !1 !== d.trigger.apply(i, n))) { if (!o && !d.noBubble && !y(i)) { for (l = d.delegateType || m, wt.test(l + m) || (s = s.parentNode); s; s = s.parentNode) v.push(s), u = s;
                    u === (i.ownerDocument || r) && v.push(u.defaultView || u.parentWindow || e) } a = 0; while ((s = v[a++]) && !t.isPropagationStopped()) h = s, t.type = a > 1 ? l : d.bindType || m, (p = (J.get(s, "events") || {})[t.type] && J.get(s, "handle")) && p.apply(s, n), (p = c && s[c]) && p.apply && Y(s) && (t.result = p.apply(s, n), !1 === t.result && t.preventDefault()); return t.type = m, o || t.isDefaultPrevented() || d._default && !1 !== d._default.apply(v.pop(), n) || !Y(i) || c && g(i[m]) && !y(i) && ((u = i[c]) && (i[c] = null), w.event.triggered = m, t.isPropagationStopped() && h.addEventListener(m, Tt), i[m](), t.isPropagationStopped() && h.removeEventListener(m, Tt), w.event.triggered = void 0, u && (i[c] = u)), t.result } }, simulate: function(e, t, n) { var r = w.extend(new w.Event, n, { type: e, isSimulated: !0 });
            w.event.trigger(r, null, t) } }), w.fn.extend({ trigger: function(e, t) { return this.each(function() { w.event.trigger(e, t, this) }) }, triggerHandler: function(e, t) { var n = this[0]; if (n) return w.event.trigger(e, t, n, !0) } }), h.focusin || w.each({ focus: "focusin", blur: "focusout" }, function(e, t) { var n = function(e) { w.event.simulate(t, e.target, w.event.fix(e)) };
        w.event.special[t] = { setup: function() { var r = this.ownerDocument || this,
                    i = J.access(r, t);
                i || r.addEventListener(e, n, !0), J.access(r, t, (i || 0) + 1) }, teardown: function() { var r = this.ownerDocument || this,
                    i = J.access(r, t) - 1;
                i ? J.access(r, t, i) : (r.removeEventListener(e, n, !0), J.remove(r, t)) } } }); var Ct = e.location,
        Et = Date.now(),
        kt = /\?/;
    w.parseXML = function(t) { var n; if (!t || "string" != typeof t) return null; try { n = (new e.DOMParser).parseFromString(t, "text/xml") } catch (e) { n = void 0 } return n && !n.getElementsByTagName("parsererror").length || w.error("Invalid XML: " + t), n }; var St = /\[\]$/,
        Dt = /\r?\n/g,
        Nt = /^(?:submit|button|image|reset|file)$/i,
        At = /^(?:input|select|textarea|keygen)/i;

    function jt(e, t, n, r) { var i; if (Array.isArray(t)) w.each(t, function(t, i) { n || St.test(e) ? r(e, i) : jt(e + "[" + ("object" == typeof i && null != i ? t : "") + "]", i, n, r) });
        else if (n || "object" !== x(t)) r(e, t);
        else
            for (i in t) jt(e + "[" + i + "]", t[i], n, r) } w.param = function(e, t) { var n, r = [],
            i = function(e, t) { var n = g(t) ? t() : t;
                r[r.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == n ? "" : n) }; if (Array.isArray(e) || e.jquery && !w.isPlainObject(e)) w.each(e, function() { i(this.name, this.value) });
        else
            for (n in e) jt(n, e[n], t, i); return r.join("&") }, w.fn.extend({ serialize: function() { return w.param(this.serializeArray()) }, serializeArray: function() { return this.map(function() { var e = w.prop(this, "elements"); return e ? w.makeArray(e) : this }).filter(function() { var e = this.type; return this.name && !w(this).is(":disabled") && At.test(this.nodeName) && !Nt.test(e) && (this.checked || !pe.test(e)) }).map(function(e, t) { var n = w(this).val(); return null == n ? null : Array.isArray(n) ? w.map(n, function(e) { return { name: t.name, value: e.replace(Dt, "\r\n") } }) : { name: t.name, value: n.replace(Dt, "\r\n") } }).get() } }); var qt = /%20/g,
        Lt = /#.*$/,
        Ht = /([?&])_=[^&]*/,
        Ot = /^(.*?):[ \t]*([^\r\n]*)$/gm,
        Pt = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
        Mt = /^(?:GET|HEAD)$/,
        Rt = /^\/\//,
        It = {},
        Wt = {},
        $t = "*/".concat("*"),
        Bt = r.createElement("a");
    Bt.href = Ct.href;

    function Ft(e) { return function(t, n) { "string" != typeof t && (n = t, t = "*"); var r, i = 0,
                o = t.toLowerCase().match(M) || []; if (g(n))
                while (r = o[i++]) "+" === r[0] ? (r = r.slice(1) || "*", (e[r] = e[r] || []).unshift(n)) : (e[r] = e[r] || []).push(n) } }

    function _t(e, t, n, r) { var i = {},
            o = e === Wt;

        function a(s) { var u; return i[s] = !0, w.each(e[s] || [], function(e, s) { var l = s(t, n, r); return "string" != typeof l || o || i[l] ? o ? !(u = l) : void 0 : (t.dataTypes.unshift(l), a(l), !1) }), u } return a(t.dataTypes[0]) || !i["*"] && a("*") }

    function zt(e, t) { var n, r, i = w.ajaxSettings.flatOptions || {}; for (n in t) void 0 !== t[n] && ((i[n] ? e : r || (r = {}))[n] = t[n]); return r && w.extend(!0, e, r), e }

    function Xt(e, t, n) { var r, i, o, a, s = e.contents,
            u = e.dataTypes; while ("*" === u[0]) u.shift(), void 0 === r && (r = e.mimeType || t.getResponseHeader("Content-Type")); if (r)
            for (i in s)
                if (s[i] && s[i].test(r)) { u.unshift(i); break }
        if (u[0] in n) o = u[0];
        else { for (i in n) { if (!u[0] || e.converters[i + " " + u[0]]) { o = i; break } a || (a = i) } o = o || a } if (o) return o !== u[0] && u.unshift(o), n[o] }

    function Ut(e, t, n, r) { var i, o, a, s, u, l = {},
            c = e.dataTypes.slice(); if (c[1])
            for (a in e.converters) l[a.toLowerCase()] = e.converters[a];
        o = c.shift(); while (o)
            if (e.responseFields[o] && (n[e.responseFields[o]] = t), !u && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), u = o, o = c.shift())
                if ("*" === o) o = u;
                else if ("*" !== u && u !== o) { if (!(a = l[u + " " + o] || l["* " + o]))
                for (i in l)
                    if ((s = i.split(" "))[1] === o && (a = l[u + " " + s[0]] || l["* " + s[0]])) {!0 === a ? a = l[i] : !0 !== l[i] && (o = s[0], c.unshift(s[1])); break }
            if (!0 !== a)
                if (a && e["throws"]) t = a(t);
                else try { t = a(t) }
            catch (e) { return { state: "parsererror", error: a ? e : "No conversion from " + u + " to " + o } } } return { state: "success", data: t } } w.extend({ active: 0, lastModified: {}, etag: {}, ajaxSettings: { url: Ct.href, type: "GET", isLocal: Pt.test(Ct.protocol), global: !0, processData: !0, async: !0, contentType: "application/x-www-form-urlencoded; charset=UTF-8", accepts: { "*": $t, text: "text/plain", html: "text/html", xml: "application/xml, text/xml", json: "application/json, text/javascript" }, contents: { xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/ }, responseFields: { xml: "responseXML", text: "responseText", json: "responseJSON" }, converters: { "* text": String, "text html": !0, "text json": JSON.parse, "text xml": w.parseXML }, flatOptions: { url: !0, context: !0 } }, ajaxSetup: function(e, t) { return t ? zt(zt(e, w.ajaxSettings), t) : zt(w.ajaxSettings, e) }, ajaxPrefilter: Ft(It), ajaxTransport: Ft(Wt), ajax: function(t, n) { "object" == typeof t && (n = t, t = void 0), n = n || {}; var i, o, a, s, u, l, c, f, p, d, h = w.ajaxSetup({}, n),
                g = h.context || h,
                y = h.context && (g.nodeType || g.jquery) ? w(g) : w.event,
                v = w.Deferred(),
                m = w.Callbacks("once memory"),
                x = h.statusCode || {},
                b = {},
                T = {},
                C = "canceled",
                E = { readyState: 0, getResponseHeader: function(e) { var t; if (c) { if (!s) { s = {}; while (t = Ot.exec(a)) s[t[1].toLowerCase()] = t[2] } t = s[e.toLowerCase()] } return null == t ? null : t }, getAllResponseHeaders: function() { return c ? a : null }, setRequestHeader: function(e, t) { return null == c && (e = T[e.toLowerCase()] = T[e.toLowerCase()] || e, b[e] = t), this }, overrideMimeType: function(e) { return null == c && (h.mimeType = e), this }, statusCode: function(e) { var t; if (e)
                            if (c) E.always(e[E.status]);
                            else
                                for (t in e) x[t] = [x[t], e[t]]; return this }, abort: function(e) { var t = e || C; return i && i.abort(t), k(0, t), this } }; if (v.promise(E), h.url = ((t || h.url || Ct.href) + "").replace(Rt, Ct.protocol + "//"), h.type = n.method || n.type || h.method || h.type, h.dataTypes = (h.dataType || "*").toLowerCase().match(M) || [""], null == h.crossDomain) { l = r.createElement("a"); try { l.href = h.url, l.href = l.href, h.crossDomain = Bt.protocol + "//" + Bt.host != l.protocol + "//" + l.host } catch (e) { h.crossDomain = !0 } } if (h.data && h.processData && "string" != typeof h.data && (h.data = w.param(h.data, h.traditional)), _t(It, h, n, E), c) return E;
            (f = w.event && h.global) && 0 == w.active++ && w.event.trigger("ajaxStart"), h.type = h.type.toUpperCase(), h.hasContent = !Mt.test(h.type), o = h.url.replace(Lt, ""), h.hasContent ? h.data && h.processData && 0 === (h.contentType || "").indexOf("application/x-www-form-urlencoded") && (h.data = h.data.replace(qt, "+")) : (d = h.url.slice(o.length), h.data && (h.processData || "string" == typeof h.data) && (o += (kt.test(o) ? "&" : "?") + h.data, delete h.data), !1 === h.cache && (o = o.replace(Ht, "$1"), d = (kt.test(o) ? "&" : "?") + "_=" + Et++ + d), h.url = o + d), h.ifModified && (w.lastModified[o] && E.setRequestHeader("If-Modified-Since", w.lastModified[o]), w.etag[o] && E.setRequestHeader("If-None-Match", w.etag[o])), (h.data && h.hasContent && !1 !== h.contentType || n.contentType) && E.setRequestHeader("Content-Type", h.contentType), E.setRequestHeader("Accept", h.dataTypes[0] && h.accepts[h.dataTypes[0]] ? h.accepts[h.dataTypes[0]] + ("*" !== h.dataTypes[0] ? ", " + $t + "; q=0.01" : "") : h.accepts["*"]); for (p in h.headers) E.setRequestHeader(p, h.headers[p]); if (h.beforeSend && (!1 === h.beforeSend.call(g, E, h) || c)) return E.abort(); if (C = "abort", m.add(h.complete), E.done(h.success), E.fail(h.error), i = _t(Wt, h, n, E)) { if (E.readyState = 1, f && y.trigger("ajaxSend", [E, h]), c) return E;
                h.async && h.timeout > 0 && (u = e.setTimeout(function() { E.abort("timeout") }, h.timeout)); try { c = !1, i.send(b, k) } catch (e) { if (c) throw e;
                    k(-1, e) } } else k(-1, "No Transport");

            function k(t, n, r, s) { var l, p, d, b, T, C = n;
                c || (c = !0, u && e.clearTimeout(u), i = void 0, a = s || "", E.readyState = t > 0 ? 4 : 0, l = t >= 200 && t < 300 || 304 === t, r && (b = Xt(h, E, r)), b = Ut(h, b, E, l), l ? (h.ifModified && ((T = E.getResponseHeader("Last-Modified")) && (w.lastModified[o] = T), (T = E.getResponseHeader("etag")) && (w.etag[o] = T)), 204 === t || "HEAD" === h.type ? C = "nocontent" : 304 === t ? C = "notmodified" : (C = b.state, p = b.data, l = !(d = b.error))) : (d = C, !t && C || (C = "error", t < 0 && (t = 0))), E.status = t, E.statusText = (n || C) + "", l ? v.resolveWith(g, [p, C, E]) : v.rejectWith(g, [E, C, d]), E.statusCode(x), x = void 0, f && y.trigger(l ? "ajaxSuccess" : "ajaxError", [E, h, l ? p : d]), m.fireWith(g, [E, C]), f && (y.trigger("ajaxComplete", [E, h]), --w.active || w.event.trigger("ajaxStop"))) } return E }, getJSON: function(e, t, n) { return w.get(e, t, n, "json") }, getScript: function(e, t) { return w.get(e, void 0, t, "script") } }), w.each(["get", "post"], function(e, t) { w[t] = function(e, n, r, i) { return g(n) && (i = i || r, r = n, n = void 0), w.ajax(w.extend({ url: e, type: t, dataType: i, data: n, success: r }, w.isPlainObject(e) && e)) } }), w._evalUrl = function(e) { return w.ajax({ url: e, type: "GET", dataType: "script", cache: !0, async: !1, global: !1, "throws": !0 }) }, w.fn.extend({ wrapAll: function(e) { var t; return this[0] && (g(e) && (e = e.call(this[0])), t = w(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function() { var e = this; while (e.firstElementChild) e = e.firstElementChild; return e }).append(this)), this }, wrapInner: function(e) { return g(e) ? this.each(function(t) { w(this).wrapInner(e.call(this, t)) }) : this.each(function() { var t = w(this),
                    n = t.contents();
                n.length ? n.wrapAll(e) : t.append(e) }) }, wrap: function(e) { var t = g(e); return this.each(function(n) { w(this).wrapAll(t ? e.call(this, n) : e) }) }, unwrap: function(e) { return this.parent(e).not("body").each(function() { w(this).replaceWith(this.childNodes) }), this } }), w.expr.pseudos.hidden = function(e) { return !w.expr.pseudos.visible(e) }, w.expr.pseudos.visible = function(e) { return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length) }, w.ajaxSettings.xhr = function() { try { return new e.XMLHttpRequest } catch (e) {} }; var Vt = { 0: 200, 1223: 204 },
        Gt = w.ajaxSettings.xhr();
    h.cors = !!Gt && "withCredentials" in Gt, h.ajax = Gt = !!Gt, w.ajaxTransport(function(t) { var n, r; if (h.cors || Gt && !t.crossDomain) return { send: function(i, o) { var a, s = t.xhr(); if (s.open(t.type, t.url, t.async, t.username, t.password), t.xhrFields)
                    for (a in t.xhrFields) s[a] = t.xhrFields[a];
                t.mimeType && s.overrideMimeType && s.overrideMimeType(t.mimeType), t.crossDomain || i["X-Requested-With"] || (i["X-Requested-With"] = "XMLHttpRequest"); for (a in i) s.setRequestHeader(a, i[a]);
                n = function(e) { return function() { n && (n = r = s.onload = s.onerror = s.onabort = s.ontimeout = s.onreadystatechange = null, "abort" === e ? s.abort() : "error" === e ? "number" != typeof s.status ? o(0, "error") : o(s.status, s.statusText) : o(Vt[s.status] || s.status, s.statusText, "text" !== (s.responseType || "text") || "string" != typeof s.responseText ? { binary: s.response } : { text: s.responseText }, s.getAllResponseHeaders())) } }, s.onload = n(), r = s.onerror = s.ontimeout = n("error"), void 0 !== s.onabort ? s.onabort = r : s.onreadystatechange = function() { 4 === s.readyState && e.setTimeout(function() { n && r() }) }, n = n("abort"); try { s.send(t.hasContent && t.data || null) } catch (e) { if (n) throw e } }, abort: function() { n && n() } } }), w.ajaxPrefilter(function(e) { e.crossDomain && (e.contents.script = !1) }), w.ajaxSetup({ accepts: { script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript" }, contents: { script: /\b(?:java|ecma)script\b/ }, converters: { "text script": function(e) { return w.globalEval(e), e } } }), w.ajaxPrefilter("script", function(e) { void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET") }), w.ajaxTransport("script", function(e) { if (e.crossDomain) { var t, n; return { send: function(i, o) { t = w("<script>").prop({ charset: e.scriptCharset, src: e.url }).on("load error", n = function(e) { t.remove(), n = null, e && o("error" === e.type ? 404 : 200, e.type) }), r.head.appendChild(t[0]) }, abort: function() { n && n() } } } }); var Yt = [],
        Qt = /(=)\?(?=&|$)|\?\?/;
    w.ajaxSetup({ jsonp: "callback", jsonpCallback: function() { var e = Yt.pop() || w.expando + "_" + Et++; return this[e] = !0, e } }), w.ajaxPrefilter("json jsonp", function(t, n, r) { var i, o, a, s = !1 !== t.jsonp && (Qt.test(t.url) ? "url" : "string" == typeof t.data && 0 === (t.contentType || "").indexOf("application/x-www-form-urlencoded") && Qt.test(t.data) && "data"); if (s || "jsonp" === t.dataTypes[0]) return i = t.jsonpCallback = g(t.jsonpCallback) ? t.jsonpCallback() : t.jsonpCallback, s ? t[s] = t[s].replace(Qt, "$1" + i) : !1 !== t.jsonp && (t.url += (kt.test(t.url) ? "&" : "?") + t.jsonp + "=" + i), t.converters["script json"] = function() { return a || w.error(i + " was not called"), a[0] }, t.dataTypes[0] = "json", o = e[i], e[i] = function() { a = arguments }, r.always(function() { void 0 === o ? w(e).removeProp(i) : e[i] = o, t[i] && (t.jsonpCallback = n.jsonpCallback, Yt.push(i)), a && g(o) && o(a[0]), a = o = void 0 }), "script" }), h.createHTMLDocument = function() { var e = r.implementation.createHTMLDocument("").body; return e.innerHTML = "<form></form><form></form>", 2 === e.childNodes.length }(), w.parseHTML = function(e, t, n) { if ("string" != typeof e) return []; "boolean" == typeof t && (n = t, t = !1); var i, o, a; return t || (h.createHTMLDocument ? ((i = (t = r.implementation.createHTMLDocument("")).createElement("base")).href = r.location.href, t.head.appendChild(i)) : t = r), o = A.exec(e), a = !n && [], o ? [t.createElement(o[1])] : (o = xe([e], t, a), a && a.length && w(a).remove(), w.merge([], o.childNodes)) }, w.fn.load = function(e, t, n) { var r, i, o, a = this,
            s = e.indexOf(" "); return s > -1 && (r = vt(e.slice(s)), e = e.slice(0, s)), g(t) ? (n = t, t = void 0) : t && "object" == typeof t && (i = "POST"), a.length > 0 && w.ajax({ url: e, type: i || "GET", dataType: "html", data: t }).done(function(e) { o = arguments, a.html(r ? w("<div>").append(w.parseHTML(e)).find(r) : e) }).always(n && function(e, t) { a.each(function() { n.apply(this, o || [e.responseText, t, e]) }) }), this }, w.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(e, t) { w.fn[t] = function(e) { return this.on(t, e) } }), w.expr.pseudos.animated = function(e) { return w.grep(w.timers, function(t) { return e === t.elem }).length }, w.offset = { setOffset: function(e, t, n) { var r, i, o, a, s, u, l, c = w.css(e, "position"),
                f = w(e),
                p = {}; "static" === c && (e.style.position = "relative"), s = f.offset(), o = w.css(e, "top"), u = w.css(e, "left"), (l = ("absolute" === c || "fixed" === c) && (o + u).indexOf("auto") > -1) ? (a = (r = f.position()).top, i = r.left) : (a = parseFloat(o) || 0, i = parseFloat(u) || 0), g(t) && (t = t.call(e, n, w.extend({}, s))), null != t.top && (p.top = t.top - s.top + a), null != t.left && (p.left = t.left - s.left + i), "using" in t ? t.using.call(e, p) : f.css(p) } }, w.fn.extend({ offset: function(e) { if (arguments.length) return void 0 === e ? this : this.each(function(t) { w.offset.setOffset(this, e, t) }); var t, n, r = this[0]; if (r) return r.getClientRects().length ? (t = r.getBoundingClientRect(), n = r.ownerDocument.defaultView, { top: t.top + n.pageYOffset, left: t.left + n.pageXOffset }) : { top: 0, left: 0 } }, position: function() { if (this[0]) { var e, t, n, r = this[0],
                    i = { top: 0, left: 0 }; if ("fixed" === w.css(r, "position")) t = r.getBoundingClientRect();
                else { t = this.offset(), n = r.ownerDocument, e = r.offsetParent || n.documentElement; while (e && (e === n.body || e === n.documentElement) && "static" === w.css(e, "position")) e = e.parentNode;
                    e && e !== r && 1 === e.nodeType && ((i = w(e).offset()).top += w.css(e, "borderTopWidth", !0), i.left += w.css(e, "borderLeftWidth", !0)) } return { top: t.top - i.top - w.css(r, "marginTop", !0), left: t.left - i.left - w.css(r, "marginLeft", !0) } } }, offsetParent: function() { return this.map(function() { var e = this.offsetParent; while (e && "static" === w.css(e, "position")) e = e.offsetParent; return e || be }) } }), w.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(e, t) { var n = "pageYOffset" === t;
        w.fn[e] = function(r) { return z(this, function(e, r, i) { var o; if (y(e) ? o = e : 9 === e.nodeType && (o = e.defaultView), void 0 === i) return o ? o[t] : e[r];
                o ? o.scrollTo(n ? o.pageXOffset : i, n ? i : o.pageYOffset) : e[r] = i }, e, r, arguments.length) } }), w.each(["top", "left"], function(e, t) { w.cssHooks[t] = _e(h.pixelPosition, function(e, n) { if (n) return n = Fe(e, t), We.test(n) ? w(e).position()[t] + "px" : n }) }), w.each({ Height: "height", Width: "width" }, function(e, t) { w.each({ padding: "inner" + e, content: t, "": "outer" + e }, function(n, r) { w.fn[r] = function(i, o) { var a = arguments.length && (n || "boolean" != typeof i),
                    s = n || (!0 === i || !0 === o ? "margin" : "border"); return z(this, function(t, n, i) { var o; return y(t) ? 0 === r.indexOf("outer") ? t["inner" + e] : t.document.documentElement["client" + e] : 9 === t.nodeType ? (o = t.documentElement, Math.max(t.body["scroll" + e], o["scroll" + e], t.body["offset" + e], o["offset" + e], o["client" + e])) : void 0 === i ? w.css(t, n, s) : w.style(t, n, i, s) }, t, a ? i : void 0, a) } }) }), w.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(e, t) { w.fn[t] = function(e, n) { return arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t) } }), w.fn.extend({ hover: function(e, t) { return this.mouseenter(e).mouseleave(t || e) } }), w.fn.extend({ bind: function(e, t, n) { return this.on(e, null, t, n) }, unbind: function(e, t) { return this.off(e, null, t) }, delegate: function(e, t, n, r) { return this.on(t, e, n, r) }, undelegate: function(e, t, n) { return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n) } }), w.proxy = function(e, t) { var n, r, i; if ("string" == typeof t && (n = e[t], t = e, e = n), g(e)) return r = o.call(arguments, 2), i = function() { return e.apply(t || this, r.concat(o.call(arguments))) }, i.guid = e.guid = e.guid || w.guid++, i }, w.holdReady = function(e) { e ? w.readyWait++ : w.ready(!0) }, w.isArray = Array.isArray, w.parseJSON = JSON.parse, w.nodeName = N, w.isFunction = g, w.isWindow = y, w.camelCase = G, w.type = x, w.now = Date.now, w.isNumeric = function(e) { var t = w.type(e); return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e)) }, "function" == typeof define && define.amd && define("jquery", [], function() { return w }); var Jt = e.jQuery,
        Kt = e.$; return w.noConflict = function(t) { return e.$ === w && (e.$ = Kt), t && e.jQuery === w && (e.jQuery = Jt), w }, t || (e.jQuery = e.$ = w), w });

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJqcXVlcnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIGpRdWVyeSB2My4zLjEgfCAoYykgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIHwganF1ZXJ5Lm9yZy9saWNlbnNlICovICEgZnVuY3Rpb24oZSwgdCkgeyBcInVzZSBzdHJpY3RcIjsgXCJvYmplY3RcIiA9PSB0eXBlb2YgbW9kdWxlICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIG1vZHVsZS5leHBvcnRzID8gbW9kdWxlLmV4cG9ydHMgPSBlLmRvY3VtZW50ID8gdChlLCAhMCkgOiBmdW5jdGlvbihlKSB7IGlmICghZS5kb2N1bWVudCkgdGhyb3cgbmV3IEVycm9yKFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiKTsgcmV0dXJuIHQoZSkgfSA6IHQoZSkgfShcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB3aW5kb3cgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbihlLCB0KSB7IFwidXNlIHN0cmljdFwiOyB2YXIgbiA9IFtdLFxuICAgICAgICByID0gZS5kb2N1bWVudCxcbiAgICAgICAgaSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZixcbiAgICAgICAgbyA9IG4uc2xpY2UsXG4gICAgICAgIGEgPSBuLmNvbmNhdCxcbiAgICAgICAgcyA9IG4ucHVzaCxcbiAgICAgICAgdSA9IG4uaW5kZXhPZixcbiAgICAgICAgbCA9IHt9LFxuICAgICAgICBjID0gbC50b1N0cmluZyxcbiAgICAgICAgZiA9IGwuaGFzT3duUHJvcGVydHksXG4gICAgICAgIHAgPSBmLnRvU3RyaW5nLFxuICAgICAgICBkID0gcC5jYWxsKE9iamVjdCksXG4gICAgICAgIGggPSB7fSxcbiAgICAgICAgZyA9IGZ1bmN0aW9uIGUodCkgeyByZXR1cm4gXCJmdW5jdGlvblwiID09IHR5cGVvZiB0ICYmIFwibnVtYmVyXCIgIT0gdHlwZW9mIHQubm9kZVR5cGUgfSxcbiAgICAgICAgeSA9IGZ1bmN0aW9uIGUodCkgeyByZXR1cm4gbnVsbCAhPSB0ICYmIHQgPT09IHQud2luZG93IH0sXG4gICAgICAgIHYgPSB7IHR5cGU6ICEwLCBzcmM6ICEwLCBub01vZHVsZTogITAgfTtcblxuICAgIGZ1bmN0aW9uIG0oZSwgdCwgbikgeyB2YXIgaSwgbyA9ICh0ID0gdCB8fCByKS5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpOyBpZiAoby50ZXh0ID0gZSwgbilcbiAgICAgICAgICAgIGZvciAoaSBpbiB2KSBuW2ldICYmIChvW2ldID0gbltpXSk7XG4gICAgICAgIHQuaGVhZC5hcHBlbmRDaGlsZChvKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG8pIH1cblxuICAgIGZ1bmN0aW9uIHgoZSkgeyByZXR1cm4gbnVsbCA9PSBlID8gZSArIFwiXCIgOiBcIm9iamVjdFwiID09IHR5cGVvZiBlIHx8IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSA/IGxbYy5jYWxsKGUpXSB8fCBcIm9iamVjdFwiIDogdHlwZW9mIGUgfSB2YXIgYiA9IFwiMy4zLjFcIixcbiAgICAgICAgdyA9IGZ1bmN0aW9uKGUsIHQpIHsgcmV0dXJuIG5ldyB3LmZuLmluaXQoZSwgdCkgfSxcbiAgICAgICAgVCA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZztcbiAgICB3LmZuID0gdy5wcm90b3R5cGUgPSB7IGpxdWVyeTogXCIzLjMuMVwiLCBjb25zdHJ1Y3RvcjogdywgbGVuZ3RoOiAwLCB0b0FycmF5OiBmdW5jdGlvbigpIHsgcmV0dXJuIG8uY2FsbCh0aGlzKSB9LCBnZXQ6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIG51bGwgPT0gZSA/IG8uY2FsbCh0aGlzKSA6IGUgPCAwID8gdGhpc1tlICsgdGhpcy5sZW5ndGhdIDogdGhpc1tlXSB9LCBwdXNoU3RhY2s6IGZ1bmN0aW9uKGUpIHsgdmFyIHQgPSB3Lm1lcmdlKHRoaXMuY29uc3RydWN0b3IoKSwgZSk7IHJldHVybiB0LnByZXZPYmplY3QgPSB0aGlzLCB0IH0sIGVhY2g6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIHcuZWFjaCh0aGlzLCBlKSB9LCBtYXA6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIHRoaXMucHVzaFN0YWNrKHcubWFwKHRoaXMsIGZ1bmN0aW9uKHQsIG4pIHsgcmV0dXJuIGUuY2FsbCh0LCBuLCB0KSB9KSkgfSwgc2xpY2U6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5wdXNoU3RhY2soby5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSB9LCBmaXJzdDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmVxKDApIH0sIGxhc3Q6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5lcSgtMSkgfSwgZXE6IGZ1bmN0aW9uKGUpIHsgdmFyIHQgPSB0aGlzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBuID0gK2UgKyAoZSA8IDAgPyB0IDogMCk7IHJldHVybiB0aGlzLnB1c2hTdGFjayhuID49IDAgJiYgbiA8IHQgPyBbdGhpc1tuXV0gOiBbXSkgfSwgZW5kOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCkgfSwgcHVzaDogcywgc29ydDogbi5zb3J0LCBzcGxpY2U6IG4uc3BsaWNlIH0sIHcuZXh0ZW5kID0gdy5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHsgdmFyIGUsIHQsIG4sIHIsIGksIG8sIGEgPSBhcmd1bWVudHNbMF0gfHwge30sXG4gICAgICAgICAgICBzID0gMSxcbiAgICAgICAgICAgIHUgPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgbCA9ICExOyBmb3IgKFwiYm9vbGVhblwiID09IHR5cGVvZiBhICYmIChsID0gYSwgYSA9IGFyZ3VtZW50c1tzXSB8fCB7fSwgcysrKSwgXCJvYmplY3RcIiA9PSB0eXBlb2YgYSB8fCBnKGEpIHx8IChhID0ge30pLCBzID09PSB1ICYmIChhID0gdGhpcywgcy0tKTsgcyA8IHU7IHMrKylcbiAgICAgICAgICAgIGlmIChudWxsICE9IChlID0gYXJndW1lbnRzW3NdKSlcbiAgICAgICAgICAgICAgICBmb3IgKHQgaW4gZSkgbiA9IGFbdF0sIGEgIT09IChyID0gZVt0XSkgJiYgKGwgJiYgciAmJiAody5pc1BsYWluT2JqZWN0KHIpIHx8IChpID0gQXJyYXkuaXNBcnJheShyKSkpID8gKGkgPyAoaSA9ICExLCBvID0gbiAmJiBBcnJheS5pc0FycmF5KG4pID8gbiA6IFtdKSA6IG8gPSBuICYmIHcuaXNQbGFpbk9iamVjdChuKSA/IG4gOiB7fSwgYVt0XSA9IHcuZXh0ZW5kKGwsIG8sIHIpKSA6IHZvaWQgMCAhPT0gciAmJiAoYVt0XSA9IHIpKTsgcmV0dXJuIGEgfSwgdy5leHRlbmQoeyBleHBhbmRvOiBcImpRdWVyeVwiICsgKFwiMy4zLjFcIiArIE1hdGgucmFuZG9tKCkpLnJlcGxhY2UoL1xcRC9nLCBcIlwiKSwgaXNSZWFkeTogITAsIGVycm9yOiBmdW5jdGlvbihlKSB7IHRocm93IG5ldyBFcnJvcihlKSB9LCBub29wOiBmdW5jdGlvbigpIHt9LCBpc1BsYWluT2JqZWN0OiBmdW5jdGlvbihlKSB7IHZhciB0LCBuOyByZXR1cm4gISghZSB8fCBcIltvYmplY3QgT2JqZWN0XVwiICE9PSBjLmNhbGwoZSkpICYmICghKHQgPSBpKGUpKSB8fCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mKG4gPSBmLmNhbGwodCwgXCJjb25zdHJ1Y3RvclwiKSAmJiB0LmNvbnN0cnVjdG9yKSAmJiBwLmNhbGwobikgPT09IGQpIH0sIGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKGUpIHsgdmFyIHQ7IGZvciAodCBpbiBlKSByZXR1cm4gITE7IHJldHVybiAhMCB9LCBnbG9iYWxFdmFsOiBmdW5jdGlvbihlKSB7IG0oZSkgfSwgZWFjaDogZnVuY3Rpb24oZSwgdCkgeyB2YXIgbiwgciA9IDA7IGlmIChDKGUpKSB7IGZvciAobiA9IGUubGVuZ3RoOyByIDwgbjsgcisrKVxuICAgICAgICAgICAgICAgICAgICBpZiAoITEgPT09IHQuY2FsbChlW3JdLCByLCBlW3JdKSkgYnJlYWsgfSBlbHNlXG4gICAgICAgICAgICAgICAgZm9yIChyIGluIGUpXG4gICAgICAgICAgICAgICAgICAgIGlmICghMSA9PT0gdC5jYWxsKGVbcl0sIHIsIGVbcl0pKSBicmVhazsgcmV0dXJuIGUgfSwgdHJpbTogZnVuY3Rpb24oZSkgeyByZXR1cm4gbnVsbCA9PSBlID8gXCJcIiA6IChlICsgXCJcIikucmVwbGFjZShULCBcIlwiKSB9LCBtYWtlQXJyYXk6IGZ1bmN0aW9uKGUsIHQpIHsgdmFyIG4gPSB0IHx8IFtdOyByZXR1cm4gbnVsbCAhPSBlICYmIChDKE9iamVjdChlKSkgPyB3Lm1lcmdlKG4sIFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgPyBbZV0gOiBlKSA6IHMuY2FsbChuLCBlKSksIG4gfSwgaW5BcnJheTogZnVuY3Rpb24oZSwgdCwgbikgeyByZXR1cm4gbnVsbCA9PSB0ID8gLTEgOiB1LmNhbGwodCwgZSwgbikgfSwgbWVyZ2U6IGZ1bmN0aW9uKGUsIHQpIHsgZm9yICh2YXIgbiA9ICt0Lmxlbmd0aCwgciA9IDAsIGkgPSBlLmxlbmd0aDsgciA8IG47IHIrKykgZVtpKytdID0gdFtyXTsgcmV0dXJuIGUubGVuZ3RoID0gaSwgZSB9LCBncmVwOiBmdW5jdGlvbihlLCB0LCBuKSB7IGZvciAodmFyIHIsIGkgPSBbXSwgbyA9IDAsIGEgPSBlLmxlbmd0aCwgcyA9ICFuOyBvIDwgYTsgbysrKShyID0gIXQoZVtvXSwgbykpICE9PSBzICYmIGkucHVzaChlW29dKTsgcmV0dXJuIGkgfSwgbWFwOiBmdW5jdGlvbihlLCB0LCBuKSB7IHZhciByLCBpLCBvID0gMCxcbiAgICAgICAgICAgICAgICBzID0gW107IGlmIChDKGUpKVxuICAgICAgICAgICAgICAgIGZvciAociA9IGUubGVuZ3RoOyBvIDwgcjsgbysrKSBudWxsICE9IChpID0gdChlW29dLCBvLCBuKSkgJiYgcy5wdXNoKGkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGZvciAobyBpbiBlKSBudWxsICE9IChpID0gdChlW29dLCBvLCBuKSkgJiYgcy5wdXNoKGkpOyByZXR1cm4gYS5hcHBseShbXSwgcykgfSwgZ3VpZDogMSwgc3VwcG9ydDogaCB9KSwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgKHcuZm5bU3ltYm9sLml0ZXJhdG9yXSA9IG5bU3ltYm9sLml0ZXJhdG9yXSksIHcuZWFjaChcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoXCIgXCIpLCBmdW5jdGlvbihlLCB0KSB7IGxbXCJbb2JqZWN0IFwiICsgdCArIFwiXVwiXSA9IHQudG9Mb3dlckNhc2UoKSB9KTtcblxuICAgIGZ1bmN0aW9uIEMoZSkgeyB2YXIgdCA9ICEhZSAmJiBcImxlbmd0aFwiIGluIGUgJiYgZS5sZW5ndGgsXG4gICAgICAgICAgICBuID0geChlKTsgcmV0dXJuICFnKGUpICYmICF5KGUpICYmIChcImFycmF5XCIgPT09IG4gfHwgMCA9PT0gdCB8fCBcIm51bWJlclwiID09IHR5cGVvZiB0ICYmIHQgPiAwICYmIHQgLSAxIGluIGUpIH0gdmFyIEUgPSBmdW5jdGlvbihlKSB7IHZhciB0LCBuLCByLCBpLCBvLCBhLCBzLCB1LCBsLCBjLCBmLCBwLCBkLCBoLCBnLCB5LCB2LCBtLCB4LCBiID0gXCJzaXp6bGVcIiArIDEgKiBuZXcgRGF0ZSxcbiAgICAgICAgICAgIHcgPSBlLmRvY3VtZW50LFxuICAgICAgICAgICAgVCA9IDAsXG4gICAgICAgICAgICBDID0gMCxcbiAgICAgICAgICAgIEUgPSBhZSgpLFxuICAgICAgICAgICAgayA9IGFlKCksXG4gICAgICAgICAgICBTID0gYWUoKSxcbiAgICAgICAgICAgIEQgPSBmdW5jdGlvbihlLCB0KSB7IHJldHVybiBlID09PSB0ICYmIChmID0gITApLCAwIH0sXG4gICAgICAgICAgICBOID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgICAgICAgICBBID0gW10sXG4gICAgICAgICAgICBqID0gQS5wb3AsXG4gICAgICAgICAgICBxID0gQS5wdXNoLFxuICAgICAgICAgICAgTCA9IEEucHVzaCxcbiAgICAgICAgICAgIEggPSBBLnNsaWNlLFxuICAgICAgICAgICAgTyA9IGZ1bmN0aW9uKGUsIHQpIHsgZm9yICh2YXIgbiA9IDAsIHIgPSBlLmxlbmd0aDsgbiA8IHI7IG4rKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVbbl0gPT09IHQpIHJldHVybiBuOyByZXR1cm4gLTEgfSxcbiAgICAgICAgICAgIFAgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG4gICAgICAgICAgICBNID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuICAgICAgICAgICAgUiA9IFwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFwwLVxcXFx4YTBdKStcIixcbiAgICAgICAgICAgIEkgPSBcIlxcXFxbXCIgKyBNICsgXCIqKFwiICsgUiArIFwiKSg/OlwiICsgTSArIFwiKihbKl4kfCF+XT89KVwiICsgTSArIFwiKig/OicoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcInwoXCIgKyBSICsgXCIpKXwpXCIgKyBNICsgXCIqXFxcXF1cIixcbiAgICAgICAgICAgIFcgPSBcIjooXCIgKyBSICsgXCIpKD86XFxcXCgoKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8KCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgSSArIFwiKSopfC4qKVxcXFwpfClcIixcbiAgICAgICAgICAgICQgPSBuZXcgUmVnRXhwKE0gKyBcIitcIiwgXCJnXCIpLFxuICAgICAgICAgICAgQiA9IG5ldyBSZWdFeHAoXCJeXCIgKyBNICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICsgTSArIFwiKyRcIiwgXCJnXCIpLFxuICAgICAgICAgICAgRiA9IG5ldyBSZWdFeHAoXCJeXCIgKyBNICsgXCIqLFwiICsgTSArIFwiKlwiKSxcbiAgICAgICAgICAgIF8gPSBuZXcgUmVnRXhwKFwiXlwiICsgTSArIFwiKihbPit+XXxcIiArIE0gKyBcIilcIiArIE0gKyBcIipcIiksXG4gICAgICAgICAgICB6ID0gbmV3IFJlZ0V4cChcIj1cIiArIE0gKyBcIiooW15cXFxcXSdcXFwiXSo/KVwiICsgTSArIFwiKlxcXFxdXCIsIFwiZ1wiKSxcbiAgICAgICAgICAgIFggPSBuZXcgUmVnRXhwKFcpLFxuICAgICAgICAgICAgVSA9IG5ldyBSZWdFeHAoXCJeXCIgKyBSICsgXCIkXCIpLFxuICAgICAgICAgICAgViA9IHsgSUQ6IG5ldyBSZWdFeHAoXCJeIyhcIiArIFIgKyBcIilcIiksIENMQVNTOiBuZXcgUmVnRXhwKFwiXlxcXFwuKFwiICsgUiArIFwiKVwiKSwgVEFHOiBuZXcgUmVnRXhwKFwiXihcIiArIFIgKyBcInxbKl0pXCIpLCBBVFRSOiBuZXcgUmVnRXhwKFwiXlwiICsgSSksIFBTRVVETzogbmV3IFJlZ0V4cChcIl5cIiArIFcpLCBDSElMRDogbmV3IFJlZ0V4cChcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyBNICsgXCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIE0gKyBcIiooPzooWystXXwpXCIgKyBNICsgXCIqKFxcXFxkKyl8KSlcIiArIE0gKyBcIipcXFxcKXwpXCIsIFwiaVwiKSwgYm9vbDogbmV3IFJlZ0V4cChcIl4oPzpcIiArIFAgKyBcIikkXCIsIFwiaVwiKSwgbmVlZHNDb250ZXh0OiBuZXcgUmVnRXhwKFwiXlwiICsgTSArIFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArIE0gKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyBNICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIpIH0sXG4gICAgICAgICAgICBHID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcbiAgICAgICAgICAgIFkgPSAvXmhcXGQkL2ksXG4gICAgICAgICAgICBRID0gL15bXntdK1xce1xccypcXFtuYXRpdmUgXFx3LyxcbiAgICAgICAgICAgIEogPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcbiAgICAgICAgICAgIEsgPSAvWyt+XS8sXG4gICAgICAgICAgICBaID0gbmV3IFJlZ0V4cChcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgTSArIFwiP3woXCIgKyBNICsgXCIpfC4pXCIsIFwiaWdcIiksXG4gICAgICAgICAgICBlZSA9IGZ1bmN0aW9uKGUsIHQsIG4pIHsgdmFyIHIgPSBcIjB4XCIgKyB0IC0gNjU1MzY7IHJldHVybiByICE9PSByIHx8IG4gPyB0IDogciA8IDAgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKHIgKyA2NTUzNikgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKHIgPj4gMTAgfCA1NTI5NiwgMTAyMyAmIHIgfCA1NjMyMCkgfSxcbiAgICAgICAgICAgIHRlID0gLyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFwwLVxceDFmXFx4N2YtXFx1RkZGRlxcdy1dL2csXG4gICAgICAgICAgICBuZSA9IGZ1bmN0aW9uKGUsIHQpIHsgcmV0dXJuIHQgPyBcIlxcMFwiID09PSBlID8gXCLvv71cIiA6IGUuc2xpY2UoMCwgLTEpICsgXCJcXFxcXCIgKyBlLmNoYXJDb2RlQXQoZS5sZW5ndGggLSAxKS50b1N0cmluZygxNikgKyBcIiBcIiA6IFwiXFxcXFwiICsgZSB9LFxuICAgICAgICAgICAgcmUgPSBmdW5jdGlvbigpIHsgcCgpIH0sXG4gICAgICAgICAgICBpZSA9IG1lKGZ1bmN0aW9uKGUpIHsgcmV0dXJuICEwID09PSBlLmRpc2FibGVkICYmIChcImZvcm1cIiBpbiBlIHx8IFwibGFiZWxcIiBpbiBlKSB9LCB7IGRpcjogXCJwYXJlbnROb2RlXCIsIG5leHQ6IFwibGVnZW5kXCIgfSk7IHRyeSB7IEwuYXBwbHkoQSA9IEguY2FsbCh3LmNoaWxkTm9kZXMpLCB3LmNoaWxkTm9kZXMpLCBBW3cuY2hpbGROb2Rlcy5sZW5ndGhdLm5vZGVUeXBlIH0gY2F0Y2ggKGUpIHsgTCA9IHsgYXBwbHk6IEEubGVuZ3RoID8gZnVuY3Rpb24oZSwgdCkgeyBxLmFwcGx5KGUsIEguY2FsbCh0KSkgfSA6IGZ1bmN0aW9uKGUsIHQpIHsgdmFyIG4gPSBlLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSAwOyB3aGlsZSAoZVtuKytdID0gdFtyKytdKTtcbiAgICAgICAgICAgICAgICAgICAgZS5sZW5ndGggPSBuIC0gMSB9IH0gfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9lKGUsIHQsIHIsIGkpIHsgdmFyIG8sIHMsIGwsIGMsIGYsIGgsIHYsIG0gPSB0ICYmIHQub3duZXJEb2N1bWVudCxcbiAgICAgICAgICAgICAgICBUID0gdCA/IHQubm9kZVR5cGUgOiA5OyBpZiAociA9IHIgfHwgW10sIFwic3RyaW5nXCIgIT0gdHlwZW9mIGUgfHwgIWUgfHwgMSAhPT0gVCAmJiA5ICE9PSBUICYmIDExICE9PSBUKSByZXR1cm4gcjsgaWYgKCFpICYmICgodCA/IHQub3duZXJEb2N1bWVudCB8fCB0IDogdykgIT09IGQgJiYgcCh0KSwgdCA9IHQgfHwgZCwgZykpIHsgaWYgKDExICE9PSBUICYmIChmID0gSi5leGVjKGUpKSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8gPSBmWzFdKSB7IGlmICg5ID09PSBUKSB7IGlmICghKGwgPSB0LmdldEVsZW1lbnRCeUlkKG8pKSkgcmV0dXJuIHI7IGlmIChsLmlkID09PSBvKSByZXR1cm4gci5wdXNoKGwpLCByIH0gZWxzZSBpZiAobSAmJiAobCA9IG0uZ2V0RWxlbWVudEJ5SWQobykpICYmIHgodCwgbCkgJiYgbC5pZCA9PT0gbykgcmV0dXJuIHIucHVzaChsKSwgciB9XG4gICAgICAgICAgICAgICAgZWxzZSB7IGlmIChmWzJdKSByZXR1cm4gTC5hcHBseShyLCB0LmdldEVsZW1lbnRzQnlUYWdOYW1lKGUpKSwgcjsgaWYgKChvID0gZlszXSkgJiYgbi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSkgcmV0dXJuIEwuYXBwbHkociwgdC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKG8pKSwgciB9IGlmIChuLnFzYSAmJiAhU1tlICsgXCIgXCJdICYmICgheSB8fCAheS50ZXN0KGUpKSkgeyBpZiAoMSAhPT0gVCkgbSA9IHQsIHYgPSBlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChcIm9iamVjdFwiICE9PSB0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIChjID0gdC5nZXRBdHRyaWJ1dGUoXCJpZFwiKSkgPyBjID0gYy5yZXBsYWNlKHRlLCBuZSk6IHQuc2V0QXR0cmlidXRlKFwiaWRcIiwgYyA9IGIpLCBzID0gKGggPSBhKGUpKS5sZW5ndGg7IHdoaWxlIChzLS0pIGhbc10gPSBcIiNcIiArIGMgKyBcIiBcIiArIHZlKGhbc10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IGguam9pbihcIixcIiksIG0gPSBLLnRlc3QoZSkgJiYgZ2UodC5wYXJlbnROb2RlKSB8fCB0IH0gaWYgKHYpIHRyeSB7IHJldHVybiBMLmFwcGx5KHIsIG0ucXVlcnlTZWxlY3RvckFsbCh2KSksIHIgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge30gZmluYWxseSB7IGMgPT09IGIgJiYgdC5yZW1vdmVBdHRyaWJ1dGUoXCJpZFwiKSB9IH0gfSByZXR1cm4gdShlLnJlcGxhY2UoQiwgXCIkMVwiKSwgdCwgciwgaSkgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFlKCkgeyB2YXIgZSA9IFtdO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiB0KG4sIGkpIHsgcmV0dXJuIGUucHVzaChuICsgXCIgXCIpID4gci5jYWNoZUxlbmd0aCAmJiBkZWxldGUgdFtlLnNoaWZ0KCldLCB0W24gKyBcIiBcIl0gPSBpIH0gcmV0dXJuIHQgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNlKGUpIHsgcmV0dXJuIGVbYl0gPSAhMCwgZSB9XG5cbiAgICAgICAgZnVuY3Rpb24gdWUoZSkgeyB2YXIgdCA9IGQuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpOyB0cnkgeyByZXR1cm4gISFlKHQpIH0gY2F0Y2ggKGUpIHsgcmV0dXJuICExIH0gZmluYWxseSB7IHQucGFyZW50Tm9kZSAmJiB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodCksIHQgPSBudWxsIH0gfVxuXG4gICAgICAgIGZ1bmN0aW9uIGxlKGUsIHQpIHsgdmFyIG4gPSBlLnNwbGl0KFwifFwiKSxcbiAgICAgICAgICAgICAgICBpID0gbi5sZW5ndGg7IHdoaWxlIChpLS0pIHIuYXR0ckhhbmRsZVtuW2ldXSA9IHQgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNlKGUsIHQpIHsgdmFyIG4gPSB0ICYmIGUsXG4gICAgICAgICAgICAgICAgciA9IG4gJiYgMSA9PT0gZS5ub2RlVHlwZSAmJiAxID09PSB0Lm5vZGVUeXBlICYmIGUuc291cmNlSW5kZXggLSB0LnNvdXJjZUluZGV4OyBpZiAocikgcmV0dXJuIHI7IGlmIChuKVxuICAgICAgICAgICAgICAgIHdoaWxlIChuID0gbi5uZXh0U2libGluZylcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4gPT09IHQpIHJldHVybiAtMTsgcmV0dXJuIGUgPyAxIDogLTEgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGZlKGUpIHsgcmV0dXJuIGZ1bmN0aW9uKHQpIHsgcmV0dXJuIFwiaW5wdXRcIiA9PT0gdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICYmIHQudHlwZSA9PT0gZSB9IH1cblxuICAgICAgICBmdW5jdGlvbiBwZShlKSB7IHJldHVybiBmdW5jdGlvbih0KSB7IHZhciBuID0gdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpOyByZXR1cm4gKFwiaW5wdXRcIiA9PT0gbiB8fCBcImJ1dHRvblwiID09PSBuKSAmJiB0LnR5cGUgPT09IGUgfSB9XG5cbiAgICAgICAgZnVuY3Rpb24gZGUoZSkgeyByZXR1cm4gZnVuY3Rpb24odCkgeyByZXR1cm4gXCJmb3JtXCIgaW4gdCA/IHQucGFyZW50Tm9kZSAmJiAhMSA9PT0gdC5kaXNhYmxlZCA/IFwibGFiZWxcIiBpbiB0ID8gXCJsYWJlbFwiIGluIHQucGFyZW50Tm9kZSA/IHQucGFyZW50Tm9kZS5kaXNhYmxlZCA9PT0gZSA6IHQuZGlzYWJsZWQgPT09IGUgOiB0LmlzRGlzYWJsZWQgPT09IGUgfHwgdC5pc0Rpc2FibGVkICE9PSAhZSAmJiBpZSh0KSA9PT0gZSA6IHQuZGlzYWJsZWQgPT09IGUgOiBcImxhYmVsXCIgaW4gdCAmJiB0LmRpc2FibGVkID09PSBlIH0gfVxuXG4gICAgICAgIGZ1bmN0aW9uIGhlKGUpIHsgcmV0dXJuIHNlKGZ1bmN0aW9uKHQpIHsgcmV0dXJuIHQgPSArdCwgc2UoZnVuY3Rpb24obiwgcikgeyB2YXIgaSwgbyA9IGUoW10sIG4ubGVuZ3RoLCB0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBvLmxlbmd0aDsgd2hpbGUgKGEtLSkgbltpID0gb1thXV0gJiYgKG5baV0gPSAhKHJbaV0gPSBuW2ldKSkgfSkgfSkgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdlKGUpIHsgcmV0dXJuIGUgJiYgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgZS5nZXRFbGVtZW50c0J5VGFnTmFtZSAmJiBlIH0gbiA9IG9lLnN1cHBvcnQgPSB7fSwgbyA9IG9lLmlzWE1MID0gZnVuY3Rpb24oZSkgeyB2YXIgdCA9IGUgJiYgKGUub3duZXJEb2N1bWVudCB8fCBlKS5kb2N1bWVudEVsZW1lbnQ7IHJldHVybiAhIXQgJiYgXCJIVE1MXCIgIT09IHQubm9kZU5hbWUgfSwgcCA9IG9lLnNldERvY3VtZW50ID0gZnVuY3Rpb24oZSkgeyB2YXIgdCwgaSwgYSA9IGUgPyBlLm93bmVyRG9jdW1lbnQgfHwgZSA6IHc7IHJldHVybiBhICE9PSBkICYmIDkgPT09IGEubm9kZVR5cGUgJiYgYS5kb2N1bWVudEVsZW1lbnQgPyAoZCA9IGEsIGggPSBkLmRvY3VtZW50RWxlbWVudCwgZyA9ICFvKGQpLCB3ICE9PSBkICYmIChpID0gZC5kZWZhdWx0VmlldykgJiYgaS50b3AgIT09IGkgJiYgKGkuYWRkRXZlbnRMaXN0ZW5lciA/IGkuYWRkRXZlbnRMaXN0ZW5lcihcInVubG9hZFwiLCByZSwgITEpIDogaS5hdHRhY2hFdmVudCAmJiBpLmF0dGFjaEV2ZW50KFwib251bmxvYWRcIiwgcmUpKSwgbi5hdHRyaWJ1dGVzID0gdWUoZnVuY3Rpb24oZSkgeyByZXR1cm4gZS5jbGFzc05hbWUgPSBcImlcIiwgIWUuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpIH0pLCBuLmdldEVsZW1lbnRzQnlUYWdOYW1lID0gdWUoZnVuY3Rpb24oZSkgeyByZXR1cm4gZS5hcHBlbmRDaGlsZChkLmNyZWF0ZUNvbW1lbnQoXCJcIikpLCAhZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoIH0pLCBuLmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBRLnRlc3QoZC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKSwgbi5nZXRCeUlkID0gdWUoZnVuY3Rpb24oZSkgeyByZXR1cm4gaC5hcHBlbmRDaGlsZChlKS5pZCA9IGIsICFkLmdldEVsZW1lbnRzQnlOYW1lIHx8ICFkLmdldEVsZW1lbnRzQnlOYW1lKGIpLmxlbmd0aCB9KSwgbi5nZXRCeUlkID8gKHIuZmlsdGVyLklEID0gZnVuY3Rpb24oZSkgeyB2YXIgdCA9IGUucmVwbGFjZShaLCBlZSk7IHJldHVybiBmdW5jdGlvbihlKSB7IHJldHVybiBlLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSB0IH0gfSwgci5maW5kLklEID0gZnVuY3Rpb24oZSwgdCkgeyBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgdC5nZXRFbGVtZW50QnlJZCAmJiBnKSB7IHZhciBuID0gdC5nZXRFbGVtZW50QnlJZChlKTsgcmV0dXJuIG4gPyBbbl0gOiBbXSB9IH0pIDogKHIuZmlsdGVyLklEID0gZnVuY3Rpb24oZSkgeyB2YXIgdCA9IGUucmVwbGFjZShaLCBlZSk7IHJldHVybiBmdW5jdGlvbihlKSB7IHZhciBuID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgZS5nZXRBdHRyaWJ1dGVOb2RlICYmIGUuZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpOyByZXR1cm4gbiAmJiBuLnZhbHVlID09PSB0IH0gfSwgci5maW5kLklEID0gZnVuY3Rpb24oZSwgdCkgeyBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgdC5nZXRFbGVtZW50QnlJZCAmJiBnKSB7IHZhciBuLCByLCBpLCBvID0gdC5nZXRFbGVtZW50QnlJZChlKTsgaWYgKG8pIHsgaWYgKChuID0gby5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIikpICYmIG4udmFsdWUgPT09IGUpIHJldHVybiBbb107XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gdC5nZXRFbGVtZW50c0J5TmFtZShlKSwgciA9IDA7IHdoaWxlIChvID0gaVtyKytdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgobiA9IG8uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpKSAmJiBuLnZhbHVlID09PSBlKSByZXR1cm4gW29dIH0gcmV0dXJuIFtdIH0gfSksIHIuZmluZC5UQUcgPSBuLmdldEVsZW1lbnRzQnlUYWdOYW1lID8gZnVuY3Rpb24oZSwgdCkgeyByZXR1cm4gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgdC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/IHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoZSkgOiBuLnFzYSA/IHQucXVlcnlTZWxlY3RvckFsbChlKSA6IHZvaWQgMCB9IDogZnVuY3Rpb24oZSwgdCkgeyB2YXIgbiwgciA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICAgICAgbyA9IHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoZSk7IGlmIChcIipcIiA9PT0gZSkgeyB3aGlsZSAobiA9IG9baSsrXSkgMSA9PT0gbi5ub2RlVHlwZSAmJiByLnB1c2gobik7IHJldHVybiByIH0gcmV0dXJuIG8gfSwgci5maW5kLkNMQVNTID0gbi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKGUsIHQpIHsgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBnKSByZXR1cm4gdC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGUpIH0sIHYgPSBbXSwgeSA9IFtdLCAobi5xc2EgPSBRLnRlc3QoZC5xdWVyeVNlbGVjdG9yQWxsKSkgJiYgKHVlKGZ1bmN0aW9uKGUpIHsgaC5hcHBlbmRDaGlsZChlKS5pbm5lckhUTUwgPSBcIjxhIGlkPSdcIiArIGIgKyBcIic+PC9hPjxzZWxlY3QgaWQ9J1wiICsgYiArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCIsIGUucXVlcnlTZWxlY3RvckFsbChcIlttc2FsbG93Y2FwdHVyZV49JyddXCIpLmxlbmd0aCAmJiB5LnB1c2goXCJbKl4kXT1cIiArIE0gKyBcIiooPzonJ3xcXFwiXFxcIilcIiksIGUucXVlcnlTZWxlY3RvckFsbChcIltzZWxlY3RlZF1cIikubGVuZ3RoIHx8IHkucHVzaChcIlxcXFxbXCIgKyBNICsgXCIqKD86dmFsdWV8XCIgKyBQICsgXCIpXCIpLCBlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbaWR+PVwiICsgYiArIFwiLV1cIikubGVuZ3RoIHx8IHkucHVzaChcIn49XCIpLCBlLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGggfHwgeS5wdXNoKFwiOmNoZWNrZWRcIiksIGUucXVlcnlTZWxlY3RvckFsbChcImEjXCIgKyBiICsgXCIrKlwiKS5sZW5ndGggfHwgeS5wdXNoKFwiLiMuK1srfl1cIikgfSksIHVlKGZ1bmN0aW9uKGUpIHsgZS5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JycgZGlzYWJsZWQ9J2Rpc2FibGVkJz48L2E+PHNlbGVjdCBkaXNhYmxlZD0nZGlzYWJsZWQnPjxvcHRpb24vPjwvc2VsZWN0PlwiOyB2YXIgdCA9IGQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICAgICAgICAgIHQuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcImhpZGRlblwiKSwgZS5hcHBlbmRDaGlsZCh0KS5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsIFwiRFwiKSwgZS5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoICYmIHkucHVzaChcIm5hbWVcIiArIE0gKyBcIipbKl4kfCF+XT89XCIpLCAyICE9PSBlLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZW5hYmxlZFwiKS5sZW5ndGggJiYgeS5wdXNoKFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiksIGguYXBwZW5kQ2hpbGQoZSkuZGlzYWJsZWQgPSAhMCwgMiAhPT0gZS5xdWVyeVNlbGVjdG9yQWxsKFwiOmRpc2FibGVkXCIpLmxlbmd0aCAmJiB5LnB1c2goXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiKSwgZS5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKSwgeS5wdXNoKFwiLC4qOlwiKSB9KSksIChuLm1hdGNoZXNTZWxlY3RvciA9IFEudGVzdChtID0gaC5tYXRjaGVzIHx8IGgud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IGgubW96TWF0Y2hlc1NlbGVjdG9yIHx8IGgub01hdGNoZXNTZWxlY3RvciB8fCBoLm1zTWF0Y2hlc1NlbGVjdG9yKSkgJiYgdWUoZnVuY3Rpb24oZSkgeyBuLmRpc2Nvbm5lY3RlZE1hdGNoID0gbS5jYWxsKGUsIFwiKlwiKSwgbS5jYWxsKGUsIFwiW3MhPScnXTp4XCIpLCB2LnB1c2goXCIhPVwiLCBXKSB9KSwgeSA9IHkubGVuZ3RoICYmIG5ldyBSZWdFeHAoeS5qb2luKFwifFwiKSksIHYgPSB2Lmxlbmd0aCAmJiBuZXcgUmVnRXhwKHYuam9pbihcInxcIikpLCB0ID0gUS50ZXN0KGguY29tcGFyZURvY3VtZW50UG9zaXRpb24pLCB4ID0gdCB8fCBRLnRlc3QoaC5jb250YWlucykgPyBmdW5jdGlvbihlLCB0KSB7IHZhciBuID0gOSA9PT0gZS5ub2RlVHlwZSA/IGUuZG9jdW1lbnRFbGVtZW50IDogZSxcbiAgICAgICAgICAgICAgICAgICAgciA9IHQgJiYgdC5wYXJlbnROb2RlOyByZXR1cm4gZSA9PT0gciB8fCAhKCFyIHx8IDEgIT09IHIubm9kZVR5cGUgfHwgIShuLmNvbnRhaW5zID8gbi5jb250YWlucyhyKSA6IGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgMTYgJiBlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHIpKSkgfSA6IGZ1bmN0aW9uKGUsIHQpIHsgaWYgKHQpXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0ID0gdC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgPT09IGUpIHJldHVybiAhMDsgcmV0dXJuICExIH0sIEQgPSB0ID8gZnVuY3Rpb24oZSwgdCkgeyBpZiAoZSA9PT0gdCkgcmV0dXJuIGYgPSAhMCwgMDsgdmFyIHIgPSAhZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICF0LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uOyByZXR1cm4gciB8fCAoMSAmIChyID0gKGUub3duZXJEb2N1bWVudCB8fCBlKSA9PT0gKHQub3duZXJEb2N1bWVudCB8fCB0KSA/IGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24odCkgOiAxKSB8fCAhbi5zb3J0RGV0YWNoZWQgJiYgdC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihlKSA9PT0gciA/IGUgPT09IGQgfHwgZS5vd25lckRvY3VtZW50ID09PSB3ICYmIHgodywgZSkgPyAtMSA6IHQgPT09IGQgfHwgdC5vd25lckRvY3VtZW50ID09PSB3ICYmIHgodywgdCkgPyAxIDogYyA/IE8oYywgZSkgLSBPKGMsIHQpIDogMCA6IDQgJiByID8gLTEgOiAxKSB9IDogZnVuY3Rpb24oZSwgdCkgeyBpZiAoZSA9PT0gdCkgcmV0dXJuIGYgPSAhMCwgMDsgdmFyIG4sIHIgPSAwLFxuICAgICAgICAgICAgICAgICAgICBpID0gZS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgICAgICBvID0gdC5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgICAgICBhID0gW2VdLFxuICAgICAgICAgICAgICAgICAgICBzID0gW3RdOyBpZiAoIWkgfHwgIW8pIHJldHVybiBlID09PSBkID8gLTEgOiB0ID09PSBkID8gMSA6IGkgPyAtMSA6IG8gPyAxIDogYyA/IE8oYywgZSkgLSBPKGMsIHQpIDogMDsgaWYgKGkgPT09IG8pIHJldHVybiBjZShlLCB0KTtcbiAgICAgICAgICAgICAgICBuID0gZTsgd2hpbGUgKG4gPSBuLnBhcmVudE5vZGUpIGEudW5zaGlmdChuKTtcbiAgICAgICAgICAgICAgICBuID0gdDsgd2hpbGUgKG4gPSBuLnBhcmVudE5vZGUpIHMudW5zaGlmdChuKTsgd2hpbGUgKGFbcl0gPT09IHNbcl0pIHIrKzsgcmV0dXJuIHIgPyBjZShhW3JdLCBzW3JdKSA6IGFbcl0gPT09IHcgPyAtMSA6IHNbcl0gPT09IHcgPyAxIDogMCB9LCBkKSA6IGQgfSwgb2UubWF0Y2hlcyA9IGZ1bmN0aW9uKGUsIHQpIHsgcmV0dXJuIG9lKGUsIG51bGwsIG51bGwsIHQpIH0sIG9lLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKGUsIHQpIHsgaWYgKChlLm93bmVyRG9jdW1lbnQgfHwgZSkgIT09IGQgJiYgcChlKSwgdCA9IHQucmVwbGFjZSh6LCBcIj0nJDEnXVwiKSwgbi5tYXRjaGVzU2VsZWN0b3IgJiYgZyAmJiAhU1t0ICsgXCIgXCJdICYmICghdiB8fCAhdi50ZXN0KHQpKSAmJiAoIXkgfHwgIXkudGVzdCh0KSkpIHRyeSB7IHZhciByID0gbS5jYWxsKGUsIHQpOyBpZiAociB8fCBuLmRpc2Nvbm5lY3RlZE1hdGNoIHx8IGUuZG9jdW1lbnQgJiYgMTEgIT09IGUuZG9jdW1lbnQubm9kZVR5cGUpIHJldHVybiByIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7fSByZXR1cm4gb2UodCwgZCwgbnVsbCwgW2VdKS5sZW5ndGggPiAwIH0sIG9lLmNvbnRhaW5zID0gZnVuY3Rpb24oZSwgdCkgeyByZXR1cm4gKGUub3duZXJEb2N1bWVudCB8fCBlKSAhPT0gZCAmJiBwKGUpLCB4KGUsIHQpIH0sIG9lLmF0dHIgPSBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAoZS5vd25lckRvY3VtZW50IHx8IGUpICE9PSBkICYmIHAoZSk7IHZhciBpID0gci5hdHRySGFuZGxlW3QudG9Mb3dlckNhc2UoKV0sXG4gICAgICAgICAgICAgICAgbyA9IGkgJiYgTi5jYWxsKHIuYXR0ckhhbmRsZSwgdC50b0xvd2VyQ2FzZSgpKSA/IGkoZSwgdCwgIWcpIDogdm9pZCAwOyByZXR1cm4gdm9pZCAwICE9PSBvID8gbyA6IG4uYXR0cmlidXRlcyB8fCAhZyA/IGUuZ2V0QXR0cmlidXRlKHQpIDogKG8gPSBlLmdldEF0dHJpYnV0ZU5vZGUodCkpICYmIG8uc3BlY2lmaWVkID8gby52YWx1ZSA6IG51bGwgfSwgb2UuZXNjYXBlID0gZnVuY3Rpb24oZSkgeyByZXR1cm4gKGUgKyBcIlwiKS5yZXBsYWNlKHRlLCBuZSkgfSwgb2UuZXJyb3IgPSBmdW5jdGlvbihlKSB7IHRocm93IG5ldyBFcnJvcihcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgZSkgfSwgb2UudW5pcXVlU29ydCA9IGZ1bmN0aW9uKGUpIHsgdmFyIHQsIHIgPSBbXSxcbiAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICBvID0gMDsgaWYgKGYgPSAhbi5kZXRlY3REdXBsaWNhdGVzLCBjID0gIW4uc29ydFN0YWJsZSAmJiBlLnNsaWNlKDApLCBlLnNvcnQoRCksIGYpIHsgd2hpbGUgKHQgPSBlW28rK10pIHQgPT09IGVbb10gJiYgKGkgPSByLnB1c2gobykpOyB3aGlsZSAoaS0tKSBlLnNwbGljZShyW2ldLCAxKSB9IHJldHVybiBjID0gbnVsbCwgZSB9LCBpID0gb2UuZ2V0VGV4dCA9IGZ1bmN0aW9uKGUpIHsgdmFyIHQsIG4gPSBcIlwiLFxuICAgICAgICAgICAgICAgIHIgPSAwLFxuICAgICAgICAgICAgICAgIG8gPSBlLm5vZGVUeXBlOyBpZiAobykgeyBpZiAoMSA9PT0gbyB8fCA5ID09PSBvIHx8IDExID09PSBvKSB7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlLnRleHRDb250ZW50KSByZXR1cm4gZS50ZXh0Q29udGVudDsgZm9yIChlID0gZS5maXJzdENoaWxkOyBlOyBlID0gZS5uZXh0U2libGluZykgbiArPSBpKGUpIH0gZWxzZSBpZiAoMyA9PT0gbyB8fCA0ID09PSBvKSByZXR1cm4gZS5ub2RlVmFsdWUgfSBlbHNlXG4gICAgICAgICAgICAgICAgd2hpbGUgKHQgPSBlW3IrK10pIG4gKz0gaSh0KTsgcmV0dXJuIG4gfSwgKHIgPSBvZS5zZWxlY3RvcnMgPSB7IGNhY2hlTGVuZ3RoOiA1MCwgY3JlYXRlUHNldWRvOiBzZSwgbWF0Y2g6IFYsIGF0dHJIYW5kbGU6IHt9LCBmaW5kOiB7fSwgcmVsYXRpdmU6IHsgXCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6ICEwIH0sIFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSwgXCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogITAgfSwgXCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH0gfSwgcHJlRmlsdGVyOiB7IEFUVFI6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGVbMV0gPSBlWzFdLnJlcGxhY2UoWiwgZWUpLCBlWzNdID0gKGVbM10gfHwgZVs0XSB8fCBlWzVdIHx8IFwiXCIpLnJlcGxhY2UoWiwgZWUpLCBcIn49XCIgPT09IGVbMl0gJiYgKGVbM10gPSBcIiBcIiArIGVbM10gKyBcIiBcIiksIGUuc2xpY2UoMCwgNCkgfSwgQ0hJTEQ6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGVbMV0gPSBlWzFdLnRvTG93ZXJDYXNlKCksIFwibnRoXCIgPT09IGVbMV0uc2xpY2UoMCwgMykgPyAoZVszXSB8fCBvZS5lcnJvcihlWzBdKSwgZVs0XSA9ICsoZVs0XSA/IGVbNV0gKyAoZVs2XSB8fCAxKSA6IDIgKiAoXCJldmVuXCIgPT09IGVbM10gfHwgXCJvZGRcIiA9PT0gZVszXSkpLCBlWzVdID0gKyhlWzddICsgZVs4XSB8fCBcIm9kZFwiID09PSBlWzNdKSkgOiBlWzNdICYmIG9lLmVycm9yKGVbMF0pLCBlIH0sIFBTRVVETzogZnVuY3Rpb24oZSkgeyB2YXIgdCwgbiA9ICFlWzZdICYmIGVbMl07IHJldHVybiBWLkNISUxELnRlc3QoZVswXSkgPyBudWxsIDogKGVbM10gPyBlWzJdID0gZVs0XSB8fCBlWzVdIHx8IFwiXCIgOiBuICYmIFgudGVzdChuKSAmJiAodCA9IGEobiwgITApKSAmJiAodCA9IG4uaW5kZXhPZihcIilcIiwgbi5sZW5ndGggLSB0KSAtIG4ubGVuZ3RoKSAmJiAoZVswXSA9IGVbMF0uc2xpY2UoMCwgdCksIGVbMl0gPSBuLnNsaWNlKDAsIHQpKSwgZS5zbGljZSgwLCAzKSkgfSB9LCBmaWx0ZXI6IHsgVEFHOiBmdW5jdGlvbihlKSB7IHZhciB0ID0gZS5yZXBsYWNlKFosIGVlKS50b0xvd2VyQ2FzZSgpOyByZXR1cm4gXCIqXCIgPT09IGUgPyBmdW5jdGlvbigpIHsgcmV0dXJuICEwIH0gOiBmdW5jdGlvbihlKSB7IHJldHVybiBlLm5vZGVOYW1lICYmIGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gdCB9IH0sIENMQVNTOiBmdW5jdGlvbihlKSB7IHZhciB0ID0gRVtlICsgXCIgXCJdOyByZXR1cm4gdCB8fCAodCA9IG5ldyBSZWdFeHAoXCIoXnxcIiArIE0gKyBcIilcIiArIGUgKyBcIihcIiArIE0gKyBcInwkKVwiKSkgJiYgRShlLCBmdW5jdGlvbihlKSB7IHJldHVybiB0LnRlc3QoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZS5jbGFzc05hbWUgJiYgZS5jbGFzc05hbWUgfHwgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgZS5nZXRBdHRyaWJ1dGUgJiYgZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiKSB9KSB9LCBBVFRSOiBmdW5jdGlvbihlLCB0LCBuKSB7IHJldHVybiBmdW5jdGlvbihyKSB7IHZhciBpID0gb2UuYXR0cihyLCBlKTsgcmV0dXJuIG51bGwgPT0gaSA/IFwiIT1cIiA9PT0gdCA6ICF0IHx8IChpICs9IFwiXCIsIFwiPVwiID09PSB0ID8gaSA9PT0gbiA6IFwiIT1cIiA9PT0gdCA/IGkgIT09IG4gOiBcIl49XCIgPT09IHQgPyBuICYmIDAgPT09IGkuaW5kZXhPZihuKSA6IFwiKj1cIiA9PT0gdCA/IG4gJiYgaS5pbmRleE9mKG4pID4gLTEgOiBcIiQ9XCIgPT09IHQgPyBuICYmIGkuc2xpY2UoLW4ubGVuZ3RoKSA9PT0gbiA6IFwifj1cIiA9PT0gdCA/IChcIiBcIiArIGkucmVwbGFjZSgkLCBcIiBcIikgKyBcIiBcIikuaW5kZXhPZihuKSA+IC0xIDogXCJ8PVwiID09PSB0ICYmIChpID09PSBuIHx8IGkuc2xpY2UoMCwgbi5sZW5ndGggKyAxKSA9PT0gbiArIFwiLVwiKSkgfSB9LCBDSElMRDogZnVuY3Rpb24oZSwgdCwgbiwgciwgaSkgeyB2YXIgbyA9IFwibnRoXCIgIT09IGUuc2xpY2UoMCwgMyksXG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gXCJsYXN0XCIgIT09IGUuc2xpY2UoLTQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IFwib2YtdHlwZVwiID09PSB0OyByZXR1cm4gMSA9PT0gciAmJiAwID09PSBpID8gZnVuY3Rpb24oZSkgeyByZXR1cm4gISFlLnBhcmVudE5vZGUgfSA6IGZ1bmN0aW9uKHQsIG4sIHUpIHsgdmFyIGwsIGMsIGYsIHAsIGQsIGgsIGcgPSBvICE9PSBhID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gdC5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBzICYmIHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtID0gIXUgJiYgIXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9ICExOyBpZiAoeSkgeyBpZiAobykgeyB3aGlsZSAoZykgeyBwID0gdDsgd2hpbGUgKHAgPSBwW2ddKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzID8gcC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSB2IDogMSA9PT0gcC5ub2RlVHlwZSkgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaCA9IGcgPSBcIm9ubHlcIiA9PT0gZSAmJiAhaCAmJiBcIm5leHRTaWJsaW5nXCIgfSByZXR1cm4gITAgfSBpZiAoaCA9IFthID8geS5maXJzdENoaWxkIDogeS5sYXN0Q2hpbGRdLCBhICYmIG0pIHsgeCA9IChkID0gKGwgPSAoYyA9IChmID0gKHAgPSB5KVtiXSB8fCAocFtiXSA9IHt9KSlbcC51bmlxdWVJRF0gfHwgKGZbcC51bmlxdWVJRF0gPSB7fSkpW2VdIHx8IFtdKVswXSA9PT0gVCAmJiBsWzFdKSAmJiBsWzJdLCBwID0gZCAmJiB5LmNoaWxkTm9kZXNbZF07IHdoaWxlIChwID0gKytkICYmIHAgJiYgcFtnXSB8fCAoeCA9IGQgPSAwKSB8fCBoLnBvcCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDEgPT09IHAubm9kZVR5cGUgJiYgKyt4ICYmIHAgPT09IHQpIHsgY1tlXSA9IFtULCBkLCB4XTsgYnJlYWsgfSB9IGVsc2UgaWYgKG0gJiYgKHggPSBkID0gKGwgPSAoYyA9IChmID0gKHAgPSB0KVtiXSB8fCAocFtiXSA9IHt9KSlbcC51bmlxdWVJRF0gfHwgKGZbcC51bmlxdWVJRF0gPSB7fSkpW2VdIHx8IFtdKVswXSA9PT0gVCAmJiBsWzFdKSwgITEgPT09IHgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChwID0gKytkICYmIHAgJiYgcFtnXSB8fCAoeCA9IGQgPSAwKSB8fCBoLnBvcCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChzID8gcC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSB2IDogMSA9PT0gcC5ub2RlVHlwZSkgJiYgKyt4ICYmIChtICYmICgoYyA9IChmID0gcFtiXSB8fCAocFtiXSA9IHt9KSlbcC51bmlxdWVJRF0gfHwgKGZbcC51bmlxdWVJRF0gPSB7fSkpW2VdID0gW1QsIHhdKSwgcCA9PT0gdCkpIGJyZWFrOyByZXR1cm4gKHggLT0gaSkgPT09IHIgfHwgeCAlIHIgPT0gMCAmJiB4IC8gciA+PSAwIH0gfSB9LCBQU0VVRE86IGZ1bmN0aW9uKGUsIHQpIHsgdmFyIG4sIGkgPSByLnBzZXVkb3NbZV0gfHwgci5zZXRGaWx0ZXJzW2UudG9Mb3dlckNhc2UoKV0gfHwgb2UuZXJyb3IoXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgZSk7IHJldHVybiBpW2JdID8gaSh0KSA6IGkubGVuZ3RoID4gMSA/IChuID0gW2UsIGUsIFwiXCIsIHRdLCByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoZS50b0xvd2VyQ2FzZSgpKSA/IHNlKGZ1bmN0aW9uKGUsIG4pIHsgdmFyIHIsIG8gPSBpKGUsIHQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBvLmxlbmd0aDsgd2hpbGUgKGEtLSkgZVtyID0gTyhlLCBvW2FdKV0gPSAhKG5bcl0gPSBvW2FdKSB9KSA6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGkoZSwgMCwgbikgfSkgOiBpIH0gfSwgcHNldWRvczogeyBub3Q6IHNlKGZ1bmN0aW9uKGUpIHsgdmFyIHQgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBzKGUucmVwbGFjZShCLCBcIiQxXCIpKTsgcmV0dXJuIHJbYl0gPyBzZShmdW5jdGlvbihlLCB0LCBuLCBpKSB7IHZhciBvLCBhID0gcihlLCBudWxsLCBpLCBbXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcyA9IGUubGVuZ3RoOyB3aGlsZSAocy0tKShvID0gYVtzXSkgJiYgKGVbc10gPSAhKHRbc10gPSBvKSkgfSkgOiBmdW5jdGlvbihlLCBpLCBvKSB7IHJldHVybiB0WzBdID0gZSwgcih0LCBudWxsLCBvLCBuKSwgdFswXSA9IG51bGwsICFuLnBvcCgpIH0gfSksIGhhczogc2UoZnVuY3Rpb24oZSkgeyByZXR1cm4gZnVuY3Rpb24odCkgeyByZXR1cm4gb2UoZSwgdCkubGVuZ3RoID4gMCB9IH0pLCBjb250YWluczogc2UoZnVuY3Rpb24oZSkgeyByZXR1cm4gZSA9IGUucmVwbGFjZShaLCBlZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbih0KSB7IHJldHVybiAodC50ZXh0Q29udGVudCB8fCB0LmlubmVyVGV4dCB8fCBpKHQpKS5pbmRleE9mKGUpID4gLTEgfSB9KSwgbGFuZzogc2UoZnVuY3Rpb24oZSkgeyByZXR1cm4gVS50ZXN0KGUgfHwgXCJcIikgfHwgb2UuZXJyb3IoXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGUpLCBlID0gZS5yZXBsYWNlKFosIGVlKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24odCkgeyB2YXIgbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbyB7IGlmIChuID0gZyA/IHQubGFuZyA6IHQuZ2V0QXR0cmlidXRlKFwieG1sOmxhbmdcIikgfHwgdC5nZXRBdHRyaWJ1dGUoXCJsYW5nXCIpKSByZXR1cm4gKG4gPSBuLnRvTG93ZXJDYXNlKCkpID09PSBlIHx8IDAgPT09IG4uaW5kZXhPZihlICsgXCItXCIpIH0gd2hpbGUgKCh0ID0gdC5wYXJlbnROb2RlKSAmJiAxID09PSB0Lm5vZGVUeXBlKTsgcmV0dXJuICExIH0gfSksIHRhcmdldDogZnVuY3Rpb24odCkgeyB2YXIgbiA9IGUubG9jYXRpb24gJiYgZS5sb2NhdGlvbi5oYXNoOyByZXR1cm4gbiAmJiBuLnNsaWNlKDEpID09PSB0LmlkIH0sIHJvb3Q6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGUgPT09IGggfSwgZm9jdXM6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGUgPT09IGQuYWN0aXZlRWxlbWVudCAmJiAoIWQuaGFzRm9jdXMgfHwgZC5oYXNGb2N1cygpKSAmJiAhIShlLnR5cGUgfHwgZS5ocmVmIHx8IH5lLnRhYkluZGV4KSB9LCBlbmFibGVkOiBkZSghMSksIGRpc2FibGVkOiBkZSghMCksIGNoZWNrZWQ6IGZ1bmN0aW9uKGUpIHsgdmFyIHQgPSBlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7IHJldHVybiBcImlucHV0XCIgPT09IHQgJiYgISFlLmNoZWNrZWQgfHwgXCJvcHRpb25cIiA9PT0gdCAmJiAhIWUuc2VsZWN0ZWQgfSwgc2VsZWN0ZWQ6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGUucGFyZW50Tm9kZSAmJiBlLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleCwgITAgPT09IGUuc2VsZWN0ZWQgfSwgZW1wdHk6IGZ1bmN0aW9uKGUpIHsgZm9yIChlID0gZS5maXJzdENoaWxkOyBlOyBlID0gZS5uZXh0U2libGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLm5vZGVUeXBlIDwgNikgcmV0dXJuICExOyByZXR1cm4gITAgfSwgcGFyZW50OiBmdW5jdGlvbihlKSB7IHJldHVybiAhci5wc2V1ZG9zLmVtcHR5KGUpIH0sIGhlYWRlcjogZnVuY3Rpb24oZSkgeyByZXR1cm4gWS50ZXN0KGUubm9kZU5hbWUpIH0sIGlucHV0OiBmdW5jdGlvbihlKSB7IHJldHVybiBHLnRlc3QoZS5ub2RlTmFtZSkgfSwgYnV0dG9uOiBmdW5jdGlvbihlKSB7IHZhciB0ID0gZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpOyByZXR1cm4gXCJpbnB1dFwiID09PSB0ICYmIFwiYnV0dG9uXCIgPT09IGUudHlwZSB8fCBcImJ1dHRvblwiID09PSB0IH0sIHRleHQ6IGZ1bmN0aW9uKGUpIHsgdmFyIHQ7IHJldHVybiBcImlucHV0XCIgPT09IGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAmJiBcInRleHRcIiA9PT0gZS50eXBlICYmIChudWxsID09ICh0ID0gZS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKSB8fCBcInRleHRcIiA9PT0gdC50b0xvd2VyQ2FzZSgpKSB9LCBmaXJzdDogaGUoZnVuY3Rpb24oKSB7IHJldHVybiBbMF0gfSksIGxhc3Q6IGhlKGZ1bmN0aW9uKGUsIHQpIHsgcmV0dXJuIFt0IC0gMV0gfSksIGVxOiBoZShmdW5jdGlvbihlLCB0LCBuKSB7IHJldHVybiBbbiA8IDAgPyBuICsgdCA6IG5dIH0pLCBldmVuOiBoZShmdW5jdGlvbihlLCB0KSB7IGZvciAodmFyIG4gPSAwOyBuIDwgdDsgbiArPSAyKSBlLnB1c2gobik7IHJldHVybiBlIH0pLCBvZGQ6IGhlKGZ1bmN0aW9uKGUsIHQpIHsgZm9yICh2YXIgbiA9IDE7IG4gPCB0OyBuICs9IDIpIGUucHVzaChuKTsgcmV0dXJuIGUgfSksIGx0OiBoZShmdW5jdGlvbihlLCB0LCBuKSB7IGZvciAodmFyIHIgPSBuIDwgMCA/IG4gKyB0IDogbjsgLS1yID49IDA7KSBlLnB1c2gocik7IHJldHVybiBlIH0pLCBndDogaGUoZnVuY3Rpb24oZSwgdCwgbikgeyBmb3IgKHZhciByID0gbiA8IDAgPyBuICsgdCA6IG47ICsrciA8IHQ7KSBlLnB1c2gocik7IHJldHVybiBlIH0pIH0gfSkucHNldWRvcy5udGggPSByLnBzZXVkb3MuZXE7IGZvciAodCBpbiB7IHJhZGlvOiAhMCwgY2hlY2tib3g6ICEwLCBmaWxlOiAhMCwgcGFzc3dvcmQ6ICEwLCBpbWFnZTogITAgfSkgci5wc2V1ZG9zW3RdID0gZmUodCk7IGZvciAodCBpbiB7IHN1Ym1pdDogITAsIHJlc2V0OiAhMCB9KSByLnBzZXVkb3NbdF0gPSBwZSh0KTtcblxuICAgICAgICBmdW5jdGlvbiB5ZSgpIHt9IHllLnByb3RvdHlwZSA9IHIuZmlsdGVycyA9IHIucHNldWRvcywgci5zZXRGaWx0ZXJzID0gbmV3IHllLCBhID0gb2UudG9rZW5pemUgPSBmdW5jdGlvbihlLCB0KSB7IHZhciBuLCBpLCBvLCBhLCBzLCB1LCBsLCBjID0ga1tlICsgXCIgXCJdOyBpZiAoYykgcmV0dXJuIHQgPyAwIDogYy5zbGljZSgwKTtcbiAgICAgICAgICAgIHMgPSBlLCB1ID0gW10sIGwgPSByLnByZUZpbHRlcjsgd2hpbGUgKHMpIHsgbiAmJiAhKGkgPSBGLmV4ZWMocykpIHx8IChpICYmIChzID0gcy5zbGljZShpWzBdLmxlbmd0aCkgfHwgcyksIHUucHVzaChvID0gW10pKSwgbiA9ICExLCAoaSA9IF8uZXhlYyhzKSkgJiYgKG4gPSBpLnNoaWZ0KCksIG8ucHVzaCh7IHZhbHVlOiBuLCB0eXBlOiBpWzBdLnJlcGxhY2UoQiwgXCIgXCIpIH0pLCBzID0gcy5zbGljZShuLmxlbmd0aCkpOyBmb3IgKGEgaW4gci5maWx0ZXIpICEoaSA9IFZbYV0uZXhlYyhzKSkgfHwgbFthXSAmJiAhKGkgPSBsW2FdKGkpKSB8fCAobiA9IGkuc2hpZnQoKSwgby5wdXNoKHsgdmFsdWU6IG4sIHR5cGU6IGEsIG1hdGNoZXM6IGkgfSksIHMgPSBzLnNsaWNlKG4ubGVuZ3RoKSk7IGlmICghbikgYnJlYWsgfSByZXR1cm4gdCA/IHMubGVuZ3RoIDogcyA/IG9lLmVycm9yKGUpIDogayhlLCB1KS5zbGljZSgwKSB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHZlKGUpIHsgZm9yICh2YXIgdCA9IDAsIG4gPSBlLmxlbmd0aCwgciA9IFwiXCI7IHQgPCBuOyB0KyspIHIgKz0gZVt0XS52YWx1ZTsgcmV0dXJuIHIgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1lKGUsIHQsIG4pIHsgdmFyIHIgPSB0LmRpcixcbiAgICAgICAgICAgICAgICBpID0gdC5uZXh0LFxuICAgICAgICAgICAgICAgIG8gPSBpIHx8IHIsXG4gICAgICAgICAgICAgICAgYSA9IG4gJiYgXCJwYXJlbnROb2RlXCIgPT09IG8sXG4gICAgICAgICAgICAgICAgcyA9IEMrKzsgcmV0dXJuIHQuZmlyc3QgPyBmdW5jdGlvbih0LCBuLCBpKSB7IHdoaWxlICh0ID0gdFtyXSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKDEgPT09IHQubm9kZVR5cGUgfHwgYSkgcmV0dXJuIGUodCwgbiwgaSk7IHJldHVybiAhMSB9IDogZnVuY3Rpb24odCwgbiwgdSkgeyB2YXIgbCwgYywgZiwgcCA9IFtULCBzXTsgaWYgKHUpIHsgd2hpbGUgKHQgPSB0W3JdKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgxID09PSB0Lm5vZGVUeXBlIHx8IGEpICYmIGUodCwgbiwgdSkpIHJldHVybiAhMCB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHQgPSB0W3JdKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDEgPT09IHQubm9kZVR5cGUgfHwgYSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZiA9IHRbYl0gfHwgKHRbYl0gPSB7fSksIGMgPSBmW3QudW5pcXVlSURdIHx8IChmW3QudW5pcXVlSURdID0ge30pLCBpICYmIGkgPT09IHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkgdCA9IHRbcl0gfHwgdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsgaWYgKChsID0gY1tvXSkgJiYgbFswXSA9PT0gVCAmJiBsWzFdID09PSBzKSByZXR1cm4gcFsyXSA9IGxbMl07IGlmIChjW29dID0gcCwgcFsyXSA9IGUodCwgbiwgdSkpIHJldHVybiAhMCB9IHJldHVybiAhMSB9IH1cblxuICAgICAgICBmdW5jdGlvbiB4ZShlKSB7IHJldHVybiBlLmxlbmd0aCA+IDEgPyBmdW5jdGlvbih0LCBuLCByKSB7IHZhciBpID0gZS5sZW5ndGg7IHdoaWxlIChpLS0pXG4gICAgICAgICAgICAgICAgICAgIGlmICghZVtpXSh0LCBuLCByKSkgcmV0dXJuICExOyByZXR1cm4gITAgfSA6IGVbMF0gfVxuXG4gICAgICAgIGZ1bmN0aW9uIGJlKGUsIHQsIG4pIHsgZm9yICh2YXIgciA9IDAsIGkgPSB0Lmxlbmd0aDsgciA8IGk7IHIrKykgb2UoZSwgdFtyXSwgbik7IHJldHVybiBuIH1cblxuICAgICAgICBmdW5jdGlvbiB3ZShlLCB0LCBuLCByLCBpKSB7IGZvciAodmFyIG8sIGEgPSBbXSwgcyA9IDAsIHUgPSBlLmxlbmd0aCwgbCA9IG51bGwgIT0gdDsgcyA8IHU7IHMrKykobyA9IGVbc10pICYmIChuICYmICFuKG8sIHIsIGkpIHx8IChhLnB1c2gobyksIGwgJiYgdC5wdXNoKHMpKSk7IHJldHVybiBhIH1cblxuICAgICAgICBmdW5jdGlvbiBUZShlLCB0LCBuLCByLCBpLCBvKSB7IHJldHVybiByICYmICFyW2JdICYmIChyID0gVGUocikpLCBpICYmICFpW2JdICYmIChpID0gVGUoaSwgbykpLCBzZShmdW5jdGlvbihvLCBhLCBzLCB1KSB7IHZhciBsLCBjLCBmLCBwID0gW10sXG4gICAgICAgICAgICAgICAgICAgIGQgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgaCA9IGEubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBnID0gbyB8fCBiZSh0IHx8IFwiKlwiLCBzLm5vZGVUeXBlID8gW3NdIDogcywgW10pLFxuICAgICAgICAgICAgICAgICAgICB5ID0gIWUgfHwgIW8gJiYgdCA/IGcgOiB3ZShnLCBwLCBlLCBzLCB1KSxcbiAgICAgICAgICAgICAgICAgICAgdiA9IG4gPyBpIHx8IChvID8gZSA6IGggfHwgcikgPyBbXSA6IGEgOiB5OyBpZiAobiAmJiBuKHksIHYsIHMsIHUpLCByKSB7IGwgPSB3ZSh2LCBkKSwgcihsLCBbXSwgcywgdSksIGMgPSBsLmxlbmd0aDsgd2hpbGUgKGMtLSkoZiA9IGxbY10pICYmICh2W2RbY11dID0gISh5W2RbY11dID0gZikpIH0gaWYgKG8pIHsgaWYgKGkgfHwgZSkgeyBpZiAoaSkgeyBsID0gW10sIGMgPSB2Lmxlbmd0aDsgd2hpbGUgKGMtLSkoZiA9IHZbY10pICYmIGwucHVzaCh5W2NdID0gZik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaShudWxsLCB2ID0gW10sIGwsIHUpIH0gYyA9IHYubGVuZ3RoOyB3aGlsZSAoYy0tKShmID0gdltjXSkgJiYgKGwgPSBpID8gTyhvLCBmKSA6IHBbY10pID4gLTEgJiYgKG9bbF0gPSAhKGFbbF0gPSBmKSkgfSB9IGVsc2UgdiA9IHdlKHYgPT09IGEgPyB2LnNwbGljZShoLCB2Lmxlbmd0aCkgOiB2KSwgaSA/IGkobnVsbCwgYSwgdiwgdSkgOiBMLmFwcGx5KGEsIHYpIH0pIH1cblxuICAgICAgICBmdW5jdGlvbiBDZShlKSB7IGZvciAodmFyIHQsIG4sIGksIG8gPSBlLmxlbmd0aCwgYSA9IHIucmVsYXRpdmVbZVswXS50eXBlXSwgcyA9IGEgfHwgci5yZWxhdGl2ZVtcIiBcIl0sIHUgPSBhID8gMSA6IDAsIGMgPSBtZShmdW5jdGlvbihlKSB7IHJldHVybiBlID09PSB0IH0sIHMsICEwKSwgZiA9IG1lKGZ1bmN0aW9uKGUpIHsgcmV0dXJuIE8odCwgZSkgPiAtMSB9LCBzLCAhMCksIHAgPSBbZnVuY3Rpb24oZSwgbiwgcikgeyB2YXIgaSA9ICFhICYmIChyIHx8IG4gIT09IGwpIHx8ICgodCA9IG4pLm5vZGVUeXBlID8gYyhlLCBuLCByKSA6IGYoZSwgbiwgcikpOyByZXR1cm4gdCA9IG51bGwsIGkgfV07IHUgPCBvOyB1KyspXG4gICAgICAgICAgICAgICAgaWYgKG4gPSByLnJlbGF0aXZlW2VbdV0udHlwZV0pIHAgPSBbbWUoeGUocCksIG4pXTtcbiAgICAgICAgICAgICAgICBlbHNlIHsgaWYgKChuID0gci5maWx0ZXJbZVt1XS50eXBlXS5hcHBseShudWxsLCBlW3VdLm1hdGNoZXMpKVtiXSkgeyBmb3IgKGkgPSArK3U7IGkgPCBvOyBpKyspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIucmVsYXRpdmVbZVtpXS50eXBlXSkgYnJlYWs7IHJldHVybiBUZSh1ID4gMSAmJiB4ZShwKSwgdSA+IDEgJiYgdmUoZS5zbGljZSgwLCB1IC0gMSkuY29uY2F0KHsgdmFsdWU6IFwiIFwiID09PSBlW3UgLSAyXS50eXBlID8gXCIqXCIgOiBcIlwiIH0pKS5yZXBsYWNlKEIsIFwiJDFcIiksIG4sIHUgPCBpICYmIENlKGUuc2xpY2UodSwgaSkpLCBpIDwgbyAmJiBDZShlID0gZS5zbGljZShpKSksIGkgPCBvICYmIHZlKGUpKSB9IHAucHVzaChuKSB9XG4gICAgICAgICAgICByZXR1cm4geGUocCkgfVxuXG4gICAgICAgIGZ1bmN0aW9uIEVlKGUsIHQpIHsgdmFyIG4gPSB0Lmxlbmd0aCA+IDAsXG4gICAgICAgICAgICAgICAgaSA9IGUubGVuZ3RoID4gMCxcbiAgICAgICAgICAgICAgICBvID0gZnVuY3Rpb24obywgYSwgcywgdSwgYykgeyB2YXIgZiwgaCwgeSwgdiA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtID0gXCIwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gbyAmJiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgPSBsLFxuICAgICAgICAgICAgICAgICAgICAgICAgQyA9IG8gfHwgaSAmJiByLmZpbmQuVEFHKFwiKlwiLCBjKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIEUgPSBUICs9IG51bGwgPT0gdyA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IC4xLFxuICAgICAgICAgICAgICAgICAgICAgICAgayA9IEMubGVuZ3RoOyBmb3IgKGMgJiYgKGwgPSBhID09PSBkIHx8IGEgfHwgYyk7IG0gIT09IGsgJiYgbnVsbCAhPSAoZiA9IENbbV0pOyBtKyspIHsgaWYgKGkgJiYgZikgeyBoID0gMCwgYSB8fCBmLm93bmVyRG9jdW1lbnQgPT09IGQgfHwgKHAoZiksIHMgPSAhZyk7IHdoaWxlICh5ID0gZVtoKytdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeShmLCBhIHx8IGQsIHMpKSB7IHUucHVzaChmKTsgYnJlYWsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgJiYgKFQgPSBFKSB9IG4gJiYgKChmID0gIXkgJiYgZikgJiYgdi0tLCBvICYmIHgucHVzaChmKSkgfSBpZiAodiArPSBtLCBuICYmIG0gIT09IHYpIHsgaCA9IDA7IHdoaWxlICh5ID0gdFtoKytdKSB5KHgsIGIsIGEsIHMpOyBpZiAobykgeyBpZiAodiA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChtLS0pIHhbbV0gfHwgYlttXSB8fCAoYlttXSA9IGouY2FsbCh1KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IHdlKGIpIH0gTC5hcHBseSh1LCBiKSwgYyAmJiAhbyAmJiBiLmxlbmd0aCA+IDAgJiYgdiArIHQubGVuZ3RoID4gMSAmJiBvZS51bmlxdWVTb3J0KHUpIH0gcmV0dXJuIGMgJiYgKFQgPSBFLCBsID0gdyksIHggfTsgcmV0dXJuIG4gPyBzZShvKSA6IG8gfSByZXR1cm4gcyA9IG9lLmNvbXBpbGUgPSBmdW5jdGlvbihlLCB0KSB7IHZhciBuLCByID0gW10sXG4gICAgICAgICAgICAgICAgaSA9IFtdLFxuICAgICAgICAgICAgICAgIG8gPSBTW2UgKyBcIiBcIl07IGlmICghbykgeyB0IHx8ICh0ID0gYShlKSksIG4gPSB0Lmxlbmd0aDsgd2hpbGUgKG4tLSkobyA9IENlKHRbbl0pKVtiXSA/IHIucHVzaChvKSA6IGkucHVzaChvKTtcbiAgICAgICAgICAgICAgICAobyA9IFMoZSwgRWUoaSwgcikpKS5zZWxlY3RvciA9IGUgfSByZXR1cm4gbyB9LCB1ID0gb2Uuc2VsZWN0ID0gZnVuY3Rpb24oZSwgdCwgbiwgaSkgeyB2YXIgbywgdSwgbCwgYywgZiwgcCA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSAmJiBlLFxuICAgICAgICAgICAgICAgIGQgPSAhaSAmJiBhKGUgPSBwLnNlbGVjdG9yIHx8IGUpOyBpZiAobiA9IG4gfHwgW10sIDEgPT09IGQubGVuZ3RoKSB7IGlmICgodSA9IGRbMF0gPSBkWzBdLnNsaWNlKDApKS5sZW5ndGggPiAyICYmIFwiSURcIiA9PT0gKGwgPSB1WzBdKS50eXBlICYmIDkgPT09IHQubm9kZVR5cGUgJiYgZyAmJiByLnJlbGF0aXZlW3VbMV0udHlwZV0pIHsgaWYgKCEodCA9IChyLmZpbmQuSUQobC5tYXRjaGVzWzBdLnJlcGxhY2UoWiwgZWUpLCB0KSB8fCBbXSlbMF0pKSByZXR1cm4gbjtcbiAgICAgICAgICAgICAgICAgICAgcCAmJiAodCA9IHQucGFyZW50Tm9kZSksIGUgPSBlLnNsaWNlKHUuc2hpZnQoKS52YWx1ZS5sZW5ndGgpIH0gbyA9IFYubmVlZHNDb250ZXh0LnRlc3QoZSkgPyAwIDogdS5sZW5ndGg7IHdoaWxlIChvLS0pIHsgaWYgKGwgPSB1W29dLCByLnJlbGF0aXZlW2MgPSBsLnR5cGVdKSBicmVhazsgaWYgKChmID0gci5maW5kW2NdKSAmJiAoaSA9IGYobC5tYXRjaGVzWzBdLnJlcGxhY2UoWiwgZWUpLCBLLnRlc3QodVswXS50eXBlKSAmJiBnZSh0LnBhcmVudE5vZGUpIHx8IHQpKSkgeyBpZiAodS5zcGxpY2UobywgMSksICEoZSA9IGkubGVuZ3RoICYmIHZlKHUpKSkgcmV0dXJuIEwuYXBwbHkobiwgaSksIG47IGJyZWFrIH0gfSB9IHJldHVybiAocCB8fCBzKGUsIGQpKShpLCB0LCAhZywgbiwgIXQgfHwgSy50ZXN0KGUpICYmIGdlKHQucGFyZW50Tm9kZSkgfHwgdCksIG4gfSwgbi5zb3J0U3RhYmxlID0gYi5zcGxpdChcIlwiKS5zb3J0KEQpLmpvaW4oXCJcIikgPT09IGIsIG4uZGV0ZWN0RHVwbGljYXRlcyA9ICEhZiwgcCgpLCBuLnNvcnREZXRhY2hlZCA9IHVlKGZ1bmN0aW9uKGUpIHsgcmV0dXJuIDEgJiBlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGQuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpKSB9KSwgdWUoZnVuY3Rpb24oZSkgeyByZXR1cm4gZS5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIiwgXCIjXCIgPT09IGUuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpIH0pIHx8IGxlKFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFwiLCBmdW5jdGlvbihlLCB0LCBuKSB7IGlmICghbikgcmV0dXJuIGUuZ2V0QXR0cmlidXRlKHQsIFwidHlwZVwiID09PSB0LnRvTG93ZXJDYXNlKCkgPyAxIDogMikgfSksIG4uYXR0cmlidXRlcyAmJiB1ZShmdW5jdGlvbihlKSB7IHJldHVybiBlLmlubmVySFRNTCA9IFwiPGlucHV0Lz5cIiwgZS5maXJzdENoaWxkLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIFwiXCIpLCBcIlwiID09PSBlLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgfSkgfHwgbGUoXCJ2YWx1ZVwiLCBmdW5jdGlvbihlLCB0LCBuKSB7IGlmICghbiAmJiBcImlucHV0XCIgPT09IGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkgcmV0dXJuIGUuZGVmYXVsdFZhbHVlIH0pLCB1ZShmdW5jdGlvbihlKSB7IHJldHVybiBudWxsID09IGUuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgfSkgfHwgbGUoUCwgZnVuY3Rpb24oZSwgdCwgbikgeyB2YXIgcjsgaWYgKCFuKSByZXR1cm4gITAgPT09IGVbdF0gPyB0LnRvTG93ZXJDYXNlKCkgOiAociA9IGUuZ2V0QXR0cmlidXRlTm9kZSh0KSkgJiYgci5zcGVjaWZpZWQgPyByLnZhbHVlIDogbnVsbCB9KSwgb2UgfShlKTtcbiAgICB3LmZpbmQgPSBFLCB3LmV4cHIgPSBFLnNlbGVjdG9ycywgdy5leHByW1wiOlwiXSA9IHcuZXhwci5wc2V1ZG9zLCB3LnVuaXF1ZVNvcnQgPSB3LnVuaXF1ZSA9IEUudW5pcXVlU29ydCwgdy50ZXh0ID0gRS5nZXRUZXh0LCB3LmlzWE1MRG9jID0gRS5pc1hNTCwgdy5jb250YWlucyA9IEUuY29udGFpbnMsIHcuZXNjYXBlU2VsZWN0b3IgPSBFLmVzY2FwZTsgdmFyIGsgPSBmdW5jdGlvbihlLCB0LCBuKSB7IHZhciByID0gW10sXG4gICAgICAgICAgICAgICAgaSA9IHZvaWQgMCAhPT0gbjsgd2hpbGUgKChlID0gZVt0XSkgJiYgOSAhPT0gZS5ub2RlVHlwZSlcbiAgICAgICAgICAgICAgICBpZiAoMSA9PT0gZS5ub2RlVHlwZSkgeyBpZiAoaSAmJiB3KGUpLmlzKG4pKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgci5wdXNoKGUpIH1cbiAgICAgICAgICAgIHJldHVybiByIH0sXG4gICAgICAgIFMgPSBmdW5jdGlvbihlLCB0KSB7IGZvciAodmFyIG4gPSBbXTsgZTsgZSA9IGUubmV4dFNpYmxpbmcpIDEgPT09IGUubm9kZVR5cGUgJiYgZSAhPT0gdCAmJiBuLnB1c2goZSk7IHJldHVybiBuIH0sXG4gICAgICAgIEQgPSB3LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG4gICAgZnVuY3Rpb24gTihlLCB0KSB7IHJldHVybiBlLm5vZGVOYW1lICYmIGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gdC50b0xvd2VyQ2FzZSgpIH0gdmFyIEEgPSAvXjwoW2Etel1bXlxcL1xcMD46XFx4MjBcXHRcXHJcXG5cXGZdKilbXFx4MjBcXHRcXHJcXG5cXGZdKlxcLz8+KD86PFxcL1xcMT58KSQvaTtcblxuICAgIGZ1bmN0aW9uIGooZSwgdCwgbikgeyByZXR1cm4gZyh0KSA/IHcuZ3JlcChlLCBmdW5jdGlvbihlLCByKSB7IHJldHVybiAhIXQuY2FsbChlLCByLCBlKSAhPT0gbiB9KSA6IHQubm9kZVR5cGUgPyB3LmdyZXAoZSwgZnVuY3Rpb24oZSkgeyByZXR1cm4gZSA9PT0gdCAhPT0gbiB9KSA6IFwic3RyaW5nXCIgIT0gdHlwZW9mIHQgPyB3LmdyZXAoZSwgZnVuY3Rpb24oZSkgeyByZXR1cm4gdS5jYWxsKHQsIGUpID4gLTEgIT09IG4gfSkgOiB3LmZpbHRlcih0LCBlLCBuKSB9IHcuZmlsdGVyID0gZnVuY3Rpb24oZSwgdCwgbikgeyB2YXIgciA9IHRbMF07IHJldHVybiBuICYmIChlID0gXCI6bm90KFwiICsgZSArIFwiKVwiKSwgMSA9PT0gdC5sZW5ndGggJiYgMSA9PT0gci5ub2RlVHlwZSA/IHcuZmluZC5tYXRjaGVzU2VsZWN0b3IociwgZSkgPyBbcl0gOiBbXSA6IHcuZmluZC5tYXRjaGVzKGUsIHcuZ3JlcCh0LCBmdW5jdGlvbihlKSB7IHJldHVybiAxID09PSBlLm5vZGVUeXBlIH0pKSB9LCB3LmZuLmV4dGVuZCh7IGZpbmQ6IGZ1bmN0aW9uKGUpIHsgdmFyIHQsIG4sIHIgPSB0aGlzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpID0gdGhpczsgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIGUpIHJldHVybiB0aGlzLnB1c2hTdGFjayh3KGUpLmZpbHRlcihmdW5jdGlvbigpIHsgZm9yICh0ID0gMDsgdCA8IHI7IHQrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHcuY29udGFpbnMoaVt0XSwgdGhpcykpIHJldHVybiAhMCB9KSk7IGZvciAobiA9IHRoaXMucHVzaFN0YWNrKFtdKSwgdCA9IDA7IHQgPCByOyB0KyspIHcuZmluZChlLCBpW3RdLCBuKTsgcmV0dXJuIHIgPiAxID8gdy51bmlxdWVTb3J0KG4pIDogbiB9LCBmaWx0ZXI6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIHRoaXMucHVzaFN0YWNrKGoodGhpcywgZSB8fCBbXSwgITEpKSB9LCBub3Q6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIHRoaXMucHVzaFN0YWNrKGoodGhpcywgZSB8fCBbXSwgITApKSB9LCBpczogZnVuY3Rpb24oZSkgeyByZXR1cm4gISFqKHRoaXMsIFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgJiYgRC50ZXN0KGUpID8gdyhlKSA6IGUgfHwgW10sICExKS5sZW5ndGggfSB9KTsgdmFyIHEsIEwgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLztcbiAgICAody5mbi5pbml0ID0gZnVuY3Rpb24oZSwgdCwgbikgeyB2YXIgaSwgbzsgaWYgKCFlKSByZXR1cm4gdGhpczsgaWYgKG4gPSBuIHx8IHEsIFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHsgaWYgKCEoaSA9IFwiPFwiID09PSBlWzBdICYmIFwiPlwiID09PSBlW2UubGVuZ3RoIC0gMV0gJiYgZS5sZW5ndGggPj0gMyA/IFtudWxsLCBlLCBudWxsXSA6IEwuZXhlYyhlKSkgfHwgIWlbMV0gJiYgdCkgcmV0dXJuICF0IHx8IHQuanF1ZXJ5ID8gKHQgfHwgbikuZmluZChlKSA6IHRoaXMuY29uc3RydWN0b3IodCkuZmluZChlKTsgaWYgKGlbMV0pIHsgaWYgKHQgPSB0IGluc3RhbmNlb2YgdyA/IHRbMF0gOiB0LCB3Lm1lcmdlKHRoaXMsIHcucGFyc2VIVE1MKGlbMV0sIHQgJiYgdC5ub2RlVHlwZSA/IHQub3duZXJEb2N1bWVudCB8fCB0IDogciwgITApKSwgQS50ZXN0KGlbMV0pICYmIHcuaXNQbGFpbk9iamVjdCh0KSlcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpIGluIHQpIGcodGhpc1tpXSkgPyB0aGlzW2ldKHRbaV0pIDogdGhpcy5hdHRyKGksIHRbaV0pOyByZXR1cm4gdGhpcyB9IHJldHVybiAobyA9IHIuZ2V0RWxlbWVudEJ5SWQoaVsyXSkpICYmICh0aGlzWzBdID0gbywgdGhpcy5sZW5ndGggPSAxKSwgdGhpcyB9IHJldHVybiBlLm5vZGVUeXBlID8gKHRoaXNbMF0gPSBlLCB0aGlzLmxlbmd0aCA9IDEsIHRoaXMpIDogZyhlKSA/IHZvaWQgMCAhPT0gbi5yZWFkeSA/IG4ucmVhZHkoZSkgOiBlKHcpIDogdy5tYWtlQXJyYXkoZSwgdGhpcykgfSkucHJvdG90eXBlID0gdy5mbiwgcSA9IHcocik7IHZhciBIID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG4gICAgICAgIE8gPSB7IGNoaWxkcmVuOiAhMCwgY29udGVudHM6ICEwLCBuZXh0OiAhMCwgcHJldjogITAgfTtcbiAgICB3LmZuLmV4dGVuZCh7IGhhczogZnVuY3Rpb24oZSkgeyB2YXIgdCA9IHcoZSwgdGhpcyksXG4gICAgICAgICAgICAgICAgbiA9IHQubGVuZ3RoOyByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24oKSB7IGZvciAodmFyIGUgPSAwOyBlIDwgbjsgZSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAody5jb250YWlucyh0aGlzLCB0W2VdKSkgcmV0dXJuICEwIH0pIH0sIGNsb3Nlc3Q6IGZ1bmN0aW9uKGUsIHQpIHsgdmFyIG4sIHIgPSAwLFxuICAgICAgICAgICAgICAgIGkgPSB0aGlzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBvID0gW10sXG4gICAgICAgICAgICAgICAgYSA9IFwic3RyaW5nXCIgIT0gdHlwZW9mIGUgJiYgdyhlKTsgaWYgKCFELnRlc3QoZSkpXG4gICAgICAgICAgICAgICAgZm9yICg7IHIgPCBpOyByKyspXG4gICAgICAgICAgICAgICAgICAgIGZvciAobiA9IHRoaXNbcl07IG4gJiYgbiAhPT0gdDsgbiA9IG4ucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuLm5vZGVUeXBlIDwgMTEgJiYgKGEgPyBhLmluZGV4KG4pID4gLTEgOiAxID09PSBuLm5vZGVUeXBlICYmIHcuZmluZC5tYXRjaGVzU2VsZWN0b3IobiwgZSkpKSB7IG8ucHVzaChuKTsgYnJlYWsgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKG8ubGVuZ3RoID4gMSA/IHcudW5pcXVlU29ydChvKSA6IG8pIH0sIGluZGV4OiBmdW5jdGlvbihlKSB7IHJldHVybiBlID8gXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSA/IHUuY2FsbCh3KGUpLCB0aGlzWzBdKSA6IHUuY2FsbCh0aGlzLCBlLmpxdWVyeSA/IGVbMF0gOiBlKSA6IHRoaXNbMF0gJiYgdGhpc1swXS5wYXJlbnROb2RlID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMSB9LCBhZGQ6IGZ1bmN0aW9uKGUsIHQpIHsgcmV0dXJuIHRoaXMucHVzaFN0YWNrKHcudW5pcXVlU29ydCh3Lm1lcmdlKHRoaXMuZ2V0KCksIHcoZSwgdCkpKSkgfSwgYWRkQmFjazogZnVuY3Rpb24oZSkgeyByZXR1cm4gdGhpcy5hZGQobnVsbCA9PSBlID8gdGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlcihlKSkgfSB9KTtcblxuICAgIGZ1bmN0aW9uIFAoZSwgdCkgeyB3aGlsZSAoKGUgPSBlW3RdKSAmJiAxICE9PSBlLm5vZGVUeXBlKTsgcmV0dXJuIGUgfSB3LmVhY2goeyBwYXJlbnQ6IGZ1bmN0aW9uKGUpIHsgdmFyIHQgPSBlLnBhcmVudE5vZGU7IHJldHVybiB0ICYmIDExICE9PSB0Lm5vZGVUeXBlID8gdCA6IG51bGwgfSwgcGFyZW50czogZnVuY3Rpb24oZSkgeyByZXR1cm4gayhlLCBcInBhcmVudE5vZGVcIikgfSwgcGFyZW50c1VudGlsOiBmdW5jdGlvbihlLCB0LCBuKSB7IHJldHVybiBrKGUsIFwicGFyZW50Tm9kZVwiLCBuKSB9LCBuZXh0OiBmdW5jdGlvbihlKSB7IHJldHVybiBQKGUsIFwibmV4dFNpYmxpbmdcIikgfSwgcHJldjogZnVuY3Rpb24oZSkgeyByZXR1cm4gUChlLCBcInByZXZpb3VzU2libGluZ1wiKSB9LCBuZXh0QWxsOiBmdW5jdGlvbihlKSB7IHJldHVybiBrKGUsIFwibmV4dFNpYmxpbmdcIikgfSwgcHJldkFsbDogZnVuY3Rpb24oZSkgeyByZXR1cm4gayhlLCBcInByZXZpb3VzU2libGluZ1wiKSB9LCBuZXh0VW50aWw6IGZ1bmN0aW9uKGUsIHQsIG4pIHsgcmV0dXJuIGsoZSwgXCJuZXh0U2libGluZ1wiLCBuKSB9LCBwcmV2VW50aWw6IGZ1bmN0aW9uKGUsIHQsIG4pIHsgcmV0dXJuIGsoZSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgbikgfSwgc2libGluZ3M6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIFMoKGUucGFyZW50Tm9kZSB8fCB7fSkuZmlyc3RDaGlsZCwgZSkgfSwgY2hpbGRyZW46IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIFMoZS5maXJzdENoaWxkKSB9LCBjb250ZW50czogZnVuY3Rpb24oZSkgeyByZXR1cm4gTihlLCBcImlmcmFtZVwiKSA/IGUuY29udGVudERvY3VtZW50IDogKE4oZSwgXCJ0ZW1wbGF0ZVwiKSAmJiAoZSA9IGUuY29udGVudCB8fCBlKSwgdy5tZXJnZShbXSwgZS5jaGlsZE5vZGVzKSkgfSB9LCBmdW5jdGlvbihlLCB0KSB7IHcuZm5bZV0gPSBmdW5jdGlvbihuLCByKSB7IHZhciBpID0gdy5tYXAodGhpcywgdCwgbik7IHJldHVybiBcIlVudGlsXCIgIT09IGUuc2xpY2UoLTUpICYmIChyID0gbiksIHIgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgciAmJiAoaSA9IHcuZmlsdGVyKHIsIGkpKSwgdGhpcy5sZW5ndGggPiAxICYmIChPW2VdIHx8IHcudW5pcXVlU29ydChpKSwgSC50ZXN0KGUpICYmIGkucmV2ZXJzZSgpKSwgdGhpcy5wdXNoU3RhY2soaSkgfSB9KTsgdmFyIE0gPSAvW15cXHgyMFxcdFxcclxcblxcZl0rL2c7XG5cbiAgICBmdW5jdGlvbiBSKGUpIHsgdmFyIHQgPSB7fTsgcmV0dXJuIHcuZWFjaChlLm1hdGNoKE0pIHx8IFtdLCBmdW5jdGlvbihlLCBuKSB7IHRbbl0gPSAhMCB9KSwgdCB9IHcuQ2FsbGJhY2tzID0gZnVuY3Rpb24oZSkgeyBlID0gXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSA/IFIoZSkgOiB3LmV4dGVuZCh7fSwgZSk7IHZhciB0LCBuLCByLCBpLCBvID0gW10sXG4gICAgICAgICAgICBhID0gW10sXG4gICAgICAgICAgICBzID0gLTEsXG4gICAgICAgICAgICB1ID0gZnVuY3Rpb24oKSB7IGZvciAoaSA9IGkgfHwgZS5vbmNlLCByID0gdCA9ICEwOyBhLmxlbmd0aDsgcyA9IC0xKSB7IG4gPSBhLnNoaWZ0KCk7IHdoaWxlICgrK3MgPCBvLmxlbmd0aCkgITEgPT09IG9bc10uYXBwbHkoblswXSwgblsxXSkgJiYgZS5zdG9wT25GYWxzZSAmJiAocyA9IG8ubGVuZ3RoLCBuID0gITEpIH0gZS5tZW1vcnkgfHwgKG4gPSAhMSksIHQgPSAhMSwgaSAmJiAobyA9IG4gPyBbXSA6IFwiXCIpIH0sXG4gICAgICAgICAgICBsID0geyBhZGQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbyAmJiAobiAmJiAhdCAmJiAocyA9IG8ubGVuZ3RoIC0gMSwgYS5wdXNoKG4pKSwgZnVuY3Rpb24gdChuKSB7IHcuZWFjaChuLCBmdW5jdGlvbihuLCByKSB7IGcocikgPyBlLnVuaXF1ZSAmJiBsLmhhcyhyKSB8fCBvLnB1c2gocikgOiByICYmIHIubGVuZ3RoICYmIFwic3RyaW5nXCIgIT09IHgocikgJiYgdChyKSB9KSB9KGFyZ3VtZW50cyksIG4gJiYgIXQgJiYgdSgpKSwgdGhpcyB9LCByZW1vdmU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdy5lYWNoKGFyZ3VtZW50cywgZnVuY3Rpb24oZSwgdCkgeyB2YXIgbjsgd2hpbGUgKChuID0gdy5pbkFycmF5KHQsIG8sIG4pKSA+IC0xKSBvLnNwbGljZShuLCAxKSwgbiA8PSBzICYmIHMtLSB9KSwgdGhpcyB9LCBoYXM6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGUgPyB3LmluQXJyYXkoZSwgbykgPiAtMSA6IG8ubGVuZ3RoID4gMCB9LCBlbXB0eTogZnVuY3Rpb24oKSB7IHJldHVybiBvICYmIChvID0gW10pLCB0aGlzIH0sIGRpc2FibGU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gaSA9IGEgPSBbXSwgbyA9IG4gPSBcIlwiLCB0aGlzIH0sIGRpc2FibGVkOiBmdW5jdGlvbigpIHsgcmV0dXJuICFvIH0sIGxvY2s6IGZ1bmN0aW9uKCkgeyByZXR1cm4gaSA9IGEgPSBbXSwgbiB8fCB0IHx8IChvID0gbiA9IFwiXCIpLCB0aGlzIH0sIGxvY2tlZDogZnVuY3Rpb24oKSB7IHJldHVybiAhIWkgfSwgZmlyZVdpdGg6IGZ1bmN0aW9uKGUsIG4pIHsgcmV0dXJuIGkgfHwgKG4gPSBbZSwgKG4gPSBuIHx8IFtdKS5zbGljZSA/IG4uc2xpY2UoKSA6IG5dLCBhLnB1c2gobiksIHQgfHwgdSgpKSwgdGhpcyB9LCBmaXJlOiBmdW5jdGlvbigpIHsgcmV0dXJuIGwuZmlyZVdpdGgodGhpcywgYXJndW1lbnRzKSwgdGhpcyB9LCBmaXJlZDogZnVuY3Rpb24oKSB7IHJldHVybiAhIXIgfSB9OyByZXR1cm4gbCB9O1xuXG4gICAgZnVuY3Rpb24gSShlKSB7IHJldHVybiBlIH1cblxuICAgIGZ1bmN0aW9uIFcoZSkgeyB0aHJvdyBlIH1cblxuICAgIGZ1bmN0aW9uICQoZSwgdCwgbiwgcikgeyB2YXIgaTsgdHJ5IHsgZSAmJiBnKGkgPSBlLnByb21pc2UpID8gaS5jYWxsKGUpLmRvbmUodCkuZmFpbChuKSA6IGUgJiYgZyhpID0gZS50aGVuKSA/IGkuY2FsbChlLCB0LCBuKSA6IHQuYXBwbHkodm9pZCAwLCBbZV0uc2xpY2UocikpIH0gY2F0Y2ggKGUpIHsgbi5hcHBseSh2b2lkIDAsIFtlXSkgfSB9IHcuZXh0ZW5kKHsgRGVmZXJyZWQ6IGZ1bmN0aW9uKHQpIHsgdmFyIG4gPSBbXG4gICAgICAgICAgICAgICAgICAgIFtcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIHcuQ2FsbGJhY2tzKFwibWVtb3J5XCIpLCB3LkNhbGxiYWNrcyhcIm1lbW9yeVwiKSwgMl0sXG4gICAgICAgICAgICAgICAgICAgIFtcInJlc29sdmVcIiwgXCJkb25lXCIsIHcuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIHcuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIDAsIFwicmVzb2x2ZWRcIl0sXG4gICAgICAgICAgICAgICAgICAgIFtcInJlamVjdFwiLCBcImZhaWxcIiwgdy5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSwgdy5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSwgMSwgXCJyZWplY3RlZFwiXVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgciA9IFwicGVuZGluZ1wiLFxuICAgICAgICAgICAgICAgIGkgPSB7IHN0YXRlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHIgfSwgYWx3YXlzOiBmdW5jdGlvbigpIHsgcmV0dXJuIG8uZG9uZShhcmd1bWVudHMpLmZhaWwoYXJndW1lbnRzKSwgdGhpcyB9LCBcImNhdGNoXCI6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGkudGhlbihudWxsLCBlKSB9LCBwaXBlOiBmdW5jdGlvbigpIHsgdmFyIGUgPSBhcmd1bWVudHM7IHJldHVybiB3LkRlZmVycmVkKGZ1bmN0aW9uKHQpIHsgdy5lYWNoKG4sIGZ1bmN0aW9uKG4sIHIpIHsgdmFyIGkgPSBnKGVbcls0XV0pICYmIGVbcls0XV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9bclsxXV0oZnVuY3Rpb24oKSB7IHZhciBlID0gaSAmJiBpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlICYmIGcoZS5wcm9taXNlKSA/IGUucHJvbWlzZSgpLnByb2dyZXNzKHQubm90aWZ5KS5kb25lKHQucmVzb2x2ZSkuZmFpbCh0LnJlamVjdCkgOiB0W3JbMF0gKyBcIldpdGhcIl0odGhpcywgaSA/IFtlXSA6IGFyZ3VtZW50cykgfSkgfSksIGUgPSBudWxsIH0pLnByb21pc2UoKSB9LCB0aGVuOiBmdW5jdGlvbih0LCByLCBpKSB7IHZhciBvID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gYSh0LCBuLCByLCBpKSB7IHJldHVybiBmdW5jdGlvbigpIHsgdmFyIHMgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdSA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBmdW5jdGlvbigpIHsgdmFyIGUsIGw7IGlmICghKHQgPCBvKSkgeyBpZiAoKGUgPSByLmFwcGx5KHMsIHUpKSA9PT0gbi5wcm9taXNlKCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGVuYWJsZSBzZWxmLXJlc29sdXRpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBlICYmIChcIm9iamVjdFwiID09IHR5cGVvZiBlIHx8IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSkgJiYgZS50aGVuLCBnKGwpID8gaSA/IGwuY2FsbChlLCBhKG8sIG4sIEksIGkpLCBhKG8sIG4sIFcsIGkpKSA6IChvKyssIGwuY2FsbChlLCBhKG8sIG4sIEksIGkpLCBhKG8sIG4sIFcsIGkpLCBhKG8sIG4sIEksIG4ubm90aWZ5V2l0aCkpKSA6IChyICE9PSBJICYmIChzID0gdm9pZCAwLCB1ID0gW2VdKSwgKGkgfHwgbi5yZXNvbHZlV2l0aCkocywgdSkpIH0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBpID8gbCA6IGZ1bmN0aW9uKCkgeyB0cnkgeyBsKCkgfSBjYXRjaCAoZSkgeyB3LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgJiYgdy5EZWZlcnJlZC5leGNlcHRpb25Ib29rKGUsIGMuc3RhY2tUcmFjZSksIHQgKyAxID49IG8gJiYgKHIgIT09IFcgJiYgKHMgPSB2b2lkIDAsIHUgPSBbZV0pLCBuLnJlamVjdFdpdGgocywgdSkpIH0gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA/IGMoKSA6ICh3LkRlZmVycmVkLmdldFN0YWNrSG9vayAmJiAoYy5zdGFja1RyYWNlID0gdy5EZWZlcnJlZC5nZXRTdGFja0hvb2soKSksIGUuc2V0VGltZW91dChjKSkgfSB9IHJldHVybiB3LkRlZmVycmVkKGZ1bmN0aW9uKGUpIHsgblswXVszXS5hZGQoYSgwLCBlLCBnKGkpID8gaSA6IEksIGUubm90aWZ5V2l0aCkpLCBuWzFdWzNdLmFkZChhKDAsIGUsIGcodCkgPyB0IDogSSkpLCBuWzJdWzNdLmFkZChhKDAsIGUsIGcocikgPyByIDogVykpIH0pLnByb21pc2UoKSB9LCBwcm9taXNlOiBmdW5jdGlvbihlKSB7IHJldHVybiBudWxsICE9IGUgPyB3LmV4dGVuZChlLCBpKSA6IGkgfSB9LFxuICAgICAgICAgICAgICAgIG8gPSB7fTsgcmV0dXJuIHcuZWFjaChuLCBmdW5jdGlvbihlLCB0KSB7IHZhciBhID0gdFsyXSxcbiAgICAgICAgICAgICAgICAgICAgcyA9IHRbNV07XG4gICAgICAgICAgICAgICAgaVt0WzFdXSA9IGEuYWRkLCBzICYmIGEuYWRkKGZ1bmN0aW9uKCkgeyByID0gcyB9LCBuWzMgLSBlXVsyXS5kaXNhYmxlLCBuWzMgLSBlXVszXS5kaXNhYmxlLCBuWzBdWzJdLmxvY2ssIG5bMF1bM10ubG9jayksIGEuYWRkKHRbM10uZmlyZSksIG9bdFswXV0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIG9bdFswXSArIFwiV2l0aFwiXSh0aGlzID09PSBvID8gdm9pZCAwIDogdGhpcywgYXJndW1lbnRzKSwgdGhpcyB9LCBvW3RbMF0gKyBcIldpdGhcIl0gPSBhLmZpcmVXaXRoIH0pLCBpLnByb21pc2UobyksIHQgJiYgdC5jYWxsKG8sIG8pLCBvIH0sIHdoZW46IGZ1bmN0aW9uKGUpIHsgdmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG4gPSB0LFxuICAgICAgICAgICAgICAgIHIgPSBBcnJheShuKSxcbiAgICAgICAgICAgICAgICBpID0gby5jYWxsKGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgYSA9IHcuRGVmZXJyZWQoKSxcbiAgICAgICAgICAgICAgICBzID0gZnVuY3Rpb24oZSkgeyByZXR1cm4gZnVuY3Rpb24obikgeyByW2VdID0gdGhpcywgaVtlXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gby5jYWxsKGFyZ3VtZW50cykgOiBuLCAtLXQgfHwgYS5yZXNvbHZlV2l0aChyLCBpKSB9IH07IGlmICh0IDw9IDEgJiYgKCQoZSwgYS5kb25lKHMobikpLnJlc29sdmUsIGEucmVqZWN0LCAhdCksIFwicGVuZGluZ1wiID09PSBhLnN0YXRlKCkgfHwgZyhpW25dICYmIGlbbl0udGhlbikpKSByZXR1cm4gYS50aGVuKCk7IHdoaWxlIChuLS0pICQoaVtuXSwgcyhuKSwgYS5yZWplY3QpOyByZXR1cm4gYS5wcm9taXNlKCkgfSB9KTsgdmFyIEIgPSAvXihFdmFsfEludGVybmFsfFJhbmdlfFJlZmVyZW5jZXxTeW50YXh8VHlwZXxVUkkpRXJyb3IkLztcbiAgICB3LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgPSBmdW5jdGlvbih0LCBuKSB7IGUuY29uc29sZSAmJiBlLmNvbnNvbGUud2FybiAmJiB0ICYmIEIudGVzdCh0Lm5hbWUpICYmIGUuY29uc29sZS53YXJuKFwialF1ZXJ5LkRlZmVycmVkIGV4Y2VwdGlvbjogXCIgKyB0Lm1lc3NhZ2UsIHQuc3RhY2ssIG4pIH0sIHcucmVhZHlFeGNlcHRpb24gPSBmdW5jdGlvbih0KSB7IGUuc2V0VGltZW91dChmdW5jdGlvbigpIHsgdGhyb3cgdCB9KSB9OyB2YXIgRiA9IHcuRGVmZXJyZWQoKTtcbiAgICB3LmZuLnJlYWR5ID0gZnVuY3Rpb24oZSkgeyByZXR1cm4gRi50aGVuKGUpW1wiY2F0Y2hcIl0oZnVuY3Rpb24oZSkgeyB3LnJlYWR5RXhjZXB0aW9uKGUpIH0pLCB0aGlzIH0sIHcuZXh0ZW5kKHsgaXNSZWFkeTogITEsIHJlYWR5V2FpdDogMSwgcmVhZHk6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICghMCA9PT0gZSA/IC0tdy5yZWFkeVdhaXQgOiB3LmlzUmVhZHkpIHx8ICh3LmlzUmVhZHkgPSAhMCwgITAgIT09IGUgJiYgLS13LnJlYWR5V2FpdCA+IDAgfHwgRi5yZXNvbHZlV2l0aChyLCBbd10pKSB9IH0pLCB3LnJlYWR5LnRoZW4gPSBGLnRoZW47XG5cbiAgICBmdW5jdGlvbiBfKCkgeyByLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIF8pLCBlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIF8pLCB3LnJlYWR5KCkgfSBcImNvbXBsZXRlXCIgPT09IHIucmVhZHlTdGF0ZSB8fCBcImxvYWRpbmdcIiAhPT0gci5yZWFkeVN0YXRlICYmICFyLmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCA/IGUuc2V0VGltZW91dCh3LnJlYWR5KSA6IChyLmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIF8pLCBlLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIF8pKTsgdmFyIHogPSBmdW5jdGlvbihlLCB0LCBuLCByLCBpLCBvLCBhKSB7IHZhciBzID0gMCxcbiAgICAgICAgICAgICAgICB1ID0gZS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbCA9IG51bGwgPT0gbjsgaWYgKFwib2JqZWN0XCIgPT09IHgobikpIHsgaSA9ICEwOyBmb3IgKHMgaW4gbikgeihlLCB0LCBzLCBuW3NdLCAhMCwgbywgYSkgfSBlbHNlIGlmICh2b2lkIDAgIT09IHIgJiYgKGkgPSAhMCwgZyhyKSB8fCAoYSA9ICEwKSwgbCAmJiAoYSA/ICh0LmNhbGwoZSwgciksIHQgPSBudWxsKSA6IChsID0gdCwgdCA9IGZ1bmN0aW9uKGUsIHQsIG4pIHsgcmV0dXJuIGwuY2FsbCh3KGUpLCBuKSB9KSksIHQpKVxuICAgICAgICAgICAgICAgIGZvciAoOyBzIDwgdTsgcysrKSB0KGVbc10sIG4sIGEgPyByIDogci5jYWxsKGVbc10sIHMsIHQoZVtzXSwgbikpKTsgcmV0dXJuIGkgPyBlIDogbCA/IHQuY2FsbChlKSA6IHUgPyB0KGVbMF0sIG4pIDogbyB9LFxuICAgICAgICBYID0gL14tbXMtLyxcbiAgICAgICAgVSA9IC8tKFthLXpdKS9nO1xuXG4gICAgZnVuY3Rpb24gVihlLCB0KSB7IHJldHVybiB0LnRvVXBwZXJDYXNlKCkgfVxuXG4gICAgZnVuY3Rpb24gRyhlKSB7IHJldHVybiBlLnJlcGxhY2UoWCwgXCJtcy1cIikucmVwbGFjZShVLCBWKSB9IHZhciBZID0gZnVuY3Rpb24oZSkgeyByZXR1cm4gMSA9PT0gZS5ub2RlVHlwZSB8fCA5ID09PSBlLm5vZGVUeXBlIHx8ICErZS5ub2RlVHlwZSB9O1xuXG4gICAgZnVuY3Rpb24gUSgpIHsgdGhpcy5leHBhbmRvID0gdy5leHBhbmRvICsgUS51aWQrKyB9IFEudWlkID0gMSwgUS5wcm90b3R5cGUgPSB7IGNhY2hlOiBmdW5jdGlvbihlKSB7IHZhciB0ID0gZVt0aGlzLmV4cGFuZG9dOyByZXR1cm4gdCB8fCAodCA9IHt9LCBZKGUpICYmIChlLm5vZGVUeXBlID8gZVt0aGlzLmV4cGFuZG9dID0gdCA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCB0aGlzLmV4cGFuZG8sIHsgdmFsdWU6IHQsIGNvbmZpZ3VyYWJsZTogITAgfSkpKSwgdCB9LCBzZXQ6IGZ1bmN0aW9uKGUsIHQsIG4pIHsgdmFyIHIsIGkgPSB0aGlzLmNhY2hlKGUpOyBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCkgaVtHKHQpXSA9IG47XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZm9yIChyIGluIHQpIGlbRyhyKV0gPSB0W3JdOyByZXR1cm4gaSB9LCBnZXQ6IGZ1bmN0aW9uKGUsIHQpIHsgcmV0dXJuIHZvaWQgMCA9PT0gdCA/IHRoaXMuY2FjaGUoZSkgOiBlW3RoaXMuZXhwYW5kb10gJiYgZVt0aGlzLmV4cGFuZG9dW0codCldIH0sIGFjY2VzczogZnVuY3Rpb24oZSwgdCwgbikgeyByZXR1cm4gdm9pZCAwID09PSB0IHx8IHQgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCAmJiB2b2lkIDAgPT09IG4gPyB0aGlzLmdldChlLCB0KSA6ICh0aGlzLnNldChlLCB0LCBuKSwgdm9pZCAwICE9PSBuID8gbiA6IHQpIH0sIHJlbW92ZTogZnVuY3Rpb24oZSwgdCkgeyB2YXIgbiwgciA9IGVbdGhpcy5leHBhbmRvXTsgaWYgKHZvaWQgMCAhPT0gcikgeyBpZiAodm9pZCAwICE9PSB0KSB7IG4gPSAodCA9IEFycmF5LmlzQXJyYXkodCkgPyB0Lm1hcChHKSA6ICh0ID0gRyh0KSkgaW4gciA/IFt0XSA6IHQubWF0Y2goTSkgfHwgW10pLmxlbmd0aDsgd2hpbGUgKG4tLSkgZGVsZXRlIHJbdFtuXV0gfSh2b2lkIDAgPT09IHQgfHwgdy5pc0VtcHR5T2JqZWN0KHIpKSAmJiAoZS5ub2RlVHlwZSA/IGVbdGhpcy5leHBhbmRvXSA9IHZvaWQgMCA6IGRlbGV0ZSBlW3RoaXMuZXhwYW5kb10pIH0gfSwgaGFzRGF0YTogZnVuY3Rpb24oZSkgeyB2YXIgdCA9IGVbdGhpcy5leHBhbmRvXTsgcmV0dXJuIHZvaWQgMCAhPT0gdCAmJiAhdy5pc0VtcHR5T2JqZWN0KHQpIH0gfTsgdmFyIEogPSBuZXcgUSxcbiAgICAgICAgSyA9IG5ldyBRLFxuICAgICAgICBaID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuICAgICAgICBlZSA9IC9bQS1aXS9nO1xuXG4gICAgZnVuY3Rpb24gdGUoZSkgeyByZXR1cm4gXCJ0cnVlXCIgPT09IGUgfHwgXCJmYWxzZVwiICE9PSBlICYmIChcIm51bGxcIiA9PT0gZSA/IG51bGwgOiBlID09PSArZSArIFwiXCIgPyArZSA6IFoudGVzdChlKSA/IEpTT04ucGFyc2UoZSkgOiBlKSB9XG5cbiAgICBmdW5jdGlvbiBuZShlLCB0LCBuKSB7IHZhciByOyBpZiAodm9pZCAwID09PSBuICYmIDEgPT09IGUubm9kZVR5cGUpXG4gICAgICAgICAgICBpZiAociA9IFwiZGF0YS1cIiArIHQucmVwbGFjZShlZSwgXCItJCZcIikudG9Mb3dlckNhc2UoKSwgXCJzdHJpbmdcIiA9PSB0eXBlb2YobiA9IGUuZ2V0QXR0cmlidXRlKHIpKSkgeyB0cnkgeyBuID0gdGUobikgfSBjYXRjaCAoZSkge30gSy5zZXQoZSwgdCwgbikgfVxuICAgICAgICBlbHNlIG4gPSB2b2lkIDA7IHJldHVybiBuIH0gdy5leHRlbmQoeyBoYXNEYXRhOiBmdW5jdGlvbihlKSB7IHJldHVybiBLLmhhc0RhdGEoZSkgfHwgSi5oYXNEYXRhKGUpIH0sIGRhdGE6IGZ1bmN0aW9uKGUsIHQsIG4pIHsgcmV0dXJuIEsuYWNjZXNzKGUsIHQsIG4pIH0sIHJlbW92ZURhdGE6IGZ1bmN0aW9uKGUsIHQpIHsgSy5yZW1vdmUoZSwgdCkgfSwgX2RhdGE6IGZ1bmN0aW9uKGUsIHQsIG4pIHsgcmV0dXJuIEouYWNjZXNzKGUsIHQsIG4pIH0sIF9yZW1vdmVEYXRhOiBmdW5jdGlvbihlLCB0KSB7IEoucmVtb3ZlKGUsIHQpIH0gfSksIHcuZm4uZXh0ZW5kKHsgZGF0YTogZnVuY3Rpb24oZSwgdCkgeyB2YXIgbiwgciwgaSwgbyA9IHRoaXNbMF0sXG4gICAgICAgICAgICAgICAgYSA9IG8gJiYgby5hdHRyaWJ1dGVzOyBpZiAodm9pZCAwID09PSBlKSB7IGlmICh0aGlzLmxlbmd0aCAmJiAoaSA9IEsuZ2V0KG8pLCAxID09PSBvLm5vZGVUeXBlICYmICFKLmdldChvLCBcImhhc0RhdGFBdHRyc1wiKSkpIHsgbiA9IGEubGVuZ3RoOyB3aGlsZSAobi0tKSBhW25dICYmIDAgPT09IChyID0gYVtuXS5uYW1lKS5pbmRleE9mKFwiZGF0YS1cIikgJiYgKHIgPSBHKHIuc2xpY2UoNSkpLCBuZShvLCByLCBpW3JdKSk7XG4gICAgICAgICAgICAgICAgICAgIEouc2V0KG8sIFwiaGFzRGF0YUF0dHJzXCIsICEwKSB9IHJldHVybiBpIH0gcmV0dXJuIFwib2JqZWN0XCIgPT0gdHlwZW9mIGUgPyB0aGlzLmVhY2goZnVuY3Rpb24oKSB7IEsuc2V0KHRoaXMsIGUpIH0pIDogeih0aGlzLCBmdW5jdGlvbih0KSB7IHZhciBuOyBpZiAobyAmJiB2b2lkIDAgPT09IHQpIHsgaWYgKHZvaWQgMCAhPT0gKG4gPSBLLmdldChvLCBlKSkpIHJldHVybiBuOyBpZiAodm9pZCAwICE9PSAobiA9IG5lKG8sIGUpKSkgcmV0dXJuIG4gfSBlbHNlIHRoaXMuZWFjaChmdW5jdGlvbigpIHsgSy5zZXQodGhpcywgZSwgdCkgfSkgfSwgbnVsbCwgdCwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsICEwKSB9LCByZW1vdmVEYXRhOiBmdW5jdGlvbihlKSB7IHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7IEsucmVtb3ZlKHRoaXMsIGUpIH0pIH0gfSksIHcuZXh0ZW5kKHsgcXVldWU6IGZ1bmN0aW9uKGUsIHQsIG4pIHsgdmFyIHI7IGlmIChlKSByZXR1cm4gdCA9ICh0IHx8IFwiZnhcIikgKyBcInF1ZXVlXCIsIHIgPSBKLmdldChlLCB0KSwgbiAmJiAoIXIgfHwgQXJyYXkuaXNBcnJheShuKSA/IHIgPSBKLmFjY2VzcyhlLCB0LCB3Lm1ha2VBcnJheShuKSkgOiByLnB1c2gobikpLCByIHx8IFtdIH0sIGRlcXVldWU6IGZ1bmN0aW9uKGUsIHQpIHsgdCA9IHQgfHwgXCJmeFwiOyB2YXIgbiA9IHcucXVldWUoZSwgdCksXG4gICAgICAgICAgICAgICAgciA9IG4ubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGkgPSBuLnNoaWZ0KCksXG4gICAgICAgICAgICAgICAgbyA9IHcuX3F1ZXVlSG9va3MoZSwgdCksXG4gICAgICAgICAgICAgICAgYSA9IGZ1bmN0aW9uKCkgeyB3LmRlcXVldWUoZSwgdCkgfTsgXCJpbnByb2dyZXNzXCIgPT09IGkgJiYgKGkgPSBuLnNoaWZ0KCksIHItLSksIGkgJiYgKFwiZnhcIiA9PT0gdCAmJiBuLnVuc2hpZnQoXCJpbnByb2dyZXNzXCIpLCBkZWxldGUgby5zdG9wLCBpLmNhbGwoZSwgYSwgbykpLCAhciAmJiBvICYmIG8uZW1wdHkuZmlyZSgpIH0sIF9xdWV1ZUhvb2tzOiBmdW5jdGlvbihlLCB0KSB7IHZhciBuID0gdCArIFwicXVldWVIb29rc1wiOyByZXR1cm4gSi5nZXQoZSwgbikgfHwgSi5hY2Nlc3MoZSwgbiwgeyBlbXB0eTogdy5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKS5hZGQoZnVuY3Rpb24oKSB7IEoucmVtb3ZlKGUsIFt0ICsgXCJxdWV1ZVwiLCBuXSkgfSkgfSkgfSB9KSwgdy5mbi5leHRlbmQoeyBxdWV1ZTogZnVuY3Rpb24oZSwgdCkgeyB2YXIgbiA9IDI7IHJldHVybiBcInN0cmluZ1wiICE9IHR5cGVvZiBlICYmICh0ID0gZSwgZSA9IFwiZnhcIiwgbi0tKSwgYXJndW1lbnRzLmxlbmd0aCA8IG4gPyB3LnF1ZXVlKHRoaXNbMF0sIGUpIDogdm9pZCAwID09PSB0ID8gdGhpcyA6IHRoaXMuZWFjaChmdW5jdGlvbigpIHsgdmFyIG4gPSB3LnF1ZXVlKHRoaXMsIGUsIHQpO1xuICAgICAgICAgICAgICAgIHcuX3F1ZXVlSG9va3ModGhpcywgZSksIFwiZnhcIiA9PT0gZSAmJiBcImlucHJvZ3Jlc3NcIiAhPT0gblswXSAmJiB3LmRlcXVldWUodGhpcywgZSkgfSkgfSwgZGVxdWV1ZTogZnVuY3Rpb24oZSkgeyByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkgeyB3LmRlcXVldWUodGhpcywgZSkgfSkgfSwgY2xlYXJRdWV1ZTogZnVuY3Rpb24oZSkgeyByZXR1cm4gdGhpcy5xdWV1ZShlIHx8IFwiZnhcIiwgW10pIH0sIHByb21pc2U6IGZ1bmN0aW9uKGUsIHQpIHsgdmFyIG4sIHIgPSAxLFxuICAgICAgICAgICAgICAgIGkgPSB3LkRlZmVycmVkKCksXG4gICAgICAgICAgICAgICAgbyA9IHRoaXMsXG4gICAgICAgICAgICAgICAgYSA9IHRoaXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHMgPSBmdW5jdGlvbigpIHstLXIgfHwgaS5yZXNvbHZlV2l0aChvLCBbb10pIH07IFwic3RyaW5nXCIgIT0gdHlwZW9mIGUgJiYgKHQgPSBlLCBlID0gdm9pZCAwKSwgZSA9IGUgfHwgXCJmeFwiOyB3aGlsZSAoYS0tKShuID0gSi5nZXQob1thXSwgZSArIFwicXVldWVIb29rc1wiKSkgJiYgbi5lbXB0eSAmJiAocisrLCBuLmVtcHR5LmFkZChzKSk7IHJldHVybiBzKCksIGkucHJvbWlzZSh0KSB9IH0pOyB2YXIgcmUgPSAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLy5zb3VyY2UsXG4gICAgICAgIGllID0gbmV3IFJlZ0V4cChcIl4oPzooWystXSk9fCkoXCIgKyByZSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIpLFxuICAgICAgICBvZSA9IFtcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiXSxcbiAgICAgICAgYWUgPSBmdW5jdGlvbihlLCB0KSB7IHJldHVybiBcIm5vbmVcIiA9PT0gKGUgPSB0IHx8IGUpLnN0eWxlLmRpc3BsYXkgfHwgXCJcIiA9PT0gZS5zdHlsZS5kaXNwbGF5ICYmIHcuY29udGFpbnMoZS5vd25lckRvY3VtZW50LCBlKSAmJiBcIm5vbmVcIiA9PT0gdy5jc3MoZSwgXCJkaXNwbGF5XCIpIH0sXG4gICAgICAgIHNlID0gZnVuY3Rpb24oZSwgdCwgbiwgcikgeyB2YXIgaSwgbywgYSA9IHt9OyBmb3IgKG8gaW4gdCkgYVtvXSA9IGUuc3R5bGVbb10sIGUuc3R5bGVbb10gPSB0W29dO1xuICAgICAgICAgICAgaSA9IG4uYXBwbHkoZSwgciB8fCBbXSk7IGZvciAobyBpbiB0KSBlLnN0eWxlW29dID0gYVtvXTsgcmV0dXJuIGkgfTtcblxuICAgIGZ1bmN0aW9uIHVlKGUsIHQsIG4sIHIpIHsgdmFyIGksIG8sIGEgPSAyMCxcbiAgICAgICAgICAgIHMgPSByID8gZnVuY3Rpb24oKSB7IHJldHVybiByLmN1cigpIH0gOiBmdW5jdGlvbigpIHsgcmV0dXJuIHcuY3NzKGUsIHQsIFwiXCIpIH0sXG4gICAgICAgICAgICB1ID0gcygpLFxuICAgICAgICAgICAgbCA9IG4gJiYgblszXSB8fCAody5jc3NOdW1iZXJbdF0gPyBcIlwiIDogXCJweFwiKSxcbiAgICAgICAgICAgIGMgPSAody5jc3NOdW1iZXJbdF0gfHwgXCJweFwiICE9PSBsICYmICt1KSAmJiBpZS5leGVjKHcuY3NzKGUsIHQpKTsgaWYgKGMgJiYgY1szXSAhPT0gbCkgeyB1IC89IDIsIGwgPSBsIHx8IGNbM10sIGMgPSArdSB8fCAxOyB3aGlsZSAoYS0tKSB3LnN0eWxlKGUsIHQsIGMgKyBsKSwgKDEgLSBvKSAqICgxIC0gKG8gPSBzKCkgLyB1IHx8IC41KSkgPD0gMCAmJiAoYSA9IDApLCBjIC89IG87XG4gICAgICAgICAgICBjICo9IDIsIHcuc3R5bGUoZSwgdCwgYyArIGwpLCBuID0gbiB8fCBbXSB9IHJldHVybiBuICYmIChjID0gK2MgfHwgK3UgfHwgMCwgaSA9IG5bMV0gPyBjICsgKG5bMV0gKyAxKSAqIG5bMl0gOiArblsyXSwgciAmJiAoci51bml0ID0gbCwgci5zdGFydCA9IGMsIHIuZW5kID0gaSkpLCBpIH0gdmFyIGxlID0ge307XG5cbiAgICBmdW5jdGlvbiBjZShlKSB7IHZhciB0LCBuID0gZS5vd25lckRvY3VtZW50LFxuICAgICAgICAgICAgciA9IGUubm9kZU5hbWUsXG4gICAgICAgICAgICBpID0gbGVbcl07IHJldHVybiBpIHx8ICh0ID0gbi5ib2R5LmFwcGVuZENoaWxkKG4uY3JlYXRlRWxlbWVudChyKSksIGkgPSB3LmNzcyh0LCBcImRpc3BsYXlcIiksIHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0KSwgXCJub25lXCIgPT09IGkgJiYgKGkgPSBcImJsb2NrXCIpLCBsZVtyXSA9IGksIGkpIH1cblxuICAgIGZ1bmN0aW9uIGZlKGUsIHQpIHsgZm9yICh2YXIgbiwgciwgaSA9IFtdLCBvID0gMCwgYSA9IGUubGVuZ3RoOyBvIDwgYTsgbysrKShyID0gZVtvXSkuc3R5bGUgJiYgKG4gPSByLnN0eWxlLmRpc3BsYXksIHQgPyAoXCJub25lXCIgPT09IG4gJiYgKGlbb10gPSBKLmdldChyLCBcImRpc3BsYXlcIikgfHwgbnVsbCwgaVtvXSB8fCAoci5zdHlsZS5kaXNwbGF5ID0gXCJcIikpLCBcIlwiID09PSByLnN0eWxlLmRpc3BsYXkgJiYgYWUocikgJiYgKGlbb10gPSBjZShyKSkpIDogXCJub25lXCIgIT09IG4gJiYgKGlbb10gPSBcIm5vbmVcIiwgSi5zZXQociwgXCJkaXNwbGF5XCIsIG4pKSk7IGZvciAobyA9IDA7IG8gPCBhOyBvKyspIG51bGwgIT0gaVtvXSAmJiAoZVtvXS5zdHlsZS5kaXNwbGF5ID0gaVtvXSk7IHJldHVybiBlIH0gdy5mbi5leHRlbmQoeyBzaG93OiBmdW5jdGlvbigpIHsgcmV0dXJuIGZlKHRoaXMsICEwKSB9LCBoaWRlOiBmdW5jdGlvbigpIHsgcmV0dXJuIGZlKHRoaXMpIH0sIHRvZ2dsZTogZnVuY3Rpb24oZSkgeyByZXR1cm4gXCJib29sZWFuXCIgPT0gdHlwZW9mIGUgPyBlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKSA6IHRoaXMuZWFjaChmdW5jdGlvbigpIHsgYWUodGhpcykgPyB3KHRoaXMpLnNob3coKSA6IHcodGhpcykuaGlkZSgpIH0pIH0gfSk7IHZhciBwZSA9IC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pLFxuICAgICAgICBkZSA9IC88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKykvaSxcbiAgICAgICAgaGUgPSAvXiR8Xm1vZHVsZSR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pLFxuICAgICAgICBnZSA9IHsgb3B0aW9uOiBbMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCJdLCB0aGVhZDogWzEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCJdLCBjb2w6IFsyLCBcIjx0YWJsZT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiXSwgdHI6IFsyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiXSwgdGQ6IFszLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiXSwgX2RlZmF1bHQ6IFswLCBcIlwiLCBcIlwiXSB9O1xuICAgIGdlLm9wdGdyb3VwID0gZ2Uub3B0aW9uLCBnZS50Ym9keSA9IGdlLnRmb290ID0gZ2UuY29sZ3JvdXAgPSBnZS5jYXB0aW9uID0gZ2UudGhlYWQsIGdlLnRoID0gZ2UudGQ7XG5cbiAgICBmdW5jdGlvbiB5ZShlLCB0KSB7IHZhciBuOyByZXR1cm4gbiA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPyBlLmdldEVsZW1lbnRzQnlUYWdOYW1lKHQgfHwgXCIqXCIpIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgZS5xdWVyeVNlbGVjdG9yQWxsID8gZS5xdWVyeVNlbGVjdG9yQWxsKHQgfHwgXCIqXCIpIDogW10sIHZvaWQgMCA9PT0gdCB8fCB0ICYmIE4oZSwgdCkgPyB3Lm1lcmdlKFtlXSwgbikgOiBuIH1cblxuICAgIGZ1bmN0aW9uIHZlKGUsIHQpIHsgZm9yICh2YXIgbiA9IDAsIHIgPSBlLmxlbmd0aDsgbiA8IHI7IG4rKykgSi5zZXQoZVtuXSwgXCJnbG9iYWxFdmFsXCIsICF0IHx8IEouZ2V0KHRbbl0sIFwiZ2xvYmFsRXZhbFwiKSkgfSB2YXIgbWUgPSAvPHwmIz9cXHcrOy87XG5cbiAgICBmdW5jdGlvbiB4ZShlLCB0LCBuLCByLCBpKSB7IGZvciAodmFyIG8sIGEsIHMsIHUsIGwsIGMsIGYgPSB0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgcCA9IFtdLCBkID0gMCwgaCA9IGUubGVuZ3RoOyBkIDwgaDsgZCsrKVxuICAgICAgICAgICAgaWYgKChvID0gZVtkXSkgfHwgMCA9PT0gbylcbiAgICAgICAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0geChvKSkgdy5tZXJnZShwLCBvLm5vZGVUeXBlID8gW29dIDogbyk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWUudGVzdChvKSkgeyBhID0gYSB8fCBmLmFwcGVuZENoaWxkKHQuY3JlYXRlRWxlbWVudChcImRpdlwiKSksIHMgPSAoZGUuZXhlYyhvKSB8fCBbXCJcIiwgXCJcIl0pWzFdLnRvTG93ZXJDYXNlKCksIHUgPSBnZVtzXSB8fCBnZS5fZGVmYXVsdCwgYS5pbm5lckhUTUwgPSB1WzFdICsgdy5odG1sUHJlZmlsdGVyKG8pICsgdVsyXSwgYyA9IHVbMF07IHdoaWxlIChjLS0pIGEgPSBhLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIHcubWVyZ2UocCwgYS5jaGlsZE5vZGVzKSwgKGEgPSBmLmZpcnN0Q2hpbGQpLnRleHRDb250ZW50ID0gXCJcIiB9IGVsc2UgcC5wdXNoKHQuY3JlYXRlVGV4dE5vZGUobykpO1xuICAgICAgICBmLnRleHRDb250ZW50ID0gXCJcIiwgZCA9IDA7IHdoaWxlIChvID0gcFtkKytdKVxuICAgICAgICAgICAgaWYgKHIgJiYgdy5pbkFycmF5KG8sIHIpID4gLTEpIGkgJiYgaS5wdXNoKG8pO1xuICAgICAgICAgICAgZWxzZSBpZiAobCA9IHcuY29udGFpbnMoby5vd25lckRvY3VtZW50LCBvKSwgYSA9IHllKGYuYXBwZW5kQ2hpbGQobyksIFwic2NyaXB0XCIpLCBsICYmIHZlKGEpLCBuKSB7IGMgPSAwOyB3aGlsZSAobyA9IGFbYysrXSkgaGUudGVzdChvLnR5cGUgfHwgXCJcIikgJiYgbi5wdXNoKG8pIH0gcmV0dXJuIGYgfSEgZnVuY3Rpb24oKSB7IHZhciBlID0gci5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCkuYXBwZW5kQ2hpbGQoci5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKSxcbiAgICAgICAgICAgIHQgPSByLmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgdC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwicmFkaW9cIiksIHQuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiksIHQuc2V0QXR0cmlidXRlKFwibmFtZVwiLCBcInRcIiksIGUuYXBwZW5kQ2hpbGQodCksIGguY2hlY2tDbG9uZSA9IGUuY2xvbmVOb2RlKCEwKS5jbG9uZU5vZGUoITApLmxhc3RDaGlsZC5jaGVja2VkLCBlLmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiLCBoLm5vQ2xvbmVDaGVja2VkID0gISFlLmNsb25lTm9kZSghMCkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZSB9KCk7IHZhciBiZSA9IHIuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICB3ZSA9IC9ea2V5LyxcbiAgICAgICAgVGUgPSAvXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnV8ZHJhZ3xkcm9wKXxjbGljay8sXG4gICAgICAgIENlID0gL14oW14uXSopKD86XFwuKC4rKXwpLztcblxuICAgIGZ1bmN0aW9uIEVlKCkgeyByZXR1cm4gITAgfVxuXG4gICAgZnVuY3Rpb24ga2UoKSB7IHJldHVybiAhMSB9XG5cbiAgICBmdW5jdGlvbiBTZSgpIHsgdHJ5IHsgcmV0dXJuIHIuYWN0aXZlRWxlbWVudCB9IGNhdGNoIChlKSB7fSB9XG5cbiAgICBmdW5jdGlvbiBEZShlLCB0LCBuLCByLCBpLCBvKSB7IHZhciBhLCBzOyBpZiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgdCkgeyBcInN0cmluZ1wiICE9IHR5cGVvZiBuICYmIChyID0gciB8fCBuLCBuID0gdm9pZCAwKTsgZm9yIChzIGluIHQpIERlKGUsIHMsIG4sIHIsIHRbc10sIG8pOyByZXR1cm4gZSB9IGlmIChudWxsID09IHIgJiYgbnVsbCA9PSBpID8gKGkgPSBuLCByID0gbiA9IHZvaWQgMCkgOiBudWxsID09IGkgJiYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIG4gPyAoaSA9IHIsIHIgPSB2b2lkIDApIDogKGkgPSByLCByID0gbiwgbiA9IHZvaWQgMCkpLCAhMSA9PT0gaSkgaSA9IGtlO1xuICAgICAgICBlbHNlIGlmICghaSkgcmV0dXJuIGU7IHJldHVybiAxID09PSBvICYmIChhID0gaSwgKGkgPSBmdW5jdGlvbihlKSB7IHJldHVybiB3KCkub2ZmKGUpLCBhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfSkuZ3VpZCA9IGEuZ3VpZCB8fCAoYS5ndWlkID0gdy5ndWlkKyspKSwgZS5lYWNoKGZ1bmN0aW9uKCkgeyB3LmV2ZW50LmFkZCh0aGlzLCB0LCBpLCByLCBuKSB9KSB9IHcuZXZlbnQgPSB7IGdsb2JhbDoge30sIGFkZDogZnVuY3Rpb24oZSwgdCwgbiwgciwgaSkgeyB2YXIgbywgYSwgcywgdSwgbCwgYywgZiwgcCwgZCwgaCwgZywgeSA9IEouZ2V0KGUpOyBpZiAoeSkgeyBuLmhhbmRsZXIgJiYgKG4gPSAobyA9IG4pLmhhbmRsZXIsIGkgPSBvLnNlbGVjdG9yKSwgaSAmJiB3LmZpbmQubWF0Y2hlc1NlbGVjdG9yKGJlLCBpKSwgbi5ndWlkIHx8IChuLmd1aWQgPSB3Lmd1aWQrKyksICh1ID0geS5ldmVudHMpIHx8ICh1ID0geS5ldmVudHMgPSB7fSksIChhID0geS5oYW5kbGUpIHx8IChhID0geS5oYW5kbGUgPSBmdW5jdGlvbih0KSB7IHJldHVybiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB3ICYmIHcuZXZlbnQudHJpZ2dlcmVkICE9PSB0LnR5cGUgPyB3LmV2ZW50LmRpc3BhdGNoLmFwcGx5KGUsIGFyZ3VtZW50cykgOiB2b2lkIDAgfSksIGwgPSAodCA9ICh0IHx8IFwiXCIpLm1hdGNoKE0pIHx8IFtcIlwiXSkubGVuZ3RoOyB3aGlsZSAobC0tKSBkID0gZyA9IChzID0gQ2UuZXhlYyh0W2xdKSB8fCBbXSlbMV0sIGggPSAoc1syXSB8fCBcIlwiKS5zcGxpdChcIi5cIikuc29ydCgpLCBkICYmIChmID0gdy5ldmVudC5zcGVjaWFsW2RdIHx8IHt9LCBkID0gKGkgPyBmLmRlbGVnYXRlVHlwZSA6IGYuYmluZFR5cGUpIHx8IGQsIGYgPSB3LmV2ZW50LnNwZWNpYWxbZF0gfHwge30sIGMgPSB3LmV4dGVuZCh7IHR5cGU6IGQsIG9yaWdUeXBlOiBnLCBkYXRhOiByLCBoYW5kbGVyOiBuLCBndWlkOiBuLmd1aWQsIHNlbGVjdG9yOiBpLCBuZWVkc0NvbnRleHQ6IGkgJiYgdy5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KGkpLCBuYW1lc3BhY2U6IGguam9pbihcIi5cIikgfSwgbyksIChwID0gdVtkXSkgfHwgKChwID0gdVtkXSA9IFtdKS5kZWxlZ2F0ZUNvdW50ID0gMCwgZi5zZXR1cCAmJiAhMSAhPT0gZi5zZXR1cC5jYWxsKGUsIHIsIGgsIGEpIHx8IGUuYWRkRXZlbnRMaXN0ZW5lciAmJiBlLmFkZEV2ZW50TGlzdGVuZXIoZCwgYSkpLCBmLmFkZCAmJiAoZi5hZGQuY2FsbChlLCBjKSwgYy5oYW5kbGVyLmd1aWQgfHwgKGMuaGFuZGxlci5ndWlkID0gbi5ndWlkKSksIGkgPyBwLnNwbGljZShwLmRlbGVnYXRlQ291bnQrKywgMCwgYykgOiBwLnB1c2goYyksIHcuZXZlbnQuZ2xvYmFsW2RdID0gITApIH0gfSwgcmVtb3ZlOiBmdW5jdGlvbihlLCB0LCBuLCByLCBpKSB7IHZhciBvLCBhLCBzLCB1LCBsLCBjLCBmLCBwLCBkLCBoLCBnLCB5ID0gSi5oYXNEYXRhKGUpICYmIEouZ2V0KGUpOyBpZiAoeSAmJiAodSA9IHkuZXZlbnRzKSkgeyBsID0gKHQgPSAodCB8fCBcIlwiKS5tYXRjaChNKSB8fCBbXCJcIl0pLmxlbmd0aDsgd2hpbGUgKGwtLSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMgPSBDZS5leGVjKHRbbF0pIHx8IFtdLCBkID0gZyA9IHNbMV0sIGggPSAoc1syXSB8fCBcIlwiKS5zcGxpdChcIi5cIikuc29ydCgpLCBkKSB7IGYgPSB3LmV2ZW50LnNwZWNpYWxbZF0gfHwge30sIHAgPSB1W2QgPSAociA/IGYuZGVsZWdhdGVUeXBlIDogZi5iaW5kVHlwZSkgfHwgZF0gfHwgW10sIHMgPSBzWzJdICYmIG5ldyBSZWdFeHAoXCIoXnxcXFxcLilcIiArIGguam9pbihcIlxcXFwuKD86LipcXFxcLnwpXCIpICsgXCIoXFxcXC58JClcIiksIGEgPSBvID0gcC5sZW5ndGg7IHdoaWxlIChvLS0pIGMgPSBwW29dLCAhaSAmJiBnICE9PSBjLm9yaWdUeXBlIHx8IG4gJiYgbi5ndWlkICE9PSBjLmd1aWQgfHwgcyAmJiAhcy50ZXN0KGMubmFtZXNwYWNlKSB8fCByICYmIHIgIT09IGMuc2VsZWN0b3IgJiYgKFwiKipcIiAhPT0gciB8fCAhYy5zZWxlY3RvcikgfHwgKHAuc3BsaWNlKG8sIDEpLCBjLnNlbGVjdG9yICYmIHAuZGVsZWdhdGVDb3VudC0tLCBmLnJlbW92ZSAmJiBmLnJlbW92ZS5jYWxsKGUsIGMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgJiYgIXAubGVuZ3RoICYmIChmLnRlYXJkb3duICYmICExICE9PSBmLnRlYXJkb3duLmNhbGwoZSwgaCwgeS5oYW5kbGUpIHx8IHcucmVtb3ZlRXZlbnQoZSwgZCwgeS5oYW5kbGUpLCBkZWxldGUgdVtkXSkgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZm9yIChkIGluIHUpIHcuZXZlbnQucmVtb3ZlKGUsIGQgKyB0W2xdLCBuLCByLCAhMCk7XG4gICAgICAgICAgICAgICAgdy5pc0VtcHR5T2JqZWN0KHUpICYmIEoucmVtb3ZlKGUsIFwiaGFuZGxlIGV2ZW50c1wiKSB9IH0sIGRpc3BhdGNoOiBmdW5jdGlvbihlKSB7IHZhciB0ID0gdy5ldmVudC5maXgoZSksXG4gICAgICAgICAgICAgICAgbiwgciwgaSwgbywgYSwgcywgdSA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICBsID0gKEouZ2V0KHRoaXMsIFwiZXZlbnRzXCIpIHx8IHt9KVt0LnR5cGVdIHx8IFtdLFxuICAgICAgICAgICAgICAgIGMgPSB3LmV2ZW50LnNwZWNpYWxbdC50eXBlXSB8fCB7fTsgZm9yICh1WzBdID0gdCwgbiA9IDE7IG4gPCBhcmd1bWVudHMubGVuZ3RoOyBuKyspIHVbbl0gPSBhcmd1bWVudHNbbl07IGlmICh0LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcywgIWMucHJlRGlzcGF0Y2ggfHwgITEgIT09IGMucHJlRGlzcGF0Y2guY2FsbCh0aGlzLCB0KSkgeyBzID0gdy5ldmVudC5oYW5kbGVycy5jYWxsKHRoaXMsIHQsIGwpLCBuID0gMDsgd2hpbGUgKChvID0gc1tuKytdKSAmJiAhdC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7IHQuY3VycmVudFRhcmdldCA9IG8uZWxlbSwgciA9IDA7IHdoaWxlICgoYSA9IG8uaGFuZGxlcnNbcisrXSkgJiYgIXQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSkgdC5ybmFtZXNwYWNlICYmICF0LnJuYW1lc3BhY2UudGVzdChhLm5hbWVzcGFjZSkgfHwgKHQuaGFuZGxlT2JqID0gYSwgdC5kYXRhID0gYS5kYXRhLCB2b2lkIDAgIT09IChpID0gKCh3LmV2ZW50LnNwZWNpYWxbYS5vcmlnVHlwZV0gfHwge30pLmhhbmRsZSB8fCBhLmhhbmRsZXIpLmFwcGx5KG8uZWxlbSwgdSkpICYmICExID09PSAodC5yZXN1bHQgPSBpKSAmJiAodC5wcmV2ZW50RGVmYXVsdCgpLCB0LnN0b3BQcm9wYWdhdGlvbigpKSkgfSByZXR1cm4gYy5wb3N0RGlzcGF0Y2ggJiYgYy5wb3N0RGlzcGF0Y2guY2FsbCh0aGlzLCB0KSwgdC5yZXN1bHQgfSB9LCBoYW5kbGVyczogZnVuY3Rpb24oZSwgdCkgeyB2YXIgbiwgciwgaSwgbywgYSwgcyA9IFtdLFxuICAgICAgICAgICAgICAgIHUgPSB0LmRlbGVnYXRlQ291bnQsXG4gICAgICAgICAgICAgICAgbCA9IGUudGFyZ2V0OyBpZiAodSAmJiBsLm5vZGVUeXBlICYmICEoXCJjbGlja1wiID09PSBlLnR5cGUgJiYgZS5idXR0b24gPj0gMSkpXG4gICAgICAgICAgICAgICAgZm9yICg7IGwgIT09IHRoaXM7IGwgPSBsLnBhcmVudE5vZGUgfHwgdGhpcylcbiAgICAgICAgICAgICAgICAgICAgaWYgKDEgPT09IGwubm9kZVR5cGUgJiYgKFwiY2xpY2tcIiAhPT0gZS50eXBlIHx8ICEwICE9PSBsLmRpc2FibGVkKSkgeyBmb3IgKG8gPSBbXSwgYSA9IHt9LCBuID0gMDsgbiA8IHU7IG4rKykgdm9pZCAwID09PSBhW2kgPSAociA9IHRbbl0pLnNlbGVjdG9yICsgXCIgXCJdICYmIChhW2ldID0gci5uZWVkc0NvbnRleHQgPyB3KGksIHRoaXMpLmluZGV4KGwpID4gLTEgOiB3LmZpbmQoaSwgdGhpcywgbnVsbCwgW2xdKS5sZW5ndGgpLCBhW2ldICYmIG8ucHVzaChyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8ubGVuZ3RoICYmIHMucHVzaCh7IGVsZW06IGwsIGhhbmRsZXJzOiBvIH0pIH1cbiAgICAgICAgICAgIHJldHVybiBsID0gdGhpcywgdSA8IHQubGVuZ3RoICYmIHMucHVzaCh7IGVsZW06IGwsIGhhbmRsZXJzOiB0LnNsaWNlKHUpIH0pLCBzIH0sIGFkZFByb3A6IGZ1bmN0aW9uKGUsIHQpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHcuRXZlbnQucHJvdG90eXBlLCBlLCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCBnZXQ6IGcodCkgPyBmdW5jdGlvbigpIHsgaWYgKHRoaXMub3JpZ2luYWxFdmVudCkgcmV0dXJuIHQodGhpcy5vcmlnaW5hbEV2ZW50KSB9IDogZnVuY3Rpb24oKSB7IGlmICh0aGlzLm9yaWdpbmFsRXZlbnQpIHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbZV0gfSwgc2V0OiBmdW5jdGlvbih0KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBlLCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiB0IH0pIH0gfSkgfSwgZml4OiBmdW5jdGlvbihlKSB7IHJldHVybiBlW3cuZXhwYW5kb10gPyBlIDogbmV3IHcuRXZlbnQoZSkgfSwgc3BlY2lhbDogeyBsb2FkOiB7IG5vQnViYmxlOiAhMCB9LCBmb2N1czogeyB0cmlnZ2VyOiBmdW5jdGlvbigpIHsgaWYgKHRoaXMgIT09IFNlKCkgJiYgdGhpcy5mb2N1cykgcmV0dXJuIHRoaXMuZm9jdXMoKSwgITEgfSwgZGVsZWdhdGVUeXBlOiBcImZvY3VzaW5cIiB9LCBibHVyOiB7IHRyaWdnZXI6IGZ1bmN0aW9uKCkgeyBpZiAodGhpcyA9PT0gU2UoKSAmJiB0aGlzLmJsdXIpIHJldHVybiB0aGlzLmJsdXIoKSwgITEgfSwgZGVsZWdhdGVUeXBlOiBcImZvY3Vzb3V0XCIgfSwgY2xpY2s6IHsgdHJpZ2dlcjogZnVuY3Rpb24oKSB7IGlmIChcImNoZWNrYm94XCIgPT09IHRoaXMudHlwZSAmJiB0aGlzLmNsaWNrICYmIE4odGhpcywgXCJpbnB1dFwiKSkgcmV0dXJuIHRoaXMuY2xpY2soKSwgITEgfSwgX2RlZmF1bHQ6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIE4oZS50YXJnZXQsIFwiYVwiKSB9IH0sIGJlZm9yZXVubG9hZDogeyBwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKGUpIHsgdm9pZCAwICE9PSBlLnJlc3VsdCAmJiBlLm9yaWdpbmFsRXZlbnQgJiYgKGUub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGUucmVzdWx0KSB9IH0gfSB9LCB3LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oZSwgdCwgbikgeyBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgJiYgZS5yZW1vdmVFdmVudExpc3RlbmVyKHQsIG4pIH0sIHcuRXZlbnQgPSBmdW5jdGlvbihlLCB0KSB7IGlmICghKHRoaXMgaW5zdGFuY2VvZiB3LkV2ZW50KSkgcmV0dXJuIG5ldyB3LkV2ZW50KGUsIHQpO1xuICAgICAgICBlICYmIGUudHlwZSA/ICh0aGlzLm9yaWdpbmFsRXZlbnQgPSBlLCB0aGlzLnR5cGUgPSBlLnR5cGUsIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZS5kZWZhdWx0UHJldmVudGVkIHx8IHZvaWQgMCA9PT0gZS5kZWZhdWx0UHJldmVudGVkICYmICExID09PSBlLnJldHVyblZhbHVlID8gRWUgOiBrZSwgdGhpcy50YXJnZXQgPSBlLnRhcmdldCAmJiAzID09PSBlLnRhcmdldC5ub2RlVHlwZSA/IGUudGFyZ2V0LnBhcmVudE5vZGUgOiBlLnRhcmdldCwgdGhpcy5jdXJyZW50VGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0LCB0aGlzLnJlbGF0ZWRUYXJnZXQgPSBlLnJlbGF0ZWRUYXJnZXQpIDogdGhpcy50eXBlID0gZSwgdCAmJiB3LmV4dGVuZCh0aGlzLCB0KSwgdGhpcy50aW1lU3RhbXAgPSBlICYmIGUudGltZVN0YW1wIHx8IERhdGUubm93KCksIHRoaXNbdy5leHBhbmRvXSA9ICEwIH0sIHcuRXZlbnQucHJvdG90eXBlID0geyBjb25zdHJ1Y3Rvcjogdy5FdmVudCwgaXNEZWZhdWx0UHJldmVudGVkOiBrZSwgaXNQcm9wYWdhdGlvblN0b3BwZWQ6IGtlLCBpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDoga2UsIGlzU2ltdWxhdGVkOiAhMSwgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkgeyB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcbiAgICAgICAgICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gRWUsIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgJiYgZS5wcmV2ZW50RGVmYXVsdCgpIH0sIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7IHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuICAgICAgICAgICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IEVlLCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICYmIGUuc3RvcFByb3BhZ2F0aW9uKCkgfSwgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHsgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG4gICAgICAgICAgICB0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gRWUsIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgJiYgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSwgdGhpcy5zdG9wUHJvcGFnYXRpb24oKSB9IH0sIHcuZWFjaCh7IGFsdEtleTogITAsIGJ1YmJsZXM6ICEwLCBjYW5jZWxhYmxlOiAhMCwgY2hhbmdlZFRvdWNoZXM6ICEwLCBjdHJsS2V5OiAhMCwgZGV0YWlsOiAhMCwgZXZlbnRQaGFzZTogITAsIG1ldGFLZXk6ICEwLCBwYWdlWDogITAsIHBhZ2VZOiAhMCwgc2hpZnRLZXk6ICEwLCB2aWV3OiAhMCwgXCJjaGFyXCI6ICEwLCBjaGFyQ29kZTogITAsIGtleTogITAsIGtleUNvZGU6ICEwLCBidXR0b246ICEwLCBidXR0b25zOiAhMCwgY2xpZW50WDogITAsIGNsaWVudFk6ICEwLCBvZmZzZXRYOiAhMCwgb2Zmc2V0WTogITAsIHBvaW50ZXJJZDogITAsIHBvaW50ZXJUeXBlOiAhMCwgc2NyZWVuWDogITAsIHNjcmVlblk6ICEwLCB0YXJnZXRUb3VjaGVzOiAhMCwgdG9FbGVtZW50OiAhMCwgdG91Y2hlczogITAsIHdoaWNoOiBmdW5jdGlvbihlKSB7IHZhciB0ID0gZS5idXR0b247IHJldHVybiBudWxsID09IGUud2hpY2ggJiYgd2UudGVzdChlLnR5cGUpID8gbnVsbCAhPSBlLmNoYXJDb2RlID8gZS5jaGFyQ29kZSA6IGUua2V5Q29kZSA6ICFlLndoaWNoICYmIHZvaWQgMCAhPT0gdCAmJiBUZS50ZXN0KGUudHlwZSkgPyAxICYgdCA/IDEgOiAyICYgdCA/IDMgOiA0ICYgdCA/IDIgOiAwIDogZS53aGljaCB9IH0sIHcuZXZlbnQuYWRkUHJvcCksIHcuZWFjaCh7IG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsIG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIiwgcG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsIHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCIgfSwgZnVuY3Rpb24oZSwgdCkgeyB3LmV2ZW50LnNwZWNpYWxbZV0gPSB7IGRlbGVnYXRlVHlwZTogdCwgYmluZFR5cGU6IHQsIGhhbmRsZTogZnVuY3Rpb24oZSkgeyB2YXIgbiwgciA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGkgPSBlLnJlbGF0ZWRUYXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIG8gPSBlLmhhbmRsZU9iajsgcmV0dXJuIGkgJiYgKGkgPT09IHIgfHwgdy5jb250YWlucyhyLCBpKSkgfHwgKGUudHlwZSA9IG8ub3JpZ1R5cGUsIG4gPSBvLmhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgZS50eXBlID0gdCksIG4gfSB9IH0pLCB3LmZuLmV4dGVuZCh7IG9uOiBmdW5jdGlvbihlLCB0LCBuLCByKSB7IHJldHVybiBEZSh0aGlzLCBlLCB0LCBuLCByKSB9LCBvbmU6IGZ1bmN0aW9uKGUsIHQsIG4sIHIpIHsgcmV0dXJuIERlKHRoaXMsIGUsIHQsIG4sIHIsIDEpIH0sIG9mZjogZnVuY3Rpb24oZSwgdCwgbikgeyB2YXIgciwgaTsgaWYgKGUgJiYgZS5wcmV2ZW50RGVmYXVsdCAmJiBlLmhhbmRsZU9iaikgcmV0dXJuIHIgPSBlLmhhbmRsZU9iaiwgdyhlLmRlbGVnYXRlVGFyZ2V0KS5vZmYoci5uYW1lc3BhY2UgPyByLm9yaWdUeXBlICsgXCIuXCIgKyByLm5hbWVzcGFjZSA6IHIub3JpZ1R5cGUsIHIuc2VsZWN0b3IsIHIuaGFuZGxlciksIHRoaXM7IGlmIChcIm9iamVjdFwiID09IHR5cGVvZiBlKSB7IGZvciAoaSBpbiBlKSB0aGlzLm9mZihpLCB0LCBlW2ldKTsgcmV0dXJuIHRoaXMgfSByZXR1cm4gITEgIT09IHQgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiB0IHx8IChuID0gdCwgdCA9IHZvaWQgMCksICExID09PSBuICYmIChuID0ga2UpLCB0aGlzLmVhY2goZnVuY3Rpb24oKSB7IHcuZXZlbnQucmVtb3ZlKHRoaXMsIGUsIG4sIHQpIH0pIH0gfSk7IHZhciBOZSA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKilbXj5dKilcXC8+L2dpLFxuICAgICAgICBBZSA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxuICAgICAgICBqZSA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG4gICAgICAgIHFlID0gL15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nO1xuXG4gICAgZnVuY3Rpb24gTGUoZSwgdCkgeyByZXR1cm4gTihlLCBcInRhYmxlXCIpICYmIE4oMTEgIT09IHQubm9kZVR5cGUgPyB0IDogdC5maXJzdENoaWxkLCBcInRyXCIpID8gdyhlKS5jaGlsZHJlbihcInRib2R5XCIpWzBdIHx8IGUgOiBlIH1cblxuICAgIGZ1bmN0aW9uIEhlKGUpIHsgcmV0dXJuIGUudHlwZSA9IChudWxsICE9PSBlLmdldEF0dHJpYnV0ZShcInR5cGVcIikpICsgXCIvXCIgKyBlLnR5cGUsIGUgfVxuXG4gICAgZnVuY3Rpb24gT2UoZSkgeyByZXR1cm4gXCJ0cnVlL1wiID09PSAoZS50eXBlIHx8IFwiXCIpLnNsaWNlKDAsIDUpID8gZS50eXBlID0gZS50eXBlLnNsaWNlKDUpIDogZS5yZW1vdmVBdHRyaWJ1dGUoXCJ0eXBlXCIpLCBlIH1cblxuICAgIGZ1bmN0aW9uIFBlKGUsIHQpIHsgdmFyIG4sIHIsIGksIG8sIGEsIHMsIHUsIGw7IGlmICgxID09PSB0Lm5vZGVUeXBlKSB7IGlmIChKLmhhc0RhdGEoZSkgJiYgKG8gPSBKLmFjY2VzcyhlKSwgYSA9IEouc2V0KHQsIG8pLCBsID0gby5ldmVudHMpKSB7IGRlbGV0ZSBhLmhhbmRsZSwgYS5ldmVudHMgPSB7fTsgZm9yIChpIGluIGwpXG4gICAgICAgICAgICAgICAgICAgIGZvciAobiA9IDAsIHIgPSBsW2ldLmxlbmd0aDsgbiA8IHI7IG4rKykgdy5ldmVudC5hZGQodCwgaSwgbFtpXVtuXSkgfSBLLmhhc0RhdGEoZSkgJiYgKHMgPSBLLmFjY2VzcyhlKSwgdSA9IHcuZXh0ZW5kKHt9LCBzKSwgSy5zZXQodCwgdSkpIH0gfVxuXG4gICAgZnVuY3Rpb24gTWUoZSwgdCkgeyB2YXIgbiA9IHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTsgXCJpbnB1dFwiID09PSBuICYmIHBlLnRlc3QoZS50eXBlKSA/IHQuY2hlY2tlZCA9IGUuY2hlY2tlZCA6IFwiaW5wdXRcIiAhPT0gbiAmJiBcInRleHRhcmVhXCIgIT09IG4gfHwgKHQuZGVmYXVsdFZhbHVlID0gZS5kZWZhdWx0VmFsdWUpIH1cblxuICAgIGZ1bmN0aW9uIFJlKGUsIHQsIG4sIHIpIHsgdCA9IGEuYXBwbHkoW10sIHQpOyB2YXIgaSwgbywgcywgdSwgbCwgYywgZiA9IDAsXG4gICAgICAgICAgICBwID0gZS5sZW5ndGgsXG4gICAgICAgICAgICBkID0gcCAtIDEsXG4gICAgICAgICAgICB5ID0gdFswXSxcbiAgICAgICAgICAgIHYgPSBnKHkpOyBpZiAodiB8fCBwID4gMSAmJiBcInN0cmluZ1wiID09IHR5cGVvZiB5ICYmICFoLmNoZWNrQ2xvbmUgJiYgamUudGVzdCh5KSkgcmV0dXJuIGUuZWFjaChmdW5jdGlvbihpKSB7IHZhciBvID0gZS5lcShpKTtcbiAgICAgICAgICAgIHYgJiYgKHRbMF0gPSB5LmNhbGwodGhpcywgaSwgby5odG1sKCkpKSwgUmUobywgdCwgbiwgcikgfSk7IGlmIChwICYmIChpID0geGUodCwgZVswXS5vd25lckRvY3VtZW50LCAhMSwgZSwgciksIG8gPSBpLmZpcnN0Q2hpbGQsIDEgPT09IGkuY2hpbGROb2Rlcy5sZW5ndGggJiYgKGkgPSBvKSwgbyB8fCByKSkgeyBmb3IgKHUgPSAocyA9IHcubWFwKHllKGksIFwic2NyaXB0XCIpLCBIZSkpLmxlbmd0aDsgZiA8IHA7IGYrKykgbCA9IGksIGYgIT09IGQgJiYgKGwgPSB3LmNsb25lKGwsICEwLCAhMCksIHUgJiYgdy5tZXJnZShzLCB5ZShsLCBcInNjcmlwdFwiKSkpLCBuLmNhbGwoZVtmXSwgbCwgZik7IGlmICh1KVxuICAgICAgICAgICAgICAgIGZvciAoYyA9IHNbcy5sZW5ndGggLSAxXS5vd25lckRvY3VtZW50LCB3Lm1hcChzLCBPZSksIGYgPSAwOyBmIDwgdTsgZisrKSBsID0gc1tmXSwgaGUudGVzdChsLnR5cGUgfHwgXCJcIikgJiYgIUouYWNjZXNzKGwsIFwiZ2xvYmFsRXZhbFwiKSAmJiB3LmNvbnRhaW5zKGMsIGwpICYmIChsLnNyYyAmJiBcIm1vZHVsZVwiICE9PSAobC50eXBlIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkgPyB3Ll9ldmFsVXJsICYmIHcuX2V2YWxVcmwobC5zcmMpIDogbShsLnRleHRDb250ZW50LnJlcGxhY2UocWUsIFwiXCIpLCBjLCBsKSkgfSByZXR1cm4gZSB9XG5cbiAgICBmdW5jdGlvbiBJZShlLCB0LCBuKSB7IGZvciAodmFyIHIsIGkgPSB0ID8gdy5maWx0ZXIodCwgZSkgOiBlLCBvID0gMDsgbnVsbCAhPSAociA9IGlbb10pOyBvKyspIG4gfHwgMSAhPT0gci5ub2RlVHlwZSB8fCB3LmNsZWFuRGF0YSh5ZShyKSksIHIucGFyZW50Tm9kZSAmJiAobiAmJiB3LmNvbnRhaW5zKHIub3duZXJEb2N1bWVudCwgcikgJiYgdmUoeWUociwgXCJzY3JpcHRcIikpLCByLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocikpOyByZXR1cm4gZSB9IHcuZXh0ZW5kKHsgaHRtbFByZWZpbHRlcjogZnVuY3Rpb24oZSkgeyByZXR1cm4gZS5yZXBsYWNlKE5lLCBcIjwkMT48LyQyPlwiKSB9LCBjbG9uZTogZnVuY3Rpb24oZSwgdCwgbikgeyB2YXIgciwgaSwgbywgYSwgcyA9IGUuY2xvbmVOb2RlKCEwKSxcbiAgICAgICAgICAgICAgICB1ID0gdy5jb250YWlucyhlLm93bmVyRG9jdW1lbnQsIGUpOyBpZiAoIShoLm5vQ2xvbmVDaGVja2VkIHx8IDEgIT09IGUubm9kZVR5cGUgJiYgMTEgIT09IGUubm9kZVR5cGUgfHwgdy5pc1hNTERvYyhlKSkpXG4gICAgICAgICAgICAgICAgZm9yIChhID0geWUocyksIHIgPSAwLCBpID0gKG8gPSB5ZShlKSkubGVuZ3RoOyByIDwgaTsgcisrKSBNZShvW3JdLCBhW3JdKTsgaWYgKHQpXG4gICAgICAgICAgICAgICAgaWYgKG4pXG4gICAgICAgICAgICAgICAgICAgIGZvciAobyA9IG8gfHwgeWUoZSksIGEgPSBhIHx8IHllKHMpLCByID0gMCwgaSA9IG8ubGVuZ3RoOyByIDwgaTsgcisrKSBQZShvW3JdLCBhW3JdKTtcbiAgICAgICAgICAgICAgICBlbHNlIFBlKGUsIHMpOyByZXR1cm4gKGEgPSB5ZShzLCBcInNjcmlwdFwiKSkubGVuZ3RoID4gMCAmJiB2ZShhLCAhdSAmJiB5ZShlLCBcInNjcmlwdFwiKSksIHMgfSwgY2xlYW5EYXRhOiBmdW5jdGlvbihlKSB7IGZvciAodmFyIHQsIG4sIHIsIGkgPSB3LmV2ZW50LnNwZWNpYWwsIG8gPSAwOyB2b2lkIDAgIT09IChuID0gZVtvXSk7IG8rKylcbiAgICAgICAgICAgICAgICBpZiAoWShuKSkgeyBpZiAodCA9IG5bSi5leHBhbmRvXSkgeyBpZiAodC5ldmVudHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChyIGluIHQuZXZlbnRzKSBpW3JdID8gdy5ldmVudC5yZW1vdmUobiwgcikgOiB3LnJlbW92ZUV2ZW50KG4sIHIsIHQuaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5bSi5leHBhbmRvXSA9IHZvaWQgMCB9IG5bSy5leHBhbmRvXSAmJiAobltLLmV4cGFuZG9dID0gdm9pZCAwKSB9IH0gfSksIHcuZm4uZXh0ZW5kKHsgZGV0YWNoOiBmdW5jdGlvbihlKSB7IHJldHVybiBJZSh0aGlzLCBlLCAhMCkgfSwgcmVtb3ZlOiBmdW5jdGlvbihlKSB7IHJldHVybiBJZSh0aGlzLCBlKSB9LCB0ZXh0OiBmdW5jdGlvbihlKSB7IHJldHVybiB6KHRoaXMsIGZ1bmN0aW9uKGUpIHsgcmV0dXJuIHZvaWQgMCA9PT0gZSA/IHcudGV4dCh0aGlzKSA6IHRoaXMuZW1wdHkoKS5lYWNoKGZ1bmN0aW9uKCkgeyAxICE9PSB0aGlzLm5vZGVUeXBlICYmIDExICE9PSB0aGlzLm5vZGVUeXBlICYmIDkgIT09IHRoaXMubm9kZVR5cGUgfHwgKHRoaXMudGV4dENvbnRlbnQgPSBlKSB9KSB9LCBudWxsLCBlLCBhcmd1bWVudHMubGVuZ3RoKSB9LCBhcHBlbmQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gUmUodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbihlKSB7IDEgIT09IHRoaXMubm9kZVR5cGUgJiYgMTEgIT09IHRoaXMubm9kZVR5cGUgJiYgOSAhPT0gdGhpcy5ub2RlVHlwZSB8fCBMZSh0aGlzLCBlKS5hcHBlbmRDaGlsZChlKSB9KSB9LCBwcmVwZW5kOiBmdW5jdGlvbigpIHsgcmV0dXJuIFJlKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oZSkgeyBpZiAoMSA9PT0gdGhpcy5ub2RlVHlwZSB8fCAxMSA9PT0gdGhpcy5ub2RlVHlwZSB8fCA5ID09PSB0aGlzLm5vZGVUeXBlKSB7IHZhciB0ID0gTGUodGhpcywgZSk7XG4gICAgICAgICAgICAgICAgICAgIHQuaW5zZXJ0QmVmb3JlKGUsIHQuZmlyc3RDaGlsZCkgfSB9KSB9LCBiZWZvcmU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gUmUodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbihlKSB7IHRoaXMucGFyZW50Tm9kZSAmJiB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGUsIHRoaXMpIH0pIH0sIGFmdGVyOiBmdW5jdGlvbigpIHsgcmV0dXJuIFJlKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oZSkgeyB0aGlzLnBhcmVudE5vZGUgJiYgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlLCB0aGlzLm5leHRTaWJsaW5nKSB9KSB9LCBlbXB0eTogZnVuY3Rpb24oKSB7IGZvciAodmFyIGUsIHQgPSAwOyBudWxsICE9IChlID0gdGhpc1t0XSk7IHQrKykgMSA9PT0gZS5ub2RlVHlwZSAmJiAody5jbGVhbkRhdGEoeWUoZSwgITEpKSwgZS50ZXh0Q29udGVudCA9IFwiXCIpOyByZXR1cm4gdGhpcyB9LCBjbG9uZTogZnVuY3Rpb24oZSwgdCkgeyByZXR1cm4gZSA9IG51bGwgIT0gZSAmJiBlLCB0ID0gbnVsbCA9PSB0ID8gZSA6IHQsIHRoaXMubWFwKGZ1bmN0aW9uKCkgeyByZXR1cm4gdy5jbG9uZSh0aGlzLCBlLCB0KSB9KSB9LCBodG1sOiBmdW5jdGlvbihlKSB7IHJldHVybiB6KHRoaXMsIGZ1bmN0aW9uKGUpIHsgdmFyIHQgPSB0aGlzWzBdIHx8IHt9LFxuICAgICAgICAgICAgICAgICAgICBuID0gMCxcbiAgICAgICAgICAgICAgICAgICAgciA9IHRoaXMubGVuZ3RoOyBpZiAodm9pZCAwID09PSBlICYmIDEgPT09IHQubm9kZVR5cGUpIHJldHVybiB0LmlubmVySFRNTDsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgJiYgIUFlLnRlc3QoZSkgJiYgIWdlWyhkZS5leGVjKGUpIHx8IFtcIlwiLCBcIlwiXSlbMV0udG9Mb3dlckNhc2UoKV0pIHsgZSA9IHcuaHRtbFByZWZpbHRlcihlKTsgdHJ5IHsgZm9yICg7IG4gPCByOyBuKyspIDEgPT09ICh0ID0gdGhpc1tuXSB8fCB7fSkubm9kZVR5cGUgJiYgKHcuY2xlYW5EYXRhKHllKHQsICExKSksIHQuaW5uZXJIVE1MID0gZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gMCB9IGNhdGNoIChlKSB7fSB9IHQgJiYgdGhpcy5lbXB0eSgpLmFwcGVuZChlKSB9LCBudWxsLCBlLCBhcmd1bWVudHMubGVuZ3RoKSB9LCByZXBsYWNlV2l0aDogZnVuY3Rpb24oKSB7IHZhciBlID0gW107IHJldHVybiBSZSh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKHQpIHsgdmFyIG4gPSB0aGlzLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgdy5pbkFycmF5KHRoaXMsIGUpIDwgMCAmJiAody5jbGVhbkRhdGEoeWUodGhpcykpLCBuICYmIG4ucmVwbGFjZUNoaWxkKHQsIHRoaXMpKSB9LCBlKSB9IH0pLCB3LmVhY2goeyBhcHBlbmRUbzogXCJhcHBlbmRcIiwgcHJlcGVuZFRvOiBcInByZXBlbmRcIiwgaW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLCBpbnNlcnRBZnRlcjogXCJhZnRlclwiLCByZXBsYWNlQWxsOiBcInJlcGxhY2VXaXRoXCIgfSwgZnVuY3Rpb24oZSwgdCkgeyB3LmZuW2VdID0gZnVuY3Rpb24oZSkgeyBmb3IgKHZhciBuLCByID0gW10sIGkgPSB3KGUpLCBvID0gaS5sZW5ndGggLSAxLCBhID0gMDsgYSA8PSBvOyBhKyspIG4gPSBhID09PSBvID8gdGhpcyA6IHRoaXMuY2xvbmUoITApLCB3KGlbYV0pW3RdKG4pLCBzLmFwcGx5KHIsIG4uZ2V0KCkpOyByZXR1cm4gdGhpcy5wdXNoU3RhY2socikgfSB9KTsgdmFyIFdlID0gbmV3IFJlZ0V4cChcIl4oXCIgKyByZSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiKSxcbiAgICAgICAgJGUgPSBmdW5jdGlvbih0KSB7IHZhciBuID0gdC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3OyByZXR1cm4gbiAmJiBuLm9wZW5lciB8fCAobiA9IGUpLCBuLmdldENvbXB1dGVkU3R5bGUodCkgfSxcbiAgICAgICAgQmUgPSBuZXcgUmVnRXhwKG9lLmpvaW4oXCJ8XCIpLCBcImlcIik7ISBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gdCgpIHsgaWYgKGMpIHsgbC5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4O3dpZHRoOjYwcHg7bWFyZ2luLXRvcDoxcHg7cGFkZGluZzowO2JvcmRlcjowXCIsIGMuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9jaztib3gtc2l6aW5nOmJvcmRlci1ib3g7b3ZlcmZsb3c6c2Nyb2xsO21hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7d2lkdGg6NjAlO3RvcDoxJVwiLCBiZS5hcHBlbmRDaGlsZChsKS5hcHBlbmRDaGlsZChjKTsgdmFyIHQgPSBlLmdldENvbXB1dGVkU3R5bGUoYyk7XG4gICAgICAgICAgICAgICAgaSA9IFwiMSVcIiAhPT0gdC50b3AsIHUgPSAxMiA9PT0gbih0Lm1hcmdpbkxlZnQpLCBjLnN0eWxlLnJpZ2h0ID0gXCI2MCVcIiwgcyA9IDM2ID09PSBuKHQucmlnaHQpLCBvID0gMzYgPT09IG4odC53aWR0aCksIGMuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCIsIGEgPSAzNiA9PT0gYy5vZmZzZXRXaWR0aCB8fCBcImFic29sdXRlXCIsIGJlLnJlbW92ZUNoaWxkKGwpLCBjID0gbnVsbCB9IH1cblxuICAgICAgICBmdW5jdGlvbiBuKGUpIHsgcmV0dXJuIE1hdGgucm91bmQocGFyc2VGbG9hdChlKSkgfSB2YXIgaSwgbywgYSwgcywgdSwgbCA9IHIuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgICAgICAgIGMgPSByLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGMuc3R5bGUgJiYgKGMuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCIsIGMuY2xvbmVOb2RlKCEwKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCIsIGguY2xlYXJDbG9uZVN0eWxlID0gXCJjb250ZW50LWJveFwiID09PSBjLnN0eWxlLmJhY2tncm91bmRDbGlwLCB3LmV4dGVuZChoLCB7IGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHQoKSwgbyB9LCBwaXhlbEJveFN0eWxlczogZnVuY3Rpb24oKSB7IHJldHVybiB0KCksIHMgfSwgcGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7IHJldHVybiB0KCksIGkgfSwgcmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHQoKSwgdSB9LCBzY3JvbGxib3hTaXplOiBmdW5jdGlvbigpIHsgcmV0dXJuIHQoKSwgYSB9IH0pKSB9KCk7XG5cbiAgICBmdW5jdGlvbiBGZShlLCB0LCBuKSB7IHZhciByLCBpLCBvLCBhLCBzID0gZS5zdHlsZTsgcmV0dXJuIChuID0gbiB8fCAkZShlKSkgJiYgKFwiXCIgIT09IChhID0gbi5nZXRQcm9wZXJ0eVZhbHVlKHQpIHx8IG5bdF0pIHx8IHcuY29udGFpbnMoZS5vd25lckRvY3VtZW50LCBlKSB8fCAoYSA9IHcuc3R5bGUoZSwgdCkpLCAhaC5waXhlbEJveFN0eWxlcygpICYmIFdlLnRlc3QoYSkgJiYgQmUudGVzdCh0KSAmJiAociA9IHMud2lkdGgsIGkgPSBzLm1pbldpZHRoLCBvID0gcy5tYXhXaWR0aCwgcy5taW5XaWR0aCA9IHMubWF4V2lkdGggPSBzLndpZHRoID0gYSwgYSA9IG4ud2lkdGgsIHMud2lkdGggPSByLCBzLm1pbldpZHRoID0gaSwgcy5tYXhXaWR0aCA9IG8pKSwgdm9pZCAwICE9PSBhID8gYSArIFwiXCIgOiBhIH1cblxuICAgIGZ1bmN0aW9uIF9lKGUsIHQpIHsgcmV0dXJuIHsgZ2V0OiBmdW5jdGlvbigpIHsgaWYgKCFlKCkpIHJldHVybiAodGhpcy5nZXQgPSB0KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmdldCB9IH0gfSB2YXIgemUgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXG4gICAgICAgIFhlID0gL14tLS8sXG4gICAgICAgIFVlID0geyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBkaXNwbGF5OiBcImJsb2NrXCIgfSxcbiAgICAgICAgVmUgPSB7IGxldHRlclNwYWNpbmc6IFwiMFwiLCBmb250V2VpZ2h0OiBcIjQwMFwiIH0sXG4gICAgICAgIEdlID0gW1wiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIl0sXG4gICAgICAgIFllID0gci5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlO1xuXG4gICAgZnVuY3Rpb24gUWUoZSkgeyBpZiAoZSBpbiBZZSkgcmV0dXJuIGU7IHZhciB0ID0gZVswXS50b1VwcGVyQ2FzZSgpICsgZS5zbGljZSgxKSxcbiAgICAgICAgICAgIG4gPSBHZS5sZW5ndGg7IHdoaWxlIChuLS0pXG4gICAgICAgICAgICBpZiAoKGUgPSBHZVtuXSArIHQpIGluIFllKSByZXR1cm4gZSB9XG5cbiAgICBmdW5jdGlvbiBKZShlKSB7IHZhciB0ID0gdy5jc3NQcm9wc1tlXTsgcmV0dXJuIHQgfHwgKHQgPSB3LmNzc1Byb3BzW2VdID0gUWUoZSkgfHwgZSksIHQgfVxuXG4gICAgZnVuY3Rpb24gS2UoZSwgdCwgbikgeyB2YXIgciA9IGllLmV4ZWModCk7IHJldHVybiByID8gTWF0aC5tYXgoMCwgclsyXSAtIChuIHx8IDApKSArIChyWzNdIHx8IFwicHhcIikgOiB0IH1cblxuICAgIGZ1bmN0aW9uIFplKGUsIHQsIG4sIHIsIGksIG8pIHsgdmFyIGEgPSBcIndpZHRoXCIgPT09IHQgPyAxIDogMCxcbiAgICAgICAgICAgIHMgPSAwLFxuICAgICAgICAgICAgdSA9IDA7IGlmIChuID09PSAociA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIikpIHJldHVybiAwOyBmb3IgKDsgYSA8IDQ7IGEgKz0gMikgXCJtYXJnaW5cIiA9PT0gbiAmJiAodSArPSB3LmNzcyhlLCBuICsgb2VbYV0sICEwLCBpKSksIHIgPyAoXCJjb250ZW50XCIgPT09IG4gJiYgKHUgLT0gdy5jc3MoZSwgXCJwYWRkaW5nXCIgKyBvZVthXSwgITAsIGkpKSwgXCJtYXJnaW5cIiAhPT0gbiAmJiAodSAtPSB3LmNzcyhlLCBcImJvcmRlclwiICsgb2VbYV0gKyBcIldpZHRoXCIsICEwLCBpKSkpIDogKHUgKz0gdy5jc3MoZSwgXCJwYWRkaW5nXCIgKyBvZVthXSwgITAsIGkpLCBcInBhZGRpbmdcIiAhPT0gbiA/IHUgKz0gdy5jc3MoZSwgXCJib3JkZXJcIiArIG9lW2FdICsgXCJXaWR0aFwiLCAhMCwgaSkgOiBzICs9IHcuY3NzKGUsIFwiYm9yZGVyXCIgKyBvZVthXSArIFwiV2lkdGhcIiwgITAsIGkpKTsgcmV0dXJuICFyICYmIG8gPj0gMCAmJiAodSArPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoZVtcIm9mZnNldFwiICsgdFswXS50b1VwcGVyQ2FzZSgpICsgdC5zbGljZSgxKV0gLSBvIC0gdSAtIHMgLSAuNSkpKSwgdSB9XG5cbiAgICBmdW5jdGlvbiBldChlLCB0LCBuKSB7IHZhciByID0gJGUoZSksXG4gICAgICAgICAgICBpID0gRmUoZSwgdCwgciksXG4gICAgICAgICAgICBvID0gXCJib3JkZXItYm94XCIgPT09IHcuY3NzKGUsIFwiYm94U2l6aW5nXCIsICExLCByKSxcbiAgICAgICAgICAgIGEgPSBvOyBpZiAoV2UudGVzdChpKSkgeyBpZiAoIW4pIHJldHVybiBpO1xuICAgICAgICAgICAgaSA9IFwiYXV0b1wiIH0gcmV0dXJuIGEgPSBhICYmIChoLmJveFNpemluZ1JlbGlhYmxlKCkgfHwgaSA9PT0gZS5zdHlsZVt0XSksIChcImF1dG9cIiA9PT0gaSB8fCAhcGFyc2VGbG9hdChpKSAmJiBcImlubGluZVwiID09PSB3LmNzcyhlLCBcImRpc3BsYXlcIiwgITEsIHIpKSAmJiAoaSA9IGVbXCJvZmZzZXRcIiArIHRbMF0udG9VcHBlckNhc2UoKSArIHQuc2xpY2UoMSldLCBhID0gITApLCAoaSA9IHBhcnNlRmxvYXQoaSkgfHwgMCkgKyBaZShlLCB0LCBuIHx8IChvID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiKSwgYSwgciwgaSkgKyBcInB4XCIgfSB3LmV4dGVuZCh7IGNzc0hvb2tzOiB7IG9wYWNpdHk6IHsgZ2V0OiBmdW5jdGlvbihlLCB0KSB7IGlmICh0KSB7IHZhciBuID0gRmUoZSwgXCJvcGFjaXR5XCIpOyByZXR1cm4gXCJcIiA9PT0gbiA/IFwiMVwiIDogbiB9IH0gfSB9LCBjc3NOdW1iZXI6IHsgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6ICEwLCBjb2x1bW5Db3VudDogITAsIGZpbGxPcGFjaXR5OiAhMCwgZmxleEdyb3c6ICEwLCBmbGV4U2hyaW5rOiAhMCwgZm9udFdlaWdodDogITAsIGxpbmVIZWlnaHQ6ICEwLCBvcGFjaXR5OiAhMCwgb3JkZXI6ICEwLCBvcnBoYW5zOiAhMCwgd2lkb3dzOiAhMCwgekluZGV4OiAhMCwgem9vbTogITAgfSwgY3NzUHJvcHM6IHt9LCBzdHlsZTogZnVuY3Rpb24oZSwgdCwgbiwgcikgeyBpZiAoZSAmJiAzICE9PSBlLm5vZGVUeXBlICYmIDggIT09IGUubm9kZVR5cGUgJiYgZS5zdHlsZSkgeyB2YXIgaSwgbywgYSwgcyA9IEcodCksXG4gICAgICAgICAgICAgICAgICAgIHUgPSBYZS50ZXN0KHQpLFxuICAgICAgICAgICAgICAgICAgICBsID0gZS5zdHlsZTsgaWYgKHUgfHwgKHQgPSBKZShzKSksIGEgPSB3LmNzc0hvb2tzW3RdIHx8IHcuY3NzSG9va3Nbc10sIHZvaWQgMCA9PT0gbikgcmV0dXJuIGEgJiYgXCJnZXRcIiBpbiBhICYmIHZvaWQgMCAhPT0gKGkgPSBhLmdldChlLCAhMSwgcikpID8gaSA6IGxbdF07IFwic3RyaW5nXCIgPT0gKG8gPSB0eXBlb2YgbikgJiYgKGkgPSBpZS5leGVjKG4pKSAmJiBpWzFdICYmIChuID0gdWUoZSwgdCwgaSksIG8gPSBcIm51bWJlclwiKSwgbnVsbCAhPSBuICYmIG4gPT09IG4gJiYgKFwibnVtYmVyXCIgPT09IG8gJiYgKG4gKz0gaSAmJiBpWzNdIHx8ICh3LmNzc051bWJlcltzXSA/IFwiXCIgOiBcInB4XCIpKSwgaC5jbGVhckNsb25lU3R5bGUgfHwgXCJcIiAhPT0gbiB8fCAwICE9PSB0LmluZGV4T2YoXCJiYWNrZ3JvdW5kXCIpIHx8IChsW3RdID0gXCJpbmhlcml0XCIpLCBhICYmIFwic2V0XCIgaW4gYSAmJiB2b2lkIDAgPT09IChuID0gYS5zZXQoZSwgbiwgcikpIHx8ICh1ID8gbC5zZXRQcm9wZXJ0eSh0LCBuKSA6IGxbdF0gPSBuKSkgfSB9LCBjc3M6IGZ1bmN0aW9uKGUsIHQsIG4sIHIpIHsgdmFyIGksIG8sIGEsIHMgPSBHKHQpOyByZXR1cm4gWGUudGVzdCh0KSB8fCAodCA9IEplKHMpKSwgKGEgPSB3LmNzc0hvb2tzW3RdIHx8IHcuY3NzSG9va3Nbc10pICYmIFwiZ2V0XCIgaW4gYSAmJiAoaSA9IGEuZ2V0KGUsICEwLCBuKSksIHZvaWQgMCA9PT0gaSAmJiAoaSA9IEZlKGUsIHQsIHIpKSwgXCJub3JtYWxcIiA9PT0gaSAmJiB0IGluIFZlICYmIChpID0gVmVbdF0pLCBcIlwiID09PSBuIHx8IG4gPyAobyA9IHBhcnNlRmxvYXQoaSksICEwID09PSBuIHx8IGlzRmluaXRlKG8pID8gbyB8fCAwIDogaSkgOiBpIH0gfSksIHcuZWFjaChbXCJoZWlnaHRcIiwgXCJ3aWR0aFwiXSwgZnVuY3Rpb24oZSwgdCkgeyB3LmNzc0hvb2tzW3RdID0geyBnZXQ6IGZ1bmN0aW9uKGUsIG4sIHIpIHsgaWYgKG4pIHJldHVybiAhemUudGVzdCh3LmNzcyhlLCBcImRpc3BsYXlcIikpIHx8IGUuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggJiYgZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCA/IGV0KGUsIHQsIHIpIDogc2UoZSwgVWUsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZXQoZSwgdCwgcikgfSkgfSwgc2V0OiBmdW5jdGlvbihlLCBuLCByKSB7IHZhciBpLCBvID0gJGUoZSksXG4gICAgICAgICAgICAgICAgICAgIGEgPSBcImJvcmRlci1ib3hcIiA9PT0gdy5jc3MoZSwgXCJib3hTaXppbmdcIiwgITEsIG8pLFxuICAgICAgICAgICAgICAgICAgICBzID0gciAmJiBaZShlLCB0LCByLCBhLCBvKTsgcmV0dXJuIGEgJiYgaC5zY3JvbGxib3hTaXplKCkgPT09IG8ucG9zaXRpb24gJiYgKHMgLT0gTWF0aC5jZWlsKGVbXCJvZmZzZXRcIiArIHRbMF0udG9VcHBlckNhc2UoKSArIHQuc2xpY2UoMSldIC0gcGFyc2VGbG9hdChvW3RdKSAtIFplKGUsIHQsIFwiYm9yZGVyXCIsICExLCBvKSAtIC41KSksIHMgJiYgKGkgPSBpZS5leGVjKG4pKSAmJiBcInB4XCIgIT09IChpWzNdIHx8IFwicHhcIikgJiYgKGUuc3R5bGVbdF0gPSBuLCBuID0gdy5jc3MoZSwgdCkpLCBLZShlLCBuLCBzKSB9IH0gfSksIHcuY3NzSG9va3MubWFyZ2luTGVmdCA9IF9lKGgucmVsaWFibGVNYXJnaW5MZWZ0LCBmdW5jdGlvbihlLCB0KSB7IGlmICh0KSByZXR1cm4gKHBhcnNlRmxvYXQoRmUoZSwgXCJtYXJnaW5MZWZ0XCIpKSB8fCBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLSBzZShlLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7IHJldHVybiBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgfSkpICsgXCJweFwiIH0pLCB3LmVhY2goeyBtYXJnaW46IFwiXCIsIHBhZGRpbmc6IFwiXCIsIGJvcmRlcjogXCJXaWR0aFwiIH0sIGZ1bmN0aW9uKGUsIHQpIHsgdy5jc3NIb29rc1tlICsgdF0gPSB7IGV4cGFuZDogZnVuY3Rpb24obikgeyBmb3IgKHZhciByID0gMCwgaSA9IHt9LCBvID0gXCJzdHJpbmdcIiA9PSB0eXBlb2YgbiA/IG4uc3BsaXQoXCIgXCIpIDogW25dOyByIDwgNDsgcisrKSBpW2UgKyBvZVtyXSArIHRdID0gb1tyXSB8fCBvW3IgLSAyXSB8fCBvWzBdOyByZXR1cm4gaSB9IH0sIFwibWFyZ2luXCIgIT09IGUgJiYgKHcuY3NzSG9va3NbZSArIHRdLnNldCA9IEtlKSB9KSwgdy5mbi5leHRlbmQoeyBjc3M6IGZ1bmN0aW9uKGUsIHQpIHsgcmV0dXJuIHoodGhpcywgZnVuY3Rpb24oZSwgdCwgbikgeyB2YXIgciwgaSwgbyA9IHt9LFxuICAgICAgICAgICAgICAgICAgICBhID0gMDsgaWYgKEFycmF5LmlzQXJyYXkodCkpIHsgZm9yIChyID0gJGUoZSksIGkgPSB0Lmxlbmd0aDsgYSA8IGk7IGErKykgb1t0W2FdXSA9IHcuY3NzKGUsIHRbYV0sICExLCByKTsgcmV0dXJuIG8gfSByZXR1cm4gdm9pZCAwICE9PSBuID8gdy5zdHlsZShlLCB0LCBuKSA6IHcuY3NzKGUsIHQpIH0sIGUsIHQsIGFyZ3VtZW50cy5sZW5ndGggPiAxKSB9IH0pO1xuXG4gICAgZnVuY3Rpb24gdHQoZSwgdCwgbiwgciwgaSkgeyByZXR1cm4gbmV3IHR0LnByb3RvdHlwZS5pbml0KGUsIHQsIG4sIHIsIGkpIH0gdy5Ud2VlbiA9IHR0LCB0dC5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiB0dCwgaW5pdDogZnVuY3Rpb24oZSwgdCwgbiwgciwgaSwgbykgeyB0aGlzLmVsZW0gPSBlLCB0aGlzLnByb3AgPSBuLCB0aGlzLmVhc2luZyA9IGkgfHwgdy5lYXNpbmcuX2RlZmF1bHQsIHRoaXMub3B0aW9ucyA9IHQsIHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCksIHRoaXMuZW5kID0gciwgdGhpcy51bml0ID0gbyB8fCAody5jc3NOdW1iZXJbbl0gPyBcIlwiIDogXCJweFwiKSB9LCBjdXI6IGZ1bmN0aW9uKCkgeyB2YXIgZSA9IHR0LnByb3BIb29rc1t0aGlzLnByb3BdOyByZXR1cm4gZSAmJiBlLmdldCA/IGUuZ2V0KHRoaXMpIDogdHQucHJvcEhvb2tzLl9kZWZhdWx0LmdldCh0aGlzKSB9LCBydW46IGZ1bmN0aW9uKGUpIHsgdmFyIHQsIG4gPSB0dC5wcm9wSG9va3NbdGhpcy5wcm9wXTsgcmV0dXJuIHRoaXMub3B0aW9ucy5kdXJhdGlvbiA/IHRoaXMucG9zID0gdCA9IHcuZWFzaW5nW3RoaXMuZWFzaW5nXShlLCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBlLCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb24pIDogdGhpcy5wb3MgPSB0ID0gZSwgdGhpcy5ub3cgPSAodGhpcy5lbmQgLSB0aGlzLnN0YXJ0KSAqIHQgKyB0aGlzLnN0YXJ0LCB0aGlzLm9wdGlvbnMuc3RlcCAmJiB0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMpLCBuICYmIG4uc2V0ID8gbi5zZXQodGhpcykgOiB0dC5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KHRoaXMpLCB0aGlzIH0gfSwgdHQucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gdHQucHJvdG90eXBlLCB0dC5wcm9wSG9va3MgPSB7IF9kZWZhdWx0OiB7IGdldDogZnVuY3Rpb24oZSkgeyB2YXIgdDsgcmV0dXJuIDEgIT09IGUuZWxlbS5ub2RlVHlwZSB8fCBudWxsICE9IGUuZWxlbVtlLnByb3BdICYmIG51bGwgPT0gZS5lbGVtLnN0eWxlW2UucHJvcF0gPyBlLmVsZW1bZS5wcm9wXSA6ICh0ID0gdy5jc3MoZS5lbGVtLCBlLnByb3AsIFwiXCIpKSAmJiBcImF1dG9cIiAhPT0gdCA/IHQgOiAwIH0sIHNldDogZnVuY3Rpb24oZSkgeyB3LmZ4LnN0ZXBbZS5wcm9wXSA/IHcuZnguc3RlcFtlLnByb3BdKGUpIDogMSAhPT0gZS5lbGVtLm5vZGVUeXBlIHx8IG51bGwgPT0gZS5lbGVtLnN0eWxlW3cuY3NzUHJvcHNbZS5wcm9wXV0gJiYgIXcuY3NzSG9va3NbZS5wcm9wXSA/IGUuZWxlbVtlLnByb3BdID0gZS5ub3cgOiB3LnN0eWxlKGUuZWxlbSwgZS5wcm9wLCBlLm5vdyArIGUudW5pdCkgfSB9IH0sIHR0LnByb3BIb29rcy5zY3JvbGxUb3AgPSB0dC5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHsgc2V0OiBmdW5jdGlvbihlKSB7IGUuZWxlbS5ub2RlVHlwZSAmJiBlLmVsZW0ucGFyZW50Tm9kZSAmJiAoZS5lbGVtW2UucHJvcF0gPSBlLm5vdykgfSB9LCB3LmVhc2luZyA9IHsgbGluZWFyOiBmdW5jdGlvbihlKSB7IHJldHVybiBlIH0sIHN3aW5nOiBmdW5jdGlvbihlKSB7IHJldHVybiAuNSAtIE1hdGguY29zKGUgKiBNYXRoLlBJKSAvIDIgfSwgX2RlZmF1bHQ6IFwic3dpbmdcIiB9LCB3LmZ4ID0gdHQucHJvdG90eXBlLmluaXQsIHcuZnguc3RlcCA9IHt9OyB2YXIgbnQsIHJ0LCBpdCA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcbiAgICAgICAgb3QgPSAvcXVldWVIb29rcyQvO1xuXG4gICAgZnVuY3Rpb24gYXQoKSB7IHJ0ICYmICghMSA9PT0gci5oaWRkZW4gJiYgZS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPyBlLnJlcXVlc3RBbmltYXRpb25GcmFtZShhdCkgOiBlLnNldFRpbWVvdXQoYXQsIHcuZnguaW50ZXJ2YWwpLCB3LmZ4LnRpY2soKSkgfVxuXG4gICAgZnVuY3Rpb24gc3QoKSB7IHJldHVybiBlLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IG50ID0gdm9pZCAwIH0pLCBudCA9IERhdGUubm93KCkgfVxuXG4gICAgZnVuY3Rpb24gdXQoZSwgdCkgeyB2YXIgbiwgciA9IDAsXG4gICAgICAgICAgICBpID0geyBoZWlnaHQ6IGUgfTsgZm9yICh0ID0gdCA/IDEgOiAwOyByIDwgNDsgciArPSAyIC0gdCkgaVtcIm1hcmdpblwiICsgKG4gPSBvZVtyXSldID0gaVtcInBhZGRpbmdcIiArIG5dID0gZTsgcmV0dXJuIHQgJiYgKGkub3BhY2l0eSA9IGkud2lkdGggPSBlKSwgaSB9XG5cbiAgICBmdW5jdGlvbiBsdChlLCB0LCBuKSB7IGZvciAodmFyIHIsIGkgPSAocHQudHdlZW5lcnNbdF0gfHwgW10pLmNvbmNhdChwdC50d2VlbmVyc1tcIipcIl0pLCBvID0gMCwgYSA9IGkubGVuZ3RoOyBvIDwgYTsgbysrKVxuICAgICAgICAgICAgaWYgKHIgPSBpW29dLmNhbGwobiwgdCwgZSkpIHJldHVybiByIH1cblxuICAgIGZ1bmN0aW9uIGN0KGUsIHQsIG4pIHsgdmFyIHIsIGksIG8sIGEsIHMsIHUsIGwsIGMsIGYgPSBcIndpZHRoXCIgaW4gdCB8fCBcImhlaWdodFwiIGluIHQsXG4gICAgICAgICAgICBwID0gdGhpcyxcbiAgICAgICAgICAgIGQgPSB7fSxcbiAgICAgICAgICAgIGggPSBlLnN0eWxlLFxuICAgICAgICAgICAgZyA9IGUubm9kZVR5cGUgJiYgYWUoZSksXG4gICAgICAgICAgICB5ID0gSi5nZXQoZSwgXCJmeHNob3dcIik7XG4gICAgICAgIG4ucXVldWUgfHwgKG51bGwgPT0gKGEgPSB3Ll9xdWV1ZUhvb2tzKGUsIFwiZnhcIikpLnVucXVldWVkICYmIChhLnVucXVldWVkID0gMCwgcyA9IGEuZW1wdHkuZmlyZSwgYS5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7IGEudW5xdWV1ZWQgfHwgcygpIH0pLCBhLnVucXVldWVkKyssIHAuYWx3YXlzKGZ1bmN0aW9uKCkgeyBwLmFsd2F5cyhmdW5jdGlvbigpIHsgYS51bnF1ZXVlZC0tLCB3LnF1ZXVlKGUsIFwiZnhcIikubGVuZ3RoIHx8IGEuZW1wdHkuZmlyZSgpIH0pIH0pKTsgZm9yIChyIGluIHQpXG4gICAgICAgICAgICBpZiAoaSA9IHRbcl0sIGl0LnRlc3QoaSkpIHsgaWYgKGRlbGV0ZSB0W3JdLCBvID0gbyB8fCBcInRvZ2dsZVwiID09PSBpLCBpID09PSAoZyA/IFwiaGlkZVwiIDogXCJzaG93XCIpKSB7IGlmIChcInNob3dcIiAhPT0gaSB8fCAheSB8fCB2b2lkIDAgPT09IHlbcl0pIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBnID0gITAgfSBkW3JdID0geSAmJiB5W3JdIHx8IHcuc3R5bGUoZSwgcikgfVxuICAgICAgICBpZiAoKHUgPSAhdy5pc0VtcHR5T2JqZWN0KHQpKSB8fCAhdy5pc0VtcHR5T2JqZWN0KGQpKSB7IGYgJiYgMSA9PT0gZS5ub2RlVHlwZSAmJiAobi5vdmVyZmxvdyA9IFtoLm92ZXJmbG93LCBoLm92ZXJmbG93WCwgaC5vdmVyZmxvd1ldLCBudWxsID09IChsID0geSAmJiB5LmRpc3BsYXkpICYmIChsID0gSi5nZXQoZSwgXCJkaXNwbGF5XCIpKSwgXCJub25lXCIgPT09IChjID0gdy5jc3MoZSwgXCJkaXNwbGF5XCIpKSAmJiAobCA/IGMgPSBsIDogKGZlKFtlXSwgITApLCBsID0gZS5zdHlsZS5kaXNwbGF5IHx8IGwsIGMgPSB3LmNzcyhlLCBcImRpc3BsYXlcIiksIGZlKFtlXSkpKSwgKFwiaW5saW5lXCIgPT09IGMgfHwgXCJpbmxpbmUtYmxvY2tcIiA9PT0gYyAmJiBudWxsICE9IGwpICYmIFwibm9uZVwiID09PSB3LmNzcyhlLCBcImZsb2F0XCIpICYmICh1IHx8IChwLmRvbmUoZnVuY3Rpb24oKSB7IGguZGlzcGxheSA9IGwgfSksIG51bGwgPT0gbCAmJiAoYyA9IGguZGlzcGxheSwgbCA9IFwibm9uZVwiID09PSBjID8gXCJcIiA6IGMpKSwgaC5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIikpLCBuLm92ZXJmbG93ICYmIChoLm92ZXJmbG93ID0gXCJoaWRkZW5cIiwgcC5hbHdheXMoZnVuY3Rpb24oKSB7IGgub3ZlcmZsb3cgPSBuLm92ZXJmbG93WzBdLCBoLm92ZXJmbG93WCA9IG4ub3ZlcmZsb3dbMV0sIGgub3ZlcmZsb3dZID0gbi5vdmVyZmxvd1syXSB9KSksIHUgPSAhMTsgZm9yIChyIGluIGQpIHUgfHwgKHkgPyBcImhpZGRlblwiIGluIHkgJiYgKGcgPSB5LmhpZGRlbikgOiB5ID0gSi5hY2Nlc3MoZSwgXCJmeHNob3dcIiwgeyBkaXNwbGF5OiBsIH0pLCBvICYmICh5LmhpZGRlbiA9ICFnKSwgZyAmJiBmZShbZV0sICEwKSwgcC5kb25lKGZ1bmN0aW9uKCkgeyBnIHx8IGZlKFtlXSksIEoucmVtb3ZlKGUsIFwiZnhzaG93XCIpOyBmb3IgKHIgaW4gZCkgdy5zdHlsZShlLCByLCBkW3JdKSB9KSksIHUgPSBsdChnID8geVtyXSA6IDAsIHIsIHApLCByIGluIHkgfHwgKHlbcl0gPSB1LnN0YXJ0LCBnICYmICh1LmVuZCA9IHUuc3RhcnQsIHUuc3RhcnQgPSAwKSkgfSB9XG5cbiAgICBmdW5jdGlvbiBmdChlLCB0KSB7IHZhciBuLCByLCBpLCBvLCBhOyBmb3IgKG4gaW4gZSlcbiAgICAgICAgICAgIGlmIChyID0gRyhuKSwgaSA9IHRbcl0sIG8gPSBlW25dLCBBcnJheS5pc0FycmF5KG8pICYmIChpID0gb1sxXSwgbyA9IGVbbl0gPSBvWzBdKSwgbiAhPT0gciAmJiAoZVtyXSA9IG8sIGRlbGV0ZSBlW25dKSwgKGEgPSB3LmNzc0hvb2tzW3JdKSAmJiBcImV4cGFuZFwiIGluIGEpIHsgbyA9IGEuZXhwYW5kKG8pLCBkZWxldGUgZVtyXTsgZm9yIChuIGluIG8pIG4gaW4gZSB8fCAoZVtuXSA9IG9bbl0sIHRbbl0gPSBpKSB9XG4gICAgICAgIGVsc2UgdFtyXSA9IGkgfVxuXG4gICAgZnVuY3Rpb24gcHQoZSwgdCwgbikgeyB2YXIgciwgaSwgbyA9IDAsXG4gICAgICAgICAgICBhID0gcHQucHJlZmlsdGVycy5sZW5ndGgsXG4gICAgICAgICAgICBzID0gdy5EZWZlcnJlZCgpLmFsd2F5cyhmdW5jdGlvbigpIHsgZGVsZXRlIHUuZWxlbSB9KSxcbiAgICAgICAgICAgIHUgPSBmdW5jdGlvbigpIHsgaWYgKGkpIHJldHVybiAhMTsgZm9yICh2YXIgdCA9IG50IHx8IHN0KCksIG4gPSBNYXRoLm1heCgwLCBsLnN0YXJ0VGltZSArIGwuZHVyYXRpb24gLSB0KSwgciA9IDEgLSAobiAvIGwuZHVyYXRpb24gfHwgMCksIG8gPSAwLCBhID0gbC50d2VlbnMubGVuZ3RoOyBvIDwgYTsgbysrKSBsLnR3ZWVuc1tvXS5ydW4ocik7IHJldHVybiBzLm5vdGlmeVdpdGgoZSwgW2wsIHIsIG5dKSwgciA8IDEgJiYgYSA/IG4gOiAoYSB8fCBzLm5vdGlmeVdpdGgoZSwgW2wsIDEsIDBdKSwgcy5yZXNvbHZlV2l0aChlLCBbbF0pLCAhMSkgfSxcbiAgICAgICAgICAgIGwgPSBzLnByb21pc2UoeyBlbGVtOiBlLCBwcm9wczogdy5leHRlbmQoe30sIHQpLCBvcHRzOiB3LmV4dGVuZCghMCwgeyBzcGVjaWFsRWFzaW5nOiB7fSwgZWFzaW5nOiB3LmVhc2luZy5fZGVmYXVsdCB9LCBuKSwgb3JpZ2luYWxQcm9wZXJ0aWVzOiB0LCBvcmlnaW5hbE9wdGlvbnM6IG4sIHN0YXJ0VGltZTogbnQgfHwgc3QoKSwgZHVyYXRpb246IG4uZHVyYXRpb24sIHR3ZWVuczogW10sIGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbih0LCBuKSB7IHZhciByID0gdy5Ud2VlbihlLCBsLm9wdHMsIHQsIG4sIGwub3B0cy5zcGVjaWFsRWFzaW5nW3RdIHx8IGwub3B0cy5lYXNpbmcpOyByZXR1cm4gbC50d2VlbnMucHVzaChyKSwgciB9LCBzdG9wOiBmdW5jdGlvbih0KSB7IHZhciBuID0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSB0ID8gbC50d2VlbnMubGVuZ3RoIDogMDsgaWYgKGkpIHJldHVybiB0aGlzOyBmb3IgKGkgPSAhMDsgbiA8IHI7IG4rKykgbC50d2VlbnNbbl0ucnVuKDEpOyByZXR1cm4gdCA/IChzLm5vdGlmeVdpdGgoZSwgW2wsIDEsIDBdKSwgcy5yZXNvbHZlV2l0aChlLCBbbCwgdF0pKSA6IHMucmVqZWN0V2l0aChlLCBbbCwgdF0pLCB0aGlzIH0gfSksXG4gICAgICAgICAgICBjID0gbC5wcm9wczsgZm9yIChmdChjLCBsLm9wdHMuc3BlY2lhbEVhc2luZyk7IG8gPCBhOyBvKyspXG4gICAgICAgICAgICBpZiAociA9IHB0LnByZWZpbHRlcnNbb10uY2FsbChsLCBlLCBjLCBsLm9wdHMpKSByZXR1cm4gZyhyLnN0b3ApICYmICh3Ll9xdWV1ZUhvb2tzKGwuZWxlbSwgbC5vcHRzLnF1ZXVlKS5zdG9wID0gci5zdG9wLmJpbmQocikpLCByOyByZXR1cm4gdy5tYXAoYywgbHQsIGwpLCBnKGwub3B0cy5zdGFydCkgJiYgbC5vcHRzLnN0YXJ0LmNhbGwoZSwgbCksIGwucHJvZ3Jlc3MobC5vcHRzLnByb2dyZXNzKS5kb25lKGwub3B0cy5kb25lLCBsLm9wdHMuY29tcGxldGUpLmZhaWwobC5vcHRzLmZhaWwpLmFsd2F5cyhsLm9wdHMuYWx3YXlzKSwgdy5meC50aW1lcih3LmV4dGVuZCh1LCB7IGVsZW06IGUsIGFuaW06IGwsIHF1ZXVlOiBsLm9wdHMucXVldWUgfSkpLCBsIH0gdy5BbmltYXRpb24gPSB3LmV4dGVuZChwdCwgeyB0d2VlbmVyczogeyBcIipcIjogW2Z1bmN0aW9uKGUsIHQpIHsgdmFyIG4gPSB0aGlzLmNyZWF0ZVR3ZWVuKGUsIHQpOyByZXR1cm4gdWUobi5lbGVtLCBlLCBpZS5leGVjKHQpLCBuKSwgbiB9XSB9LCB0d2VlbmVyOiBmdW5jdGlvbihlLCB0KSB7IGcoZSkgPyAodCA9IGUsIGUgPSBbXCIqXCJdKSA6IGUgPSBlLm1hdGNoKE0pOyBmb3IgKHZhciBuLCByID0gMCwgaSA9IGUubGVuZ3RoOyByIDwgaTsgcisrKSBuID0gZVtyXSwgcHQudHdlZW5lcnNbbl0gPSBwdC50d2VlbmVyc1tuXSB8fCBbXSwgcHQudHdlZW5lcnNbbl0udW5zaGlmdCh0KSB9LCBwcmVmaWx0ZXJzOiBbY3RdLCBwcmVmaWx0ZXI6IGZ1bmN0aW9uKGUsIHQpIHsgdCA/IHB0LnByZWZpbHRlcnMudW5zaGlmdChlKSA6IHB0LnByZWZpbHRlcnMucHVzaChlKSB9IH0pLCB3LnNwZWVkID0gZnVuY3Rpb24oZSwgdCwgbikgeyB2YXIgciA9IGUgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgZSA/IHcuZXh0ZW5kKHt9LCBlKSA6IHsgY29tcGxldGU6IG4gfHwgIW4gJiYgdCB8fCBnKGUpICYmIGUsIGR1cmF0aW9uOiBlLCBlYXNpbmc6IG4gJiYgdCB8fCB0ICYmICFnKHQpICYmIHQgfTsgcmV0dXJuIHcuZngub2ZmID8gci5kdXJhdGlvbiA9IDAgOiBcIm51bWJlclwiICE9IHR5cGVvZiByLmR1cmF0aW9uICYmIChyLmR1cmF0aW9uIGluIHcuZnguc3BlZWRzID8gci5kdXJhdGlvbiA9IHcuZnguc3BlZWRzW3IuZHVyYXRpb25dIDogci5kdXJhdGlvbiA9IHcuZnguc3BlZWRzLl9kZWZhdWx0KSwgbnVsbCAhPSByLnF1ZXVlICYmICEwICE9PSByLnF1ZXVlIHx8IChyLnF1ZXVlID0gXCJmeFwiKSwgci5vbGQgPSByLmNvbXBsZXRlLCByLmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7IGcoci5vbGQpICYmIHIub2xkLmNhbGwodGhpcyksIHIucXVldWUgJiYgdy5kZXF1ZXVlKHRoaXMsIHIucXVldWUpIH0sIHIgfSwgdy5mbi5leHRlbmQoeyBmYWRlVG86IGZ1bmN0aW9uKGUsIHQsIG4sIHIpIHsgcmV0dXJuIHRoaXMuZmlsdGVyKGFlKS5jc3MoXCJvcGFjaXR5XCIsIDApLnNob3coKS5lbmQoKS5hbmltYXRlKHsgb3BhY2l0eTogdCB9LCBlLCBuLCByKSB9LCBhbmltYXRlOiBmdW5jdGlvbihlLCB0LCBuLCByKSB7IHZhciBpID0gdy5pc0VtcHR5T2JqZWN0KGUpLFxuICAgICAgICAgICAgICAgICAgICBvID0gdy5zcGVlZCh0LCBuLCByKSxcbiAgICAgICAgICAgICAgICAgICAgYSA9IGZ1bmN0aW9uKCkgeyB2YXIgdCA9IHB0KHRoaXMsIHcuZXh0ZW5kKHt9LCBlKSwgbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAoaSB8fCBKLmdldCh0aGlzLCBcImZpbmlzaFwiKSkgJiYgdC5zdG9wKCEwKSB9OyByZXR1cm4gYS5maW5pc2ggPSBhLCBpIHx8ICExID09PSBvLnF1ZXVlID8gdGhpcy5lYWNoKGEpIDogdGhpcy5xdWV1ZShvLnF1ZXVlLCBhKSB9LCBzdG9wOiBmdW5jdGlvbihlLCB0LCBuKSB7IHZhciByID0gZnVuY3Rpb24oZSkgeyB2YXIgdCA9IGUuc3RvcDtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGUuc3RvcCwgdChuKSB9OyByZXR1cm4gXCJzdHJpbmdcIiAhPSB0eXBlb2YgZSAmJiAobiA9IHQsIHQgPSBlLCBlID0gdm9pZCAwKSwgdCAmJiAhMSAhPT0gZSAmJiB0aGlzLnF1ZXVlKGUgfHwgXCJmeFwiLCBbXSksIHRoaXMuZWFjaChmdW5jdGlvbigpIHsgdmFyIHQgPSAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBudWxsICE9IGUgJiYgZSArIFwicXVldWVIb29rc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbyA9IHcudGltZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IEouZ2V0KHRoaXMpOyBpZiAoaSkgYVtpXSAmJiBhW2ldLnN0b3AgJiYgcihhW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpIGluIGEpIGFbaV0gJiYgYVtpXS5zdG9wICYmIG90LnRlc3QoaSkgJiYgcihhW2ldKTsgZm9yIChpID0gby5sZW5ndGg7IGktLTspIG9baV0uZWxlbSAhPT0gdGhpcyB8fCBudWxsICE9IGUgJiYgb1tpXS5xdWV1ZSAhPT0gZSB8fCAob1tpXS5hbmltLnN0b3AobiksIHQgPSAhMSwgby5zcGxpY2UoaSwgMSkpOyF0ICYmIG4gfHwgdy5kZXF1ZXVlKHRoaXMsIGUpIH0pIH0sIGZpbmlzaDogZnVuY3Rpb24oZSkgeyByZXR1cm4gITEgIT09IGUgJiYgKGUgPSBlIHx8IFwiZnhcIiksIHRoaXMuZWFjaChmdW5jdGlvbigpIHsgdmFyIHQsIG4gPSBKLmdldCh0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBuW2UgKyBcInF1ZXVlXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IG5bZSArIFwicXVldWVIb29rc1wiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG8gPSB3LnRpbWVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSByID8gci5sZW5ndGggOiAwOyBmb3IgKG4uZmluaXNoID0gITAsIHcucXVldWUodGhpcywgZSwgW10pLCBpICYmIGkuc3RvcCAmJiBpLnN0b3AuY2FsbCh0aGlzLCAhMCksIHQgPSBvLmxlbmd0aDsgdC0tOykgb1t0XS5lbGVtID09PSB0aGlzICYmIG9bdF0ucXVldWUgPT09IGUgJiYgKG9bdF0uYW5pbS5zdG9wKCEwKSwgby5zcGxpY2UodCwgMSkpOyBmb3IgKHQgPSAwOyB0IDwgYTsgdCsrKSByW3RdICYmIHJbdF0uZmluaXNoICYmIHJbdF0uZmluaXNoLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBuLmZpbmlzaCB9KSB9IH0pLCB3LmVhY2goW1widG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIl0sIGZ1bmN0aW9uKGUsIHQpIHsgdmFyIG4gPSB3LmZuW3RdO1xuICAgICAgICAgICAgdy5mblt0XSA9IGZ1bmN0aW9uKGUsIHIsIGkpIHsgcmV0dXJuIG51bGwgPT0gZSB8fCBcImJvb2xlYW5cIiA9PSB0eXBlb2YgZSA/IG4uYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHRoaXMuYW5pbWF0ZSh1dCh0LCAhMCksIGUsIHIsIGkpIH0gfSksIHcuZWFjaCh7IHNsaWRlRG93bjogdXQoXCJzaG93XCIpLCBzbGlkZVVwOiB1dChcImhpZGVcIiksIHNsaWRlVG9nZ2xlOiB1dChcInRvZ2dsZVwiKSwgZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sIGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSwgZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH0gfSwgZnVuY3Rpb24oZSwgdCkgeyB3LmZuW2VdID0gZnVuY3Rpb24oZSwgbiwgcikgeyByZXR1cm4gdGhpcy5hbmltYXRlKHQsIGUsIG4sIHIpIH0gfSksIHcudGltZXJzID0gW10sIHcuZngudGljayA9IGZ1bmN0aW9uKCkgeyB2YXIgZSwgdCA9IDAsXG4gICAgICAgICAgICAgICAgbiA9IHcudGltZXJzOyBmb3IgKG50ID0gRGF0ZS5ub3coKTsgdCA8IG4ubGVuZ3RoOyB0KyspKGUgPSBuW3RdKSgpIHx8IG5bdF0gIT09IGUgfHwgbi5zcGxpY2UodC0tLCAxKTtcbiAgICAgICAgICAgIG4ubGVuZ3RoIHx8IHcuZnguc3RvcCgpLCBudCA9IHZvaWQgMCB9LCB3LmZ4LnRpbWVyID0gZnVuY3Rpb24oZSkgeyB3LnRpbWVycy5wdXNoKGUpLCB3LmZ4LnN0YXJ0KCkgfSwgdy5meC5pbnRlcnZhbCA9IDEzLCB3LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7IHJ0IHx8IChydCA9ICEwLCBhdCgpKSB9LCB3LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHsgcnQgPSBudWxsIH0sIHcuZnguc3BlZWRzID0geyBzbG93OiA2MDAsIGZhc3Q6IDIwMCwgX2RlZmF1bHQ6IDQwMCB9LCB3LmZuLmRlbGF5ID0gZnVuY3Rpb24odCwgbikgeyByZXR1cm4gdCA9IHcuZnggPyB3LmZ4LnNwZWVkc1t0XSB8fCB0IDogdCwgbiA9IG4gfHwgXCJmeFwiLCB0aGlzLnF1ZXVlKG4sIGZ1bmN0aW9uKG4sIHIpIHsgdmFyIGkgPSBlLnNldFRpbWVvdXQobiwgdCk7XG4gICAgICAgICAgICAgICAgci5zdG9wID0gZnVuY3Rpb24oKSB7IGUuY2xlYXJUaW1lb3V0KGkpIH0gfSkgfSxcbiAgICAgICAgZnVuY3Rpb24oKSB7IHZhciBlID0gci5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiksXG4gICAgICAgICAgICAgICAgdCA9IHIuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiKS5hcHBlbmRDaGlsZChyLmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIikpO1xuICAgICAgICAgICAgZS50eXBlID0gXCJjaGVja2JveFwiLCBoLmNoZWNrT24gPSBcIlwiICE9PSBlLnZhbHVlLCBoLm9wdFNlbGVjdGVkID0gdC5zZWxlY3RlZCwgKGUgPSByLmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSkudmFsdWUgPSBcInRcIiwgZS50eXBlID0gXCJyYWRpb1wiLCBoLnJhZGlvVmFsdWUgPSBcInRcIiA9PT0gZS52YWx1ZSB9KCk7IHZhciBkdCwgaHQgPSB3LmV4cHIuYXR0ckhhbmRsZTtcbiAgICB3LmZuLmV4dGVuZCh7IGF0dHI6IGZ1bmN0aW9uKGUsIHQpIHsgcmV0dXJuIHoodGhpcywgdy5hdHRyLCBlLCB0LCBhcmd1bWVudHMubGVuZ3RoID4gMSkgfSwgcmVtb3ZlQXR0cjogZnVuY3Rpb24oZSkgeyByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkgeyB3LnJlbW92ZUF0dHIodGhpcywgZSkgfSkgfSB9KSwgdy5leHRlbmQoeyBhdHRyOiBmdW5jdGlvbihlLCB0LCBuKSB7IHZhciByLCBpLCBvID0gZS5ub2RlVHlwZTsgaWYgKDMgIT09IG8gJiYgOCAhPT0gbyAmJiAyICE9PSBvKSByZXR1cm4gXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2YgZS5nZXRBdHRyaWJ1dGUgPyB3LnByb3AoZSwgdCwgbikgOiAoMSA9PT0gbyAmJiB3LmlzWE1MRG9jKGUpIHx8IChpID0gdy5hdHRySG9va3NbdC50b0xvd2VyQ2FzZSgpXSB8fCAody5leHByLm1hdGNoLmJvb2wudGVzdCh0KSA/IGR0IDogdm9pZCAwKSksIHZvaWQgMCAhPT0gbiA/IG51bGwgPT09IG4gPyB2b2lkIHcucmVtb3ZlQXR0cihlLCB0KSA6IGkgJiYgXCJzZXRcIiBpbiBpICYmIHZvaWQgMCAhPT0gKHIgPSBpLnNldChlLCBuLCB0KSkgPyByIDogKGUuc2V0QXR0cmlidXRlKHQsIG4gKyBcIlwiKSwgbikgOiBpICYmIFwiZ2V0XCIgaW4gaSAmJiBudWxsICE9PSAociA9IGkuZ2V0KGUsIHQpKSA/IHIgOiBudWxsID09IChyID0gdy5maW5kLmF0dHIoZSwgdCkpID8gdm9pZCAwIDogcikgfSwgYXR0ckhvb2tzOiB7IHR5cGU6IHsgc2V0OiBmdW5jdGlvbihlLCB0KSB7IGlmICghaC5yYWRpb1ZhbHVlICYmIFwicmFkaW9cIiA9PT0gdCAmJiBOKGUsIFwiaW5wdXRcIikpIHsgdmFyIG4gPSBlLnZhbHVlOyByZXR1cm4gZS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIHQpLCBuICYmIChlLnZhbHVlID0gbiksIHQgfSB9IH0gfSwgcmVtb3ZlQXR0cjogZnVuY3Rpb24oZSwgdCkgeyB2YXIgbiwgciA9IDAsXG4gICAgICAgICAgICAgICAgaSA9IHQgJiYgdC5tYXRjaChNKTsgaWYgKGkgJiYgMSA9PT0gZS5ub2RlVHlwZSlcbiAgICAgICAgICAgICAgICB3aGlsZSAobiA9IGlbcisrXSkgZS5yZW1vdmVBdHRyaWJ1dGUobikgfSB9KSwgZHQgPSB7IHNldDogZnVuY3Rpb24oZSwgdCwgbikgeyByZXR1cm4gITEgPT09IHQgPyB3LnJlbW92ZUF0dHIoZSwgbikgOiBlLnNldEF0dHJpYnV0ZShuLCBuKSwgbiB9IH0sIHcuZWFjaCh3LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goL1xcdysvZyksIGZ1bmN0aW9uKGUsIHQpIHsgdmFyIG4gPSBodFt0XSB8fCB3LmZpbmQuYXR0cjtcbiAgICAgICAgaHRbdF0gPSBmdW5jdGlvbihlLCB0LCByKSB7IHZhciBpLCBvLCBhID0gdC50b0xvd2VyQ2FzZSgpOyByZXR1cm4gciB8fCAobyA9IGh0W2FdLCBodFthXSA9IGksIGkgPSBudWxsICE9IG4oZSwgdCwgcikgPyBhIDogbnVsbCwgaHRbYV0gPSBvKSwgaSB9IH0pOyB2YXIgZ3QgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuICAgICAgICB5dCA9IC9eKD86YXxhcmVhKSQvaTtcbiAgICB3LmZuLmV4dGVuZCh7IHByb3A6IGZ1bmN0aW9uKGUsIHQpIHsgcmV0dXJuIHoodGhpcywgdy5wcm9wLCBlLCB0LCBhcmd1bWVudHMubGVuZ3RoID4gMSkgfSwgcmVtb3ZlUHJvcDogZnVuY3Rpb24oZSkgeyByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkgeyBkZWxldGUgdGhpc1t3LnByb3BGaXhbZV0gfHwgZV0gfSkgfSB9KSwgdy5leHRlbmQoeyBwcm9wOiBmdW5jdGlvbihlLCB0LCBuKSB7IHZhciByLCBpLCBvID0gZS5ub2RlVHlwZTsgaWYgKDMgIT09IG8gJiYgOCAhPT0gbyAmJiAyICE9PSBvKSByZXR1cm4gMSA9PT0gbyAmJiB3LmlzWE1MRG9jKGUpIHx8ICh0ID0gdy5wcm9wRml4W3RdIHx8IHQsIGkgPSB3LnByb3BIb29rc1t0XSksIHZvaWQgMCAhPT0gbiA/IGkgJiYgXCJzZXRcIiBpbiBpICYmIHZvaWQgMCAhPT0gKHIgPSBpLnNldChlLCBuLCB0KSkgPyByIDogZVt0XSA9IG4gOiBpICYmIFwiZ2V0XCIgaW4gaSAmJiBudWxsICE9PSAociA9IGkuZ2V0KGUsIHQpKSA/IHIgOiBlW3RdIH0sIHByb3BIb29rczogeyB0YWJJbmRleDogeyBnZXQ6IGZ1bmN0aW9uKGUpIHsgdmFyIHQgPSB3LmZpbmQuYXR0cihlLCBcInRhYmluZGV4XCIpOyByZXR1cm4gdCA/IHBhcnNlSW50KHQsIDEwKSA6IGd0LnRlc3QoZS5ub2RlTmFtZSkgfHwgeXQudGVzdChlLm5vZGVOYW1lKSAmJiBlLmhyZWYgPyAwIDogLTEgfSB9IH0sIHByb3BGaXg6IHsgXCJmb3JcIjogXCJodG1sRm9yXCIsIFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIiB9IH0pLCBoLm9wdFNlbGVjdGVkIHx8ICh3LnByb3BIb29rcy5zZWxlY3RlZCA9IHsgZ2V0OiBmdW5jdGlvbihlKSB7IHZhciB0ID0gZS5wYXJlbnROb2RlOyByZXR1cm4gdCAmJiB0LnBhcmVudE5vZGUgJiYgdC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXgsIG51bGwgfSwgc2V0OiBmdW5jdGlvbihlKSB7IHZhciB0ID0gZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgdCAmJiAodC5zZWxlY3RlZEluZGV4LCB0LnBhcmVudE5vZGUgJiYgdC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXgpIH0gfSksIHcuZWFjaChbXCJ0YWJJbmRleFwiLCBcInJlYWRPbmx5XCIsIFwibWF4TGVuZ3RoXCIsIFwiY2VsbFNwYWNpbmdcIiwgXCJjZWxsUGFkZGluZ1wiLCBcInJvd1NwYW5cIiwgXCJjb2xTcGFuXCIsIFwidXNlTWFwXCIsIFwiZnJhbWVCb3JkZXJcIiwgXCJjb250ZW50RWRpdGFibGVcIl0sIGZ1bmN0aW9uKCkgeyB3LnByb3BGaXhbdGhpcy50b0xvd2VyQ2FzZSgpXSA9IHRoaXMgfSk7XG5cbiAgICBmdW5jdGlvbiB2dChlKSB7IHJldHVybiAoZS5tYXRjaChNKSB8fCBbXSkuam9pbihcIiBcIikgfVxuXG4gICAgZnVuY3Rpb24gbXQoZSkgeyByZXR1cm4gZS5nZXRBdHRyaWJ1dGUgJiYgZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiIH1cblxuICAgIGZ1bmN0aW9uIHh0KGUpIHsgcmV0dXJuIEFycmF5LmlzQXJyYXkoZSkgPyBlIDogXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSA/IGUubWF0Y2goTSkgfHwgW10gOiBbXSB9IHcuZm4uZXh0ZW5kKHsgYWRkQ2xhc3M6IGZ1bmN0aW9uKGUpIHsgdmFyIHQsIG4sIHIsIGksIG8sIGEsIHMsIHUgPSAwOyBpZiAoZyhlKSkgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbih0KSB7IHcodGhpcykuYWRkQ2xhc3MoZS5jYWxsKHRoaXMsIHQsIG10KHRoaXMpKSkgfSk7IGlmICgodCA9IHh0KGUpKS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgd2hpbGUgKG4gPSB0aGlzW3UrK10pXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID0gbXQobiksIHIgPSAxID09PSBuLm5vZGVUeXBlICYmIFwiIFwiICsgdnQoaSkgKyBcIiBcIikgeyBhID0gMDsgd2hpbGUgKG8gPSB0W2ErK10pIHIuaW5kZXhPZihcIiBcIiArIG8gKyBcIiBcIikgPCAwICYmIChyICs9IG8gKyBcIiBcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpICE9PSAocyA9IHZ0KHIpKSAmJiBuLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHMpIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzIH0sIHJlbW92ZUNsYXNzOiBmdW5jdGlvbihlKSB7IHZhciB0LCBuLCByLCBpLCBvLCBhLCBzLCB1ID0gMDsgaWYgKGcoZSkpIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24odCkgeyB3KHRoaXMpLnJlbW92ZUNsYXNzKGUuY2FsbCh0aGlzLCB0LCBtdCh0aGlzKSkpIH0pOyBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLmF0dHIoXCJjbGFzc1wiLCBcIlwiKTsgaWYgKCh0ID0geHQoZSkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB3aGlsZSAobiA9IHRoaXNbdSsrXSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPSBtdChuKSwgciA9IDEgPT09IG4ubm9kZVR5cGUgJiYgXCIgXCIgKyB2dChpKSArIFwiIFwiKSB7IGEgPSAwOyB3aGlsZSAobyA9IHRbYSsrXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoci5pbmRleE9mKFwiIFwiICsgbyArIFwiIFwiKSA+IC0xKSByID0gci5yZXBsYWNlKFwiIFwiICsgbyArIFwiIFwiLCBcIiBcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpICE9PSAocyA9IHZ0KHIpKSAmJiBuLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHMpIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzIH0sIHRvZ2dsZUNsYXNzOiBmdW5jdGlvbihlLCB0KSB7IHZhciBuID0gdHlwZW9mIGUsXG4gICAgICAgICAgICAgICAgciA9IFwic3RyaW5nXCIgPT09IG4gfHwgQXJyYXkuaXNBcnJheShlKTsgcmV0dXJuIFwiYm9vbGVhblwiID09IHR5cGVvZiB0ICYmIHIgPyB0ID8gdGhpcy5hZGRDbGFzcyhlKSA6IHRoaXMucmVtb3ZlQ2xhc3MoZSkgOiBnKGUpID8gdGhpcy5lYWNoKGZ1bmN0aW9uKG4pIHsgdyh0aGlzKS50b2dnbGVDbGFzcyhlLmNhbGwodGhpcywgbiwgbXQodGhpcyksIHQpLCB0KSB9KSA6IHRoaXMuZWFjaChmdW5jdGlvbigpIHsgdmFyIHQsIGksIG8sIGE7IGlmIChyKSB7IGkgPSAwLCBvID0gdyh0aGlzKSwgYSA9IHh0KGUpOyB3aGlsZSAodCA9IGFbaSsrXSkgby5oYXNDbGFzcyh0KSA/IG8ucmVtb3ZlQ2xhc3ModCkgOiBvLmFkZENsYXNzKHQpIH0gZWxzZSB2b2lkIDAgIT09IGUgJiYgXCJib29sZWFuXCIgIT09IG4gfHwgKCh0ID0gbXQodGhpcykpICYmIEouc2V0KHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCB0KSwgdGhpcy5zZXRBdHRyaWJ1dGUgJiYgdGhpcy5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0IHx8ICExID09PSBlID8gXCJcIiA6IEouZ2V0KHRoaXMsIFwiX19jbGFzc05hbWVfX1wiKSB8fCBcIlwiKSkgfSkgfSwgaGFzQ2xhc3M6IGZ1bmN0aW9uKGUpIHsgdmFyIHQsIG4sIHIgPSAwO1xuICAgICAgICAgICAgdCA9IFwiIFwiICsgZSArIFwiIFwiOyB3aGlsZSAobiA9IHRoaXNbcisrXSlcbiAgICAgICAgICAgICAgICBpZiAoMSA9PT0gbi5ub2RlVHlwZSAmJiAoXCIgXCIgKyB2dChtdChuKSkgKyBcIiBcIikuaW5kZXhPZih0KSA+IC0xKSByZXR1cm4gITA7IHJldHVybiAhMSB9IH0pOyB2YXIgYnQgPSAvXFxyL2c7XG4gICAgdy5mbi5leHRlbmQoeyB2YWw6IGZ1bmN0aW9uKGUpIHsgdmFyIHQsIG4sIHIsIGkgPSB0aGlzWzBdOyB7IGlmIChhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gciA9IGcoZSksIHRoaXMuZWFjaChmdW5jdGlvbihuKSB7IHZhciBpO1xuICAgICAgICAgICAgICAgICAgICAxID09PSB0aGlzLm5vZGVUeXBlICYmIChudWxsID09IChpID0gciA/IGUuY2FsbCh0aGlzLCBuLCB3KHRoaXMpLnZhbCgpKSA6IGUpID8gaSA9IFwiXCIgOiBcIm51bWJlclwiID09IHR5cGVvZiBpID8gaSArPSBcIlwiIDogQXJyYXkuaXNBcnJheShpKSAmJiAoaSA9IHcubWFwKGksIGZ1bmN0aW9uKGUpIHsgcmV0dXJuIG51bGwgPT0gZSA/IFwiXCIgOiBlICsgXCJcIiB9KSksICh0ID0gdy52YWxIb29rc1t0aGlzLnR5cGVdIHx8IHcudmFsSG9va3NbdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXSkgJiYgXCJzZXRcIiBpbiB0ICYmIHZvaWQgMCAhPT0gdC5zZXQodGhpcywgaSwgXCJ2YWx1ZVwiKSB8fCAodGhpcy52YWx1ZSA9IGkpKSB9KTsgaWYgKGkpIHJldHVybiAodCA9IHcudmFsSG9va3NbaS50eXBlXSB8fCB3LnZhbEhvb2tzW2kubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0pICYmIFwiZ2V0XCIgaW4gdCAmJiB2b2lkIDAgIT09IChuID0gdC5nZXQoaSwgXCJ2YWx1ZVwiKSkgPyBuIDogXCJzdHJpbmdcIiA9PSB0eXBlb2YobiA9IGkudmFsdWUpID8gbi5yZXBsYWNlKGJ0LCBcIlwiKSA6IG51bGwgPT0gbiA/IFwiXCIgOiBuIH0gfSB9KSwgdy5leHRlbmQoeyB2YWxIb29rczogeyBvcHRpb246IHsgZ2V0OiBmdW5jdGlvbihlKSB7IHZhciB0ID0gdy5maW5kLmF0dHIoZSwgXCJ2YWx1ZVwiKTsgcmV0dXJuIG51bGwgIT0gdCA/IHQgOiB2dCh3LnRleHQoZSkpIH0gfSwgc2VsZWN0OiB7IGdldDogZnVuY3Rpb24oZSkgeyB2YXIgdCwgbiwgciwgaSA9IGUub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG8gPSBlLnNlbGVjdGVkSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gXCJzZWxlY3Qtb25lXCIgPT09IGUudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBhID8gbnVsbCA6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdSA9IGEgPyBvICsgMSA6IGkubGVuZ3RoOyBmb3IgKHIgPSBvIDwgMCA/IHUgOiBhID8gbyA6IDA7IHIgPCB1OyByKyspXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKChuID0gaVtyXSkuc2VsZWN0ZWQgfHwgciA9PT0gbykgJiYgIW4uZGlzYWJsZWQgJiYgKCFuLnBhcmVudE5vZGUuZGlzYWJsZWQgfHwgIU4obi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIpKSkgeyBpZiAodCA9IHcobikudmFsKCksIGEpIHJldHVybiB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMucHVzaCh0KSB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzIH0sIHNldDogZnVuY3Rpb24oZSwgdCkgeyB2YXIgbiwgciwgaSA9IGUub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG8gPSB3Lm1ha2VBcnJheSh0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBpLmxlbmd0aDsgd2hpbGUgKGEtLSkoKHIgPSBpW2FdKS5zZWxlY3RlZCA9IHcuaW5BcnJheSh3LnZhbEhvb2tzLm9wdGlvbi5nZXQociksIG8pID4gLTEpICYmIChuID0gITApOyByZXR1cm4gbiB8fCAoZS5zZWxlY3RlZEluZGV4ID0gLTEpLCBvIH0gfSB9IH0pLCB3LmVhY2goW1wicmFkaW9cIiwgXCJjaGVja2JveFwiXSwgZnVuY3Rpb24oKSB7IHcudmFsSG9va3NbdGhpc10gPSB7IHNldDogZnVuY3Rpb24oZSwgdCkgeyBpZiAoQXJyYXkuaXNBcnJheSh0KSkgcmV0dXJuIGUuY2hlY2tlZCA9IHcuaW5BcnJheSh3KGUpLnZhbCgpLCB0KSA+IC0xIH0gfSwgaC5jaGVja09uIHx8ICh3LnZhbEhvb2tzW3RoaXNdLmdldCA9IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIG51bGwgPT09IGUuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgPyBcIm9uXCIgOiBlLnZhbHVlIH0pIH0pLCBoLmZvY3VzaW4gPSBcIm9uZm9jdXNpblwiIGluIGU7IHZhciB3dCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxcbiAgICAgICAgVHQgPSBmdW5jdGlvbihlKSB7IGUuc3RvcFByb3BhZ2F0aW9uKCkgfTtcbiAgICB3LmV4dGVuZCh3LmV2ZW50LCB7IHRyaWdnZXI6IGZ1bmN0aW9uKHQsIG4sIGksIG8pIHsgdmFyIGEsIHMsIHUsIGwsIGMsIHAsIGQsIGgsIHYgPSBbaSB8fCByXSxcbiAgICAgICAgICAgICAgICBtID0gZi5jYWxsKHQsIFwidHlwZVwiKSA/IHQudHlwZSA6IHQsXG4gICAgICAgICAgICAgICAgeCA9IGYuY2FsbCh0LCBcIm5hbWVzcGFjZVwiKSA/IHQubmFtZXNwYWNlLnNwbGl0KFwiLlwiKSA6IFtdOyBpZiAocyA9IGggPSB1ID0gaSA9IGkgfHwgciwgMyAhPT0gaS5ub2RlVHlwZSAmJiA4ICE9PSBpLm5vZGVUeXBlICYmICF3dC50ZXN0KG0gKyB3LmV2ZW50LnRyaWdnZXJlZCkgJiYgKG0uaW5kZXhPZihcIi5cIikgPiAtMSAmJiAobSA9ICh4ID0gbS5zcGxpdChcIi5cIikpLnNoaWZ0KCksIHguc29ydCgpKSwgYyA9IG0uaW5kZXhPZihcIjpcIikgPCAwICYmIFwib25cIiArIG0sIHQgPSB0W3cuZXhwYW5kb10gPyB0IDogbmV3IHcuRXZlbnQobSwgXCJvYmplY3RcIiA9PSB0eXBlb2YgdCAmJiB0KSwgdC5pc1RyaWdnZXIgPSBvID8gMiA6IDMsIHQubmFtZXNwYWNlID0geC5qb2luKFwiLlwiKSwgdC5ybmFtZXNwYWNlID0gdC5uYW1lc3BhY2UgPyBuZXcgUmVnRXhwKFwiKF58XFxcXC4pXCIgKyB4LmpvaW4oXCJcXFxcLig/Oi4qXFxcXC58KVwiKSArIFwiKFxcXFwufCQpXCIpIDogbnVsbCwgdC5yZXN1bHQgPSB2b2lkIDAsIHQudGFyZ2V0IHx8ICh0LnRhcmdldCA9IGkpLCBuID0gbnVsbCA9PSBuID8gW3RdIDogdy5tYWtlQXJyYXkobiwgW3RdKSwgZCA9IHcuZXZlbnQuc3BlY2lhbFttXSB8fCB7fSwgbyB8fCAhZC50cmlnZ2VyIHx8ICExICE9PSBkLnRyaWdnZXIuYXBwbHkoaSwgbikpKSB7IGlmICghbyAmJiAhZC5ub0J1YmJsZSAmJiAheShpKSkgeyBmb3IgKGwgPSBkLmRlbGVnYXRlVHlwZSB8fCBtLCB3dC50ZXN0KGwgKyBtKSB8fCAocyA9IHMucGFyZW50Tm9kZSk7IHM7IHMgPSBzLnBhcmVudE5vZGUpIHYucHVzaChzKSwgdSA9IHM7XG4gICAgICAgICAgICAgICAgICAgIHUgPT09IChpLm93bmVyRG9jdW1lbnQgfHwgcikgJiYgdi5wdXNoKHUuZGVmYXVsdFZpZXcgfHwgdS5wYXJlbnRXaW5kb3cgfHwgZSkgfSBhID0gMDsgd2hpbGUgKChzID0gdlthKytdKSAmJiAhdC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSBoID0gcywgdC50eXBlID0gYSA+IDEgPyBsIDogZC5iaW5kVHlwZSB8fCBtLCAocCA9IChKLmdldChzLCBcImV2ZW50c1wiKSB8fCB7fSlbdC50eXBlXSAmJiBKLmdldChzLCBcImhhbmRsZVwiKSkgJiYgcC5hcHBseShzLCBuKSwgKHAgPSBjICYmIHNbY10pICYmIHAuYXBwbHkgJiYgWShzKSAmJiAodC5yZXN1bHQgPSBwLmFwcGx5KHMsIG4pLCAhMSA9PT0gdC5yZXN1bHQgJiYgdC5wcmV2ZW50RGVmYXVsdCgpKTsgcmV0dXJuIHQudHlwZSA9IG0sIG8gfHwgdC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCBkLl9kZWZhdWx0ICYmICExICE9PSBkLl9kZWZhdWx0LmFwcGx5KHYucG9wKCksIG4pIHx8ICFZKGkpIHx8IGMgJiYgZyhpW21dKSAmJiAheShpKSAmJiAoKHUgPSBpW2NdKSAmJiAoaVtjXSA9IG51bGwpLCB3LmV2ZW50LnRyaWdnZXJlZCA9IG0sIHQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSAmJiBoLmFkZEV2ZW50TGlzdGVuZXIobSwgVHQpLCBpW21dKCksIHQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSAmJiBoLnJlbW92ZUV2ZW50TGlzdGVuZXIobSwgVHQpLCB3LmV2ZW50LnRyaWdnZXJlZCA9IHZvaWQgMCwgdSAmJiAoaVtjXSA9IHUpKSwgdC5yZXN1bHQgfSB9LCBzaW11bGF0ZTogZnVuY3Rpb24oZSwgdCwgbikgeyB2YXIgciA9IHcuZXh0ZW5kKG5ldyB3LkV2ZW50LCBuLCB7IHR5cGU6IGUsIGlzU2ltdWxhdGVkOiAhMCB9KTtcbiAgICAgICAgICAgIHcuZXZlbnQudHJpZ2dlcihyLCBudWxsLCB0KSB9IH0pLCB3LmZuLmV4dGVuZCh7IHRyaWdnZXI6IGZ1bmN0aW9uKGUsIHQpIHsgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHsgdy5ldmVudC50cmlnZ2VyKGUsIHQsIHRoaXMpIH0pIH0sIHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbihlLCB0KSB7IHZhciBuID0gdGhpc1swXTsgaWYgKG4pIHJldHVybiB3LmV2ZW50LnRyaWdnZXIoZSwgdCwgbiwgITApIH0gfSksIGguZm9jdXNpbiB8fCB3LmVhY2goeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbihlLCB0KSB7IHZhciBuID0gZnVuY3Rpb24oZSkgeyB3LmV2ZW50LnNpbXVsYXRlKHQsIGUudGFyZ2V0LCB3LmV2ZW50LmZpeChlKSkgfTtcbiAgICAgICAgdy5ldmVudC5zcGVjaWFsW3RdID0geyBzZXR1cDogZnVuY3Rpb24oKSB7IHZhciByID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGkgPSBKLmFjY2VzcyhyLCB0KTtcbiAgICAgICAgICAgICAgICBpIHx8IHIuYWRkRXZlbnRMaXN0ZW5lcihlLCBuLCAhMCksIEouYWNjZXNzKHIsIHQsIChpIHx8IDApICsgMSkgfSwgdGVhcmRvd246IGZ1bmN0aW9uKCkgeyB2YXIgciA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBpID0gSi5hY2Nlc3MociwgdCkgLSAxO1xuICAgICAgICAgICAgICAgIGkgPyBKLmFjY2VzcyhyLCB0LCBpKSA6IChyLnJlbW92ZUV2ZW50TGlzdGVuZXIoZSwgbiwgITApLCBKLnJlbW92ZShyLCB0KSkgfSB9IH0pOyB2YXIgQ3QgPSBlLmxvY2F0aW9uLFxuICAgICAgICBFdCA9IERhdGUubm93KCksXG4gICAgICAgIGt0ID0gL1xcPy87XG4gICAgdy5wYXJzZVhNTCA9IGZ1bmN0aW9uKHQpIHsgdmFyIG47IGlmICghdCB8fCBcInN0cmluZ1wiICE9IHR5cGVvZiB0KSByZXR1cm4gbnVsbDsgdHJ5IHsgbiA9IChuZXcgZS5ET01QYXJzZXIpLnBhcnNlRnJvbVN0cmluZyh0LCBcInRleHQveG1sXCIpIH0gY2F0Y2ggKGUpIHsgbiA9IHZvaWQgMCB9IHJldHVybiBuICYmICFuLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwicGFyc2VyZXJyb3JcIikubGVuZ3RoIHx8IHcuZXJyb3IoXCJJbnZhbGlkIFhNTDogXCIgKyB0KSwgbiB9OyB2YXIgU3QgPSAvXFxbXFxdJC8sXG4gICAgICAgIER0ID0gL1xccj9cXG4vZyxcbiAgICAgICAgTnQgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXG4gICAgICAgIEF0ID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG4gICAgZnVuY3Rpb24ganQoZSwgdCwgbiwgcikgeyB2YXIgaTsgaWYgKEFycmF5LmlzQXJyYXkodCkpIHcuZWFjaCh0LCBmdW5jdGlvbih0LCBpKSB7IG4gfHwgU3QudGVzdChlKSA/IHIoZSwgaSkgOiBqdChlICsgXCJbXCIgKyAoXCJvYmplY3RcIiA9PSB0eXBlb2YgaSAmJiBudWxsICE9IGkgPyB0IDogXCJcIikgKyBcIl1cIiwgaSwgbiwgcikgfSk7XG4gICAgICAgIGVsc2UgaWYgKG4gfHwgXCJvYmplY3RcIiAhPT0geCh0KSkgcihlLCB0KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZm9yIChpIGluIHQpIGp0KGUgKyBcIltcIiArIGkgKyBcIl1cIiwgdFtpXSwgbiwgcikgfSB3LnBhcmFtID0gZnVuY3Rpb24oZSwgdCkgeyB2YXIgbiwgciA9IFtdLFxuICAgICAgICAgICAgaSA9IGZ1bmN0aW9uKGUsIHQpIHsgdmFyIG4gPSBnKHQpID8gdCgpIDogdDtcbiAgICAgICAgICAgICAgICByW3IubGVuZ3RoXSA9IGVuY29kZVVSSUNvbXBvbmVudChlKSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KG51bGwgPT0gbiA/IFwiXCIgOiBuKSB9OyBpZiAoQXJyYXkuaXNBcnJheShlKSB8fCBlLmpxdWVyeSAmJiAhdy5pc1BsYWluT2JqZWN0KGUpKSB3LmVhY2goZSwgZnVuY3Rpb24oKSB7IGkodGhpcy5uYW1lLCB0aGlzLnZhbHVlKSB9KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZm9yIChuIGluIGUpIGp0KG4sIGVbbl0sIHQsIGkpOyByZXR1cm4gci5qb2luKFwiJlwiKSB9LCB3LmZuLmV4dGVuZCh7IHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7IHJldHVybiB3LnBhcmFtKHRoaXMuc2VyaWFsaXplQXJyYXkoKSkgfSwgc2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKSB7IHZhciBlID0gdy5wcm9wKHRoaXMsIFwiZWxlbWVudHNcIik7IHJldHVybiBlID8gdy5tYWtlQXJyYXkoZSkgOiB0aGlzIH0pLmZpbHRlcihmdW5jdGlvbigpIHsgdmFyIGUgPSB0aGlzLnR5cGU7IHJldHVybiB0aGlzLm5hbWUgJiYgIXcodGhpcykuaXMoXCI6ZGlzYWJsZWRcIikgJiYgQXQudGVzdCh0aGlzLm5vZGVOYW1lKSAmJiAhTnQudGVzdChlKSAmJiAodGhpcy5jaGVja2VkIHx8ICFwZS50ZXN0KGUpKSB9KS5tYXAoZnVuY3Rpb24oZSwgdCkgeyB2YXIgbiA9IHcodGhpcykudmFsKCk7IHJldHVybiBudWxsID09IG4gPyBudWxsIDogQXJyYXkuaXNBcnJheShuKSA/IHcubWFwKG4sIGZ1bmN0aW9uKGUpIHsgcmV0dXJuIHsgbmFtZTogdC5uYW1lLCB2YWx1ZTogZS5yZXBsYWNlKER0LCBcIlxcclxcblwiKSB9IH0pIDogeyBuYW1lOiB0Lm5hbWUsIHZhbHVlOiBuLnJlcGxhY2UoRHQsIFwiXFxyXFxuXCIpIH0gfSkuZ2V0KCkgfSB9KTsgdmFyIHF0ID0gLyUyMC9nLFxuICAgICAgICBMdCA9IC8jLiokLyxcbiAgICAgICAgSHQgPSAvKFs/Jl0pXz1bXiZdKi8sXG4gICAgICAgIE90ID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9nbSxcbiAgICAgICAgUHQgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcbiAgICAgICAgTXQgPSAvXig/OkdFVHxIRUFEKSQvLFxuICAgICAgICBSdCA9IC9eXFwvXFwvLyxcbiAgICAgICAgSXQgPSB7fSxcbiAgICAgICAgV3QgPSB7fSxcbiAgICAgICAgJHQgPSBcIiovXCIuY29uY2F0KFwiKlwiKSxcbiAgICAgICAgQnQgPSByLmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgIEJ0LmhyZWYgPSBDdC5ocmVmO1xuXG4gICAgZnVuY3Rpb24gRnQoZSkgeyByZXR1cm4gZnVuY3Rpb24odCwgbikgeyBcInN0cmluZ1wiICE9IHR5cGVvZiB0ICYmIChuID0gdCwgdCA9IFwiKlwiKTsgdmFyIHIsIGkgPSAwLFxuICAgICAgICAgICAgICAgIG8gPSB0LnRvTG93ZXJDYXNlKCkubWF0Y2goTSkgfHwgW107IGlmIChnKG4pKVxuICAgICAgICAgICAgICAgIHdoaWxlIChyID0gb1tpKytdKSBcIitcIiA9PT0gclswXSA/IChyID0gci5zbGljZSgxKSB8fCBcIipcIiwgKGVbcl0gPSBlW3JdIHx8IFtdKS51bnNoaWZ0KG4pKSA6IChlW3JdID0gZVtyXSB8fCBbXSkucHVzaChuKSB9IH1cblxuICAgIGZ1bmN0aW9uIF90KGUsIHQsIG4sIHIpIHsgdmFyIGkgPSB7fSxcbiAgICAgICAgICAgIG8gPSBlID09PSBXdDtcblxuICAgICAgICBmdW5jdGlvbiBhKHMpIHsgdmFyIHU7IHJldHVybiBpW3NdID0gITAsIHcuZWFjaChlW3NdIHx8IFtdLCBmdW5jdGlvbihlLCBzKSB7IHZhciBsID0gcyh0LCBuLCByKTsgcmV0dXJuIFwic3RyaW5nXCIgIT0gdHlwZW9mIGwgfHwgbyB8fCBpW2xdID8gbyA/ICEodSA9IGwpIDogdm9pZCAwIDogKHQuZGF0YVR5cGVzLnVuc2hpZnQobCksIGEobCksICExKSB9KSwgdSB9IHJldHVybiBhKHQuZGF0YVR5cGVzWzBdKSB8fCAhaVtcIipcIl0gJiYgYShcIipcIikgfVxuXG4gICAgZnVuY3Rpb24genQoZSwgdCkgeyB2YXIgbiwgciwgaSA9IHcuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9OyBmb3IgKG4gaW4gdCkgdm9pZCAwICE9PSB0W25dICYmICgoaVtuXSA/IGUgOiByIHx8IChyID0ge30pKVtuXSA9IHRbbl0pOyByZXR1cm4gciAmJiB3LmV4dGVuZCghMCwgZSwgciksIGUgfVxuXG4gICAgZnVuY3Rpb24gWHQoZSwgdCwgbikgeyB2YXIgciwgaSwgbywgYSwgcyA9IGUuY29udGVudHMsXG4gICAgICAgICAgICB1ID0gZS5kYXRhVHlwZXM7IHdoaWxlIChcIipcIiA9PT0gdVswXSkgdS5zaGlmdCgpLCB2b2lkIDAgPT09IHIgJiYgKHIgPSBlLm1pbWVUeXBlIHx8IHQuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LVR5cGVcIikpOyBpZiAocilcbiAgICAgICAgICAgIGZvciAoaSBpbiBzKVxuICAgICAgICAgICAgICAgIGlmIChzW2ldICYmIHNbaV0udGVzdChyKSkgeyB1LnVuc2hpZnQoaSk7IGJyZWFrIH1cbiAgICAgICAgaWYgKHVbMF0gaW4gbikgbyA9IHVbMF07XG4gICAgICAgIGVsc2UgeyBmb3IgKGkgaW4gbikgeyBpZiAoIXVbMF0gfHwgZS5jb252ZXJ0ZXJzW2kgKyBcIiBcIiArIHVbMF1dKSB7IG8gPSBpOyBicmVhayB9IGEgfHwgKGEgPSBpKSB9IG8gPSBvIHx8IGEgfSBpZiAobykgcmV0dXJuIG8gIT09IHVbMF0gJiYgdS51bnNoaWZ0KG8pLCBuW29dIH1cblxuICAgIGZ1bmN0aW9uIFV0KGUsIHQsIG4sIHIpIHsgdmFyIGksIG8sIGEsIHMsIHUsIGwgPSB7fSxcbiAgICAgICAgICAgIGMgPSBlLmRhdGFUeXBlcy5zbGljZSgpOyBpZiAoY1sxXSlcbiAgICAgICAgICAgIGZvciAoYSBpbiBlLmNvbnZlcnRlcnMpIGxbYS50b0xvd2VyQ2FzZSgpXSA9IGUuY29udmVydGVyc1thXTtcbiAgICAgICAgbyA9IGMuc2hpZnQoKTsgd2hpbGUgKG8pXG4gICAgICAgICAgICBpZiAoZS5yZXNwb25zZUZpZWxkc1tvXSAmJiAobltlLnJlc3BvbnNlRmllbGRzW29dXSA9IHQpLCAhdSAmJiByICYmIGUuZGF0YUZpbHRlciAmJiAodCA9IGUuZGF0YUZpbHRlcih0LCBlLmRhdGFUeXBlKSksIHUgPSBvLCBvID0gYy5zaGlmdCgpKVxuICAgICAgICAgICAgICAgIGlmIChcIipcIiA9PT0gbykgbyA9IHU7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXCIqXCIgIT09IHUgJiYgdSAhPT0gbykgeyBpZiAoIShhID0gbFt1ICsgXCIgXCIgKyBvXSB8fCBsW1wiKiBcIiArIG9dKSlcbiAgICAgICAgICAgICAgICBmb3IgKGkgaW4gbClcbiAgICAgICAgICAgICAgICAgICAgaWYgKChzID0gaS5zcGxpdChcIiBcIikpWzFdID09PSBvICYmIChhID0gbFt1ICsgXCIgXCIgKyBzWzBdXSB8fCBsW1wiKiBcIiArIHNbMF1dKSkgeyEwID09PSBhID8gYSA9IGxbaV0gOiAhMCAhPT0gbFtpXSAmJiAobyA9IHNbMF0sIGMudW5zaGlmdChzWzFdKSk7IGJyZWFrIH1cbiAgICAgICAgICAgIGlmICghMCAhPT0gYSlcbiAgICAgICAgICAgICAgICBpZiAoYSAmJiBlW1widGhyb3dzXCJdKSB0ID0gYSh0KTtcbiAgICAgICAgICAgICAgICBlbHNlIHRyeSB7IHQgPSBhKHQpIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7IHJldHVybiB7IHN0YXRlOiBcInBhcnNlcmVycm9yXCIsIGVycm9yOiBhID8gZSA6IFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgdSArIFwiIHRvIFwiICsgbyB9IH0gfSByZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHQgfSB9IHcuZXh0ZW5kKHsgYWN0aXZlOiAwLCBsYXN0TW9kaWZpZWQ6IHt9LCBldGFnOiB7fSwgYWpheFNldHRpbmdzOiB7IHVybDogQ3QuaHJlZiwgdHlwZTogXCJHRVRcIiwgaXNMb2NhbDogUHQudGVzdChDdC5wcm90b2NvbCksIGdsb2JhbDogITAsIHByb2Nlc3NEYXRhOiAhMCwgYXN5bmM6ICEwLCBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIiwgYWNjZXB0czogeyBcIipcIjogJHQsIHRleHQ6IFwidGV4dC9wbGFpblwiLCBodG1sOiBcInRleHQvaHRtbFwiLCB4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLCBqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiIH0sIGNvbnRlbnRzOiB7IHhtbDogL1xcYnhtbFxcYi8sIGh0bWw6IC9cXGJodG1sLywganNvbjogL1xcYmpzb25cXGIvIH0sIHJlc3BvbnNlRmllbGRzOiB7IHhtbDogXCJyZXNwb25zZVhNTFwiLCB0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLCBqc29uOiBcInJlc3BvbnNlSlNPTlwiIH0sIGNvbnZlcnRlcnM6IHsgXCIqIHRleHRcIjogU3RyaW5nLCBcInRleHQgaHRtbFwiOiAhMCwgXCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSwgXCJ0ZXh0IHhtbFwiOiB3LnBhcnNlWE1MIH0sIGZsYXRPcHRpb25zOiB7IHVybDogITAsIGNvbnRleHQ6ICEwIH0gfSwgYWpheFNldHVwOiBmdW5jdGlvbihlLCB0KSB7IHJldHVybiB0ID8genQoenQoZSwgdy5hamF4U2V0dGluZ3MpLCB0KSA6IHp0KHcuYWpheFNldHRpbmdzLCBlKSB9LCBhamF4UHJlZmlsdGVyOiBGdChJdCksIGFqYXhUcmFuc3BvcnQ6IEZ0KFd0KSwgYWpheDogZnVuY3Rpb24odCwgbikgeyBcIm9iamVjdFwiID09IHR5cGVvZiB0ICYmIChuID0gdCwgdCA9IHZvaWQgMCksIG4gPSBuIHx8IHt9OyB2YXIgaSwgbywgYSwgcywgdSwgbCwgYywgZiwgcCwgZCwgaCA9IHcuYWpheFNldHVwKHt9LCBuKSxcbiAgICAgICAgICAgICAgICBnID0gaC5jb250ZXh0IHx8IGgsXG4gICAgICAgICAgICAgICAgeSA9IGguY29udGV4dCAmJiAoZy5ub2RlVHlwZSB8fCBnLmpxdWVyeSkgPyB3KGcpIDogdy5ldmVudCxcbiAgICAgICAgICAgICAgICB2ID0gdy5EZWZlcnJlZCgpLFxuICAgICAgICAgICAgICAgIG0gPSB3LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLFxuICAgICAgICAgICAgICAgIHggPSBoLnN0YXR1c0NvZGUgfHwge30sXG4gICAgICAgICAgICAgICAgYiA9IHt9LFxuICAgICAgICAgICAgICAgIFQgPSB7fSxcbiAgICAgICAgICAgICAgICBDID0gXCJjYW5jZWxlZFwiLFxuICAgICAgICAgICAgICAgIEUgPSB7IHJlYWR5U3RhdGU6IDAsIGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbihlKSB7IHZhciB0OyBpZiAoYykgeyBpZiAoIXMpIHsgcyA9IHt9OyB3aGlsZSAodCA9IE90LmV4ZWMoYSkpIHNbdFsxXS50b0xvd2VyQ2FzZSgpXSA9IHRbMl0gfSB0ID0gc1tlLnRvTG93ZXJDYXNlKCldIH0gcmV0dXJuIG51bGwgPT0gdCA/IG51bGwgOiB0IH0sIGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24oKSB7IHJldHVybiBjID8gYSA6IG51bGwgfSwgc2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oZSwgdCkgeyByZXR1cm4gbnVsbCA9PSBjICYmIChlID0gVFtlLnRvTG93ZXJDYXNlKCldID0gVFtlLnRvTG93ZXJDYXNlKCldIHx8IGUsIGJbZV0gPSB0KSwgdGhpcyB9LCBvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbihlKSB7IHJldHVybiBudWxsID09IGMgJiYgKGgubWltZVR5cGUgPSBlKSwgdGhpcyB9LCBzdGF0dXNDb2RlOiBmdW5jdGlvbihlKSB7IHZhciB0OyBpZiAoZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYykgRS5hbHdheXMoZVtFLnN0YXR1c10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh0IGluIGUpIHhbdF0gPSBbeFt0XSwgZVt0XV07IHJldHVybiB0aGlzIH0sIGFib3J0OiBmdW5jdGlvbihlKSB7IHZhciB0ID0gZSB8fCBDOyByZXR1cm4gaSAmJiBpLmFib3J0KHQpLCBrKDAsIHQpLCB0aGlzIH0gfTsgaWYgKHYucHJvbWlzZShFKSwgaC51cmwgPSAoKHQgfHwgaC51cmwgfHwgQ3QuaHJlZikgKyBcIlwiKS5yZXBsYWNlKFJ0LCBDdC5wcm90b2NvbCArIFwiLy9cIiksIGgudHlwZSA9IG4ubWV0aG9kIHx8IG4udHlwZSB8fCBoLm1ldGhvZCB8fCBoLnR5cGUsIGguZGF0YVR5cGVzID0gKGguZGF0YVR5cGUgfHwgXCIqXCIpLnRvTG93ZXJDYXNlKCkubWF0Y2goTSkgfHwgW1wiXCJdLCBudWxsID09IGguY3Jvc3NEb21haW4pIHsgbCA9IHIuY3JlYXRlRWxlbWVudChcImFcIik7IHRyeSB7IGwuaHJlZiA9IGgudXJsLCBsLmhyZWYgPSBsLmhyZWYsIGguY3Jvc3NEb21haW4gPSBCdC5wcm90b2NvbCArIFwiLy9cIiArIEJ0Lmhvc3QgIT0gbC5wcm90b2NvbCArIFwiLy9cIiArIGwuaG9zdCB9IGNhdGNoIChlKSB7IGguY3Jvc3NEb21haW4gPSAhMCB9IH0gaWYgKGguZGF0YSAmJiBoLnByb2Nlc3NEYXRhICYmIFwic3RyaW5nXCIgIT0gdHlwZW9mIGguZGF0YSAmJiAoaC5kYXRhID0gdy5wYXJhbShoLmRhdGEsIGgudHJhZGl0aW9uYWwpKSwgX3QoSXQsIGgsIG4sIEUpLCBjKSByZXR1cm4gRTtcbiAgICAgICAgICAgIChmID0gdy5ldmVudCAmJiBoLmdsb2JhbCkgJiYgMCA9PSB3LmFjdGl2ZSsrICYmIHcuZXZlbnQudHJpZ2dlcihcImFqYXhTdGFydFwiKSwgaC50eXBlID0gaC50eXBlLnRvVXBwZXJDYXNlKCksIGguaGFzQ29udGVudCA9ICFNdC50ZXN0KGgudHlwZSksIG8gPSBoLnVybC5yZXBsYWNlKEx0LCBcIlwiKSwgaC5oYXNDb250ZW50ID8gaC5kYXRhICYmIGgucHJvY2Vzc0RhdGEgJiYgMCA9PT0gKGguY29udGVudFR5cGUgfHwgXCJcIikuaW5kZXhPZihcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSAmJiAoaC5kYXRhID0gaC5kYXRhLnJlcGxhY2UocXQsIFwiK1wiKSkgOiAoZCA9IGgudXJsLnNsaWNlKG8ubGVuZ3RoKSwgaC5kYXRhICYmIChoLnByb2Nlc3NEYXRhIHx8IFwic3RyaW5nXCIgPT0gdHlwZW9mIGguZGF0YSkgJiYgKG8gKz0gKGt0LnRlc3QobykgPyBcIiZcIiA6IFwiP1wiKSArIGguZGF0YSwgZGVsZXRlIGguZGF0YSksICExID09PSBoLmNhY2hlICYmIChvID0gby5yZXBsYWNlKEh0LCBcIiQxXCIpLCBkID0gKGt0LnRlc3QobykgPyBcIiZcIiA6IFwiP1wiKSArIFwiXz1cIiArIEV0KysgKyBkKSwgaC51cmwgPSBvICsgZCksIGguaWZNb2RpZmllZCAmJiAody5sYXN0TW9kaWZpZWRbb10gJiYgRS5zZXRSZXF1ZXN0SGVhZGVyKFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgdy5sYXN0TW9kaWZpZWRbb10pLCB3LmV0YWdbb10gJiYgRS5zZXRSZXF1ZXN0SGVhZGVyKFwiSWYtTm9uZS1NYXRjaFwiLCB3LmV0YWdbb10pKSwgKGguZGF0YSAmJiBoLmhhc0NvbnRlbnQgJiYgITEgIT09IGguY29udGVudFR5cGUgfHwgbi5jb250ZW50VHlwZSkgJiYgRS5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsIGguY29udGVudFR5cGUpLCBFLnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHRcIiwgaC5kYXRhVHlwZXNbMF0gJiYgaC5hY2NlcHRzW2guZGF0YVR5cGVzWzBdXSA/IGguYWNjZXB0c1toLmRhdGFUeXBlc1swXV0gKyAoXCIqXCIgIT09IGguZGF0YVR5cGVzWzBdID8gXCIsIFwiICsgJHQgKyBcIjsgcT0wLjAxXCIgOiBcIlwiKSA6IGguYWNjZXB0c1tcIipcIl0pOyBmb3IgKHAgaW4gaC5oZWFkZXJzKSBFLnNldFJlcXVlc3RIZWFkZXIocCwgaC5oZWFkZXJzW3BdKTsgaWYgKGguYmVmb3JlU2VuZCAmJiAoITEgPT09IGguYmVmb3JlU2VuZC5jYWxsKGcsIEUsIGgpIHx8IGMpKSByZXR1cm4gRS5hYm9ydCgpOyBpZiAoQyA9IFwiYWJvcnRcIiwgbS5hZGQoaC5jb21wbGV0ZSksIEUuZG9uZShoLnN1Y2Nlc3MpLCBFLmZhaWwoaC5lcnJvciksIGkgPSBfdChXdCwgaCwgbiwgRSkpIHsgaWYgKEUucmVhZHlTdGF0ZSA9IDEsIGYgJiYgeS50cmlnZ2VyKFwiYWpheFNlbmRcIiwgW0UsIGhdKSwgYykgcmV0dXJuIEU7XG4gICAgICAgICAgICAgICAgaC5hc3luYyAmJiBoLnRpbWVvdXQgPiAwICYmICh1ID0gZS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBFLmFib3J0KFwidGltZW91dFwiKSB9LCBoLnRpbWVvdXQpKTsgdHJ5IHsgYyA9ICExLCBpLnNlbmQoYiwgaykgfSBjYXRjaCAoZSkgeyBpZiAoYykgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgaygtMSwgZSkgfSB9IGVsc2UgaygtMSwgXCJObyBUcmFuc3BvcnRcIik7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGsodCwgbiwgciwgcykgeyB2YXIgbCwgcCwgZCwgYiwgVCwgQyA9IG47XG4gICAgICAgICAgICAgICAgYyB8fCAoYyA9ICEwLCB1ICYmIGUuY2xlYXJUaW1lb3V0KHUpLCBpID0gdm9pZCAwLCBhID0gcyB8fCBcIlwiLCBFLnJlYWR5U3RhdGUgPSB0ID4gMCA/IDQgOiAwLCBsID0gdCA+PSAyMDAgJiYgdCA8IDMwMCB8fCAzMDQgPT09IHQsIHIgJiYgKGIgPSBYdChoLCBFLCByKSksIGIgPSBVdChoLCBiLCBFLCBsKSwgbCA/IChoLmlmTW9kaWZpZWQgJiYgKChUID0gRS5nZXRSZXNwb25zZUhlYWRlcihcIkxhc3QtTW9kaWZpZWRcIikpICYmICh3Lmxhc3RNb2RpZmllZFtvXSA9IFQpLCAoVCA9IEUuZ2V0UmVzcG9uc2VIZWFkZXIoXCJldGFnXCIpKSAmJiAody5ldGFnW29dID0gVCkpLCAyMDQgPT09IHQgfHwgXCJIRUFEXCIgPT09IGgudHlwZSA/IEMgPSBcIm5vY29udGVudFwiIDogMzA0ID09PSB0ID8gQyA9IFwibm90bW9kaWZpZWRcIiA6IChDID0gYi5zdGF0ZSwgcCA9IGIuZGF0YSwgbCA9ICEoZCA9IGIuZXJyb3IpKSkgOiAoZCA9IEMsICF0ICYmIEMgfHwgKEMgPSBcImVycm9yXCIsIHQgPCAwICYmICh0ID0gMCkpKSwgRS5zdGF0dXMgPSB0LCBFLnN0YXR1c1RleHQgPSAobiB8fCBDKSArIFwiXCIsIGwgPyB2LnJlc29sdmVXaXRoKGcsIFtwLCBDLCBFXSkgOiB2LnJlamVjdFdpdGgoZywgW0UsIEMsIGRdKSwgRS5zdGF0dXNDb2RlKHgpLCB4ID0gdm9pZCAwLCBmICYmIHkudHJpZ2dlcihsID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIiwgW0UsIGgsIGwgPyBwIDogZF0pLCBtLmZpcmVXaXRoKGcsIFtFLCBDXSksIGYgJiYgKHkudHJpZ2dlcihcImFqYXhDb21wbGV0ZVwiLCBbRSwgaF0pLCAtLXcuYWN0aXZlIHx8IHcuZXZlbnQudHJpZ2dlcihcImFqYXhTdG9wXCIpKSkgfSByZXR1cm4gRSB9LCBnZXRKU09OOiBmdW5jdGlvbihlLCB0LCBuKSB7IHJldHVybiB3LmdldChlLCB0LCBuLCBcImpzb25cIikgfSwgZ2V0U2NyaXB0OiBmdW5jdGlvbihlLCB0KSB7IHJldHVybiB3LmdldChlLCB2b2lkIDAsIHQsIFwic2NyaXB0XCIpIH0gfSksIHcuZWFjaChbXCJnZXRcIiwgXCJwb3N0XCJdLCBmdW5jdGlvbihlLCB0KSB7IHdbdF0gPSBmdW5jdGlvbihlLCBuLCByLCBpKSB7IHJldHVybiBnKG4pICYmIChpID0gaSB8fCByLCByID0gbiwgbiA9IHZvaWQgMCksIHcuYWpheCh3LmV4dGVuZCh7IHVybDogZSwgdHlwZTogdCwgZGF0YVR5cGU6IGksIGRhdGE6IG4sIHN1Y2Nlc3M6IHIgfSwgdy5pc1BsYWluT2JqZWN0KGUpICYmIGUpKSB9IH0pLCB3Ll9ldmFsVXJsID0gZnVuY3Rpb24oZSkgeyByZXR1cm4gdy5hamF4KHsgdXJsOiBlLCB0eXBlOiBcIkdFVFwiLCBkYXRhVHlwZTogXCJzY3JpcHRcIiwgY2FjaGU6ICEwLCBhc3luYzogITEsIGdsb2JhbDogITEsIFwidGhyb3dzXCI6ICEwIH0pIH0sIHcuZm4uZXh0ZW5kKHsgd3JhcEFsbDogZnVuY3Rpb24oZSkgeyB2YXIgdDsgcmV0dXJuIHRoaXNbMF0gJiYgKGcoZSkgJiYgKGUgPSBlLmNhbGwodGhpc1swXSkpLCB0ID0gdyhlLCB0aGlzWzBdLm93bmVyRG9jdW1lbnQpLmVxKDApLmNsb25lKCEwKSwgdGhpc1swXS5wYXJlbnROb2RlICYmIHQuaW5zZXJ0QmVmb3JlKHRoaXNbMF0pLCB0Lm1hcChmdW5jdGlvbigpIHsgdmFyIGUgPSB0aGlzOyB3aGlsZSAoZS5maXJzdEVsZW1lbnRDaGlsZCkgZSA9IGUuZmlyc3RFbGVtZW50Q2hpbGQ7IHJldHVybiBlIH0pLmFwcGVuZCh0aGlzKSksIHRoaXMgfSwgd3JhcElubmVyOiBmdW5jdGlvbihlKSB7IHJldHVybiBnKGUpID8gdGhpcy5lYWNoKGZ1bmN0aW9uKHQpIHsgdyh0aGlzKS53cmFwSW5uZXIoZS5jYWxsKHRoaXMsIHQpKSB9KSA6IHRoaXMuZWFjaChmdW5jdGlvbigpIHsgdmFyIHQgPSB3KHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICBuID0gdC5jb250ZW50cygpO1xuICAgICAgICAgICAgICAgIG4ubGVuZ3RoID8gbi53cmFwQWxsKGUpIDogdC5hcHBlbmQoZSkgfSkgfSwgd3JhcDogZnVuY3Rpb24oZSkgeyB2YXIgdCA9IGcoZSk7IHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24obikgeyB3KHRoaXMpLndyYXBBbGwodCA/IGUuY2FsbCh0aGlzLCBuKSA6IGUpIH0pIH0sIHVud3JhcDogZnVuY3Rpb24oZSkgeyByZXR1cm4gdGhpcy5wYXJlbnQoZSkubm90KFwiYm9keVwiKS5lYWNoKGZ1bmN0aW9uKCkgeyB3KHRoaXMpLnJlcGxhY2VXaXRoKHRoaXMuY2hpbGROb2RlcykgfSksIHRoaXMgfSB9KSwgdy5leHByLnBzZXVkb3MuaGlkZGVuID0gZnVuY3Rpb24oZSkgeyByZXR1cm4gIXcuZXhwci5wc2V1ZG9zLnZpc2libGUoZSkgfSwgdy5leHByLnBzZXVkb3MudmlzaWJsZSA9IGZ1bmN0aW9uKGUpIHsgcmV0dXJuICEhKGUub2Zmc2V0V2lkdGggfHwgZS5vZmZzZXRIZWlnaHQgfHwgZS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCkgfSwgdy5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7IHRyeSB7IHJldHVybiBuZXcgZS5YTUxIdHRwUmVxdWVzdCB9IGNhdGNoIChlKSB7fSB9OyB2YXIgVnQgPSB7IDA6IDIwMCwgMTIyMzogMjA0IH0sXG4gICAgICAgIEd0ID0gdy5hamF4U2V0dGluZ3MueGhyKCk7XG4gICAgaC5jb3JzID0gISFHdCAmJiBcIndpdGhDcmVkZW50aWFsc1wiIGluIEd0LCBoLmFqYXggPSBHdCA9ICEhR3QsIHcuYWpheFRyYW5zcG9ydChmdW5jdGlvbih0KSB7IHZhciBuLCByOyBpZiAoaC5jb3JzIHx8IEd0ICYmICF0LmNyb3NzRG9tYWluKSByZXR1cm4geyBzZW5kOiBmdW5jdGlvbihpLCBvKSB7IHZhciBhLCBzID0gdC54aHIoKTsgaWYgKHMub3Blbih0LnR5cGUsIHQudXJsLCB0LmFzeW5jLCB0LnVzZXJuYW1lLCB0LnBhc3N3b3JkKSwgdC54aHJGaWVsZHMpXG4gICAgICAgICAgICAgICAgICAgIGZvciAoYSBpbiB0LnhockZpZWxkcykgc1thXSA9IHQueGhyRmllbGRzW2FdO1xuICAgICAgICAgICAgICAgIHQubWltZVR5cGUgJiYgcy5vdmVycmlkZU1pbWVUeXBlICYmIHMub3ZlcnJpZGVNaW1lVHlwZSh0Lm1pbWVUeXBlKSwgdC5jcm9zc0RvbWFpbiB8fCBpW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXSB8fCAoaVtcIlgtUmVxdWVzdGVkLVdpdGhcIl0gPSBcIlhNTEh0dHBSZXF1ZXN0XCIpOyBmb3IgKGEgaW4gaSkgcy5zZXRSZXF1ZXN0SGVhZGVyKGEsIGlbYV0pO1xuICAgICAgICAgICAgICAgIG4gPSBmdW5jdGlvbihlKSB7IHJldHVybiBmdW5jdGlvbigpIHsgbiAmJiAobiA9IHIgPSBzLm9ubG9hZCA9IHMub25lcnJvciA9IHMub25hYm9ydCA9IHMub250aW1lb3V0ID0gcy5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsLCBcImFib3J0XCIgPT09IGUgPyBzLmFib3J0KCkgOiBcImVycm9yXCIgPT09IGUgPyBcIm51bWJlclwiICE9IHR5cGVvZiBzLnN0YXR1cyA/IG8oMCwgXCJlcnJvclwiKSA6IG8ocy5zdGF0dXMsIHMuc3RhdHVzVGV4dCkgOiBvKFZ0W3Muc3RhdHVzXSB8fCBzLnN0YXR1cywgcy5zdGF0dXNUZXh0LCBcInRleHRcIiAhPT0gKHMucmVzcG9uc2VUeXBlIHx8IFwidGV4dFwiKSB8fCBcInN0cmluZ1wiICE9IHR5cGVvZiBzLnJlc3BvbnNlVGV4dCA/IHsgYmluYXJ5OiBzLnJlc3BvbnNlIH0gOiB7IHRleHQ6IHMucmVzcG9uc2VUZXh0IH0sIHMuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpKSB9IH0sIHMub25sb2FkID0gbigpLCByID0gcy5vbmVycm9yID0gcy5vbnRpbWVvdXQgPSBuKFwiZXJyb3JcIiksIHZvaWQgMCAhPT0gcy5vbmFib3J0ID8gcy5vbmFib3J0ID0gciA6IHMub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7IDQgPT09IHMucmVhZHlTdGF0ZSAmJiBlLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IG4gJiYgcigpIH0pIH0sIG4gPSBuKFwiYWJvcnRcIik7IHRyeSB7IHMuc2VuZCh0Lmhhc0NvbnRlbnQgJiYgdC5kYXRhIHx8IG51bGwpIH0gY2F0Y2ggKGUpIHsgaWYgKG4pIHRocm93IGUgfSB9LCBhYm9ydDogZnVuY3Rpb24oKSB7IG4gJiYgbigpIH0gfSB9KSwgdy5hamF4UHJlZmlsdGVyKGZ1bmN0aW9uKGUpIHsgZS5jcm9zc0RvbWFpbiAmJiAoZS5jb250ZW50cy5zY3JpcHQgPSAhMSkgfSksIHcuYWpheFNldHVwKHsgYWNjZXB0czogeyBzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIiB9LCBjb250ZW50czogeyBzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiLyB9LCBjb252ZXJ0ZXJzOiB7IFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oZSkgeyByZXR1cm4gdy5nbG9iYWxFdmFsKGUpLCBlIH0gfSB9KSwgdy5hamF4UHJlZmlsdGVyKFwic2NyaXB0XCIsIGZ1bmN0aW9uKGUpIHsgdm9pZCAwID09PSBlLmNhY2hlICYmIChlLmNhY2hlID0gITEpLCBlLmNyb3NzRG9tYWluICYmIChlLnR5cGUgPSBcIkdFVFwiKSB9KSwgdy5hamF4VHJhbnNwb3J0KFwic2NyaXB0XCIsIGZ1bmN0aW9uKGUpIHsgaWYgKGUuY3Jvc3NEb21haW4pIHsgdmFyIHQsIG47IHJldHVybiB7IHNlbmQ6IGZ1bmN0aW9uKGksIG8pIHsgdCA9IHcoXCI8c2NyaXB0PlwiKS5wcm9wKHsgY2hhcnNldDogZS5zY3JpcHRDaGFyc2V0LCBzcmM6IGUudXJsIH0pLm9uKFwibG9hZCBlcnJvclwiLCBuID0gZnVuY3Rpb24oZSkgeyB0LnJlbW92ZSgpLCBuID0gbnVsbCwgZSAmJiBvKFwiZXJyb3JcIiA9PT0gZS50eXBlID8gNDA0IDogMjAwLCBlLnR5cGUpIH0pLCByLmhlYWQuYXBwZW5kQ2hpbGQodFswXSkgfSwgYWJvcnQ6IGZ1bmN0aW9uKCkgeyBuICYmIG4oKSB9IH0gfSB9KTsgdmFyIFl0ID0gW10sXG4gICAgICAgIFF0ID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcbiAgICB3LmFqYXhTZXR1cCh7IGpzb25wOiBcImNhbGxiYWNrXCIsIGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkgeyB2YXIgZSA9IFl0LnBvcCgpIHx8IHcuZXhwYW5kbyArIFwiX1wiICsgRXQrKzsgcmV0dXJuIHRoaXNbZV0gPSAhMCwgZSB9IH0pLCB3LmFqYXhQcmVmaWx0ZXIoXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKHQsIG4sIHIpIHsgdmFyIGksIG8sIGEsIHMgPSAhMSAhPT0gdC5qc29ucCAmJiAoUXQudGVzdCh0LnVybCkgPyBcInVybFwiIDogXCJzdHJpbmdcIiA9PSB0eXBlb2YgdC5kYXRhICYmIDAgPT09ICh0LmNvbnRlbnRUeXBlIHx8IFwiXCIpLmluZGV4T2YoXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIikgJiYgUXQudGVzdCh0LmRhdGEpICYmIFwiZGF0YVwiKTsgaWYgKHMgfHwgXCJqc29ucFwiID09PSB0LmRhdGFUeXBlc1swXSkgcmV0dXJuIGkgPSB0Lmpzb25wQ2FsbGJhY2sgPSBnKHQuanNvbnBDYWxsYmFjaykgPyB0Lmpzb25wQ2FsbGJhY2soKSA6IHQuanNvbnBDYWxsYmFjaywgcyA/IHRbc10gPSB0W3NdLnJlcGxhY2UoUXQsIFwiJDFcIiArIGkpIDogITEgIT09IHQuanNvbnAgJiYgKHQudXJsICs9IChrdC50ZXN0KHQudXJsKSA/IFwiJlwiIDogXCI/XCIpICsgdC5qc29ucCArIFwiPVwiICsgaSksIHQuY29udmVydGVyc1tcInNjcmlwdCBqc29uXCJdID0gZnVuY3Rpb24oKSB7IHJldHVybiBhIHx8IHcuZXJyb3IoaSArIFwiIHdhcyBub3QgY2FsbGVkXCIpLCBhWzBdIH0sIHQuZGF0YVR5cGVzWzBdID0gXCJqc29uXCIsIG8gPSBlW2ldLCBlW2ldID0gZnVuY3Rpb24oKSB7IGEgPSBhcmd1bWVudHMgfSwgci5hbHdheXMoZnVuY3Rpb24oKSB7IHZvaWQgMCA9PT0gbyA/IHcoZSkucmVtb3ZlUHJvcChpKSA6IGVbaV0gPSBvLCB0W2ldICYmICh0Lmpzb25wQ2FsbGJhY2sgPSBuLmpzb25wQ2FsbGJhY2ssIFl0LnB1c2goaSkpLCBhICYmIGcobykgJiYgbyhhWzBdKSwgYSA9IG8gPSB2b2lkIDAgfSksIFwic2NyaXB0XCIgfSksIGguY3JlYXRlSFRNTERvY3VtZW50ID0gZnVuY3Rpb24oKSB7IHZhciBlID0gci5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoXCJcIikuYm9keTsgcmV0dXJuIGUuaW5uZXJIVE1MID0gXCI8Zm9ybT48L2Zvcm0+PGZvcm0+PC9mb3JtPlwiLCAyID09PSBlLmNoaWxkTm9kZXMubGVuZ3RoIH0oKSwgdy5wYXJzZUhUTUwgPSBmdW5jdGlvbihlLCB0LCBuKSB7IGlmIChcInN0cmluZ1wiICE9IHR5cGVvZiBlKSByZXR1cm4gW107IFwiYm9vbGVhblwiID09IHR5cGVvZiB0ICYmIChuID0gdCwgdCA9ICExKTsgdmFyIGksIG8sIGE7IHJldHVybiB0IHx8IChoLmNyZWF0ZUhUTUxEb2N1bWVudCA/ICgoaSA9ICh0ID0gci5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoXCJcIikpLmNyZWF0ZUVsZW1lbnQoXCJiYXNlXCIpKS5ocmVmID0gci5sb2NhdGlvbi5ocmVmLCB0LmhlYWQuYXBwZW5kQ2hpbGQoaSkpIDogdCA9IHIpLCBvID0gQS5leGVjKGUpLCBhID0gIW4gJiYgW10sIG8gPyBbdC5jcmVhdGVFbGVtZW50KG9bMV0pXSA6IChvID0geGUoW2VdLCB0LCBhKSwgYSAmJiBhLmxlbmd0aCAmJiB3KGEpLnJlbW92ZSgpLCB3Lm1lcmdlKFtdLCBvLmNoaWxkTm9kZXMpKSB9LCB3LmZuLmxvYWQgPSBmdW5jdGlvbihlLCB0LCBuKSB7IHZhciByLCBpLCBvLCBhID0gdGhpcyxcbiAgICAgICAgICAgIHMgPSBlLmluZGV4T2YoXCIgXCIpOyByZXR1cm4gcyA+IC0xICYmIChyID0gdnQoZS5zbGljZShzKSksIGUgPSBlLnNsaWNlKDAsIHMpKSwgZyh0KSA/IChuID0gdCwgdCA9IHZvaWQgMCkgOiB0ICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIHQgJiYgKGkgPSBcIlBPU1RcIiksIGEubGVuZ3RoID4gMCAmJiB3LmFqYXgoeyB1cmw6IGUsIHR5cGU6IGkgfHwgXCJHRVRcIiwgZGF0YVR5cGU6IFwiaHRtbFwiLCBkYXRhOiB0IH0pLmRvbmUoZnVuY3Rpb24oZSkgeyBvID0gYXJndW1lbnRzLCBhLmh0bWwociA/IHcoXCI8ZGl2PlwiKS5hcHBlbmQody5wYXJzZUhUTUwoZSkpLmZpbmQocikgOiBlKSB9KS5hbHdheXMobiAmJiBmdW5jdGlvbihlLCB0KSB7IGEuZWFjaChmdW5jdGlvbigpIHsgbi5hcHBseSh0aGlzLCBvIHx8IFtlLnJlc3BvbnNlVGV4dCwgdCwgZV0pIH0pIH0pLCB0aGlzIH0sIHcuZWFjaChbXCJhamF4U3RhcnRcIiwgXCJhamF4U3RvcFwiLCBcImFqYXhDb21wbGV0ZVwiLCBcImFqYXhFcnJvclwiLCBcImFqYXhTdWNjZXNzXCIsIFwiYWpheFNlbmRcIl0sIGZ1bmN0aW9uKGUsIHQpIHsgdy5mblt0XSA9IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIHRoaXMub24odCwgZSkgfSB9KSwgdy5leHByLnBzZXVkb3MuYW5pbWF0ZWQgPSBmdW5jdGlvbihlKSB7IHJldHVybiB3LmdyZXAody50aW1lcnMsIGZ1bmN0aW9uKHQpIHsgcmV0dXJuIGUgPT09IHQuZWxlbSB9KS5sZW5ndGggfSwgdy5vZmZzZXQgPSB7IHNldE9mZnNldDogZnVuY3Rpb24oZSwgdCwgbikgeyB2YXIgciwgaSwgbywgYSwgcywgdSwgbCwgYyA9IHcuY3NzKGUsIFwicG9zaXRpb25cIiksXG4gICAgICAgICAgICAgICAgZiA9IHcoZSksXG4gICAgICAgICAgICAgICAgcCA9IHt9OyBcInN0YXRpY1wiID09PSBjICYmIChlLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiKSwgcyA9IGYub2Zmc2V0KCksIG8gPSB3LmNzcyhlLCBcInRvcFwiKSwgdSA9IHcuY3NzKGUsIFwibGVmdFwiKSwgKGwgPSAoXCJhYnNvbHV0ZVwiID09PSBjIHx8IFwiZml4ZWRcIiA9PT0gYykgJiYgKG8gKyB1KS5pbmRleE9mKFwiYXV0b1wiKSA+IC0xKSA/IChhID0gKHIgPSBmLnBvc2l0aW9uKCkpLnRvcCwgaSA9IHIubGVmdCkgOiAoYSA9IHBhcnNlRmxvYXQobykgfHwgMCwgaSA9IHBhcnNlRmxvYXQodSkgfHwgMCksIGcodCkgJiYgKHQgPSB0LmNhbGwoZSwgbiwgdy5leHRlbmQoe30sIHMpKSksIG51bGwgIT0gdC50b3AgJiYgKHAudG9wID0gdC50b3AgLSBzLnRvcCArIGEpLCBudWxsICE9IHQubGVmdCAmJiAocC5sZWZ0ID0gdC5sZWZ0IC0gcy5sZWZ0ICsgaSksIFwidXNpbmdcIiBpbiB0ID8gdC51c2luZy5jYWxsKGUsIHApIDogZi5jc3MocCkgfSB9LCB3LmZuLmV4dGVuZCh7IG9mZnNldDogZnVuY3Rpb24oZSkgeyBpZiAoYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHZvaWQgMCA9PT0gZSA/IHRoaXMgOiB0aGlzLmVhY2goZnVuY3Rpb24odCkgeyB3Lm9mZnNldC5zZXRPZmZzZXQodGhpcywgZSwgdCkgfSk7IHZhciB0LCBuLCByID0gdGhpc1swXTsgaWYgKHIpIHJldHVybiByLmdldENsaWVudFJlY3RzKCkubGVuZ3RoID8gKHQgPSByLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBuID0gci5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LCB7IHRvcDogdC50b3AgKyBuLnBhZ2VZT2Zmc2V0LCBsZWZ0OiB0LmxlZnQgKyBuLnBhZ2VYT2Zmc2V0IH0pIDogeyB0b3A6IDAsIGxlZnQ6IDAgfSB9LCBwb3NpdGlvbjogZnVuY3Rpb24oKSB7IGlmICh0aGlzWzBdKSB7IHZhciBlLCB0LCBuLCByID0gdGhpc1swXSxcbiAgICAgICAgICAgICAgICAgICAgaSA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07IGlmIChcImZpeGVkXCIgPT09IHcuY3NzKHIsIFwicG9zaXRpb25cIikpIHQgPSByLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIGVsc2UgeyB0ID0gdGhpcy5vZmZzZXQoKSwgbiA9IHIub3duZXJEb2N1bWVudCwgZSA9IHIub2Zmc2V0UGFyZW50IHx8IG4uZG9jdW1lbnRFbGVtZW50OyB3aGlsZSAoZSAmJiAoZSA9PT0gbi5ib2R5IHx8IGUgPT09IG4uZG9jdW1lbnRFbGVtZW50KSAmJiBcInN0YXRpY1wiID09PSB3LmNzcyhlLCBcInBvc2l0aW9uXCIpKSBlID0gZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBlICYmIGUgIT09IHIgJiYgMSA9PT0gZS5ub2RlVHlwZSAmJiAoKGkgPSB3KGUpLm9mZnNldCgpKS50b3AgKz0gdy5jc3MoZSwgXCJib3JkZXJUb3BXaWR0aFwiLCAhMCksIGkubGVmdCArPSB3LmNzcyhlLCBcImJvcmRlckxlZnRXaWR0aFwiLCAhMCkpIH0gcmV0dXJuIHsgdG9wOiB0LnRvcCAtIGkudG9wIC0gdy5jc3MociwgXCJtYXJnaW5Ub3BcIiwgITApLCBsZWZ0OiB0LmxlZnQgLSBpLmxlZnQgLSB3LmNzcyhyLCBcIm1hcmdpbkxlZnRcIiwgITApIH0gfSB9LCBvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKSB7IHZhciBlID0gdGhpcy5vZmZzZXRQYXJlbnQ7IHdoaWxlIChlICYmIFwic3RhdGljXCIgPT09IHcuY3NzKGUsIFwicG9zaXRpb25cIikpIGUgPSBlLm9mZnNldFBhcmVudDsgcmV0dXJuIGUgfHwgYmUgfSkgfSB9KSwgdy5lYWNoKHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbihlLCB0KSB7IHZhciBuID0gXCJwYWdlWU9mZnNldFwiID09PSB0O1xuICAgICAgICB3LmZuW2VdID0gZnVuY3Rpb24ocikgeyByZXR1cm4geih0aGlzLCBmdW5jdGlvbihlLCByLCBpKSB7IHZhciBvOyBpZiAoeShlKSA/IG8gPSBlIDogOSA9PT0gZS5ub2RlVHlwZSAmJiAobyA9IGUuZGVmYXVsdFZpZXcpLCB2b2lkIDAgPT09IGkpIHJldHVybiBvID8gb1t0XSA6IGVbcl07XG4gICAgICAgICAgICAgICAgbyA/IG8uc2Nyb2xsVG8obiA/IG8ucGFnZVhPZmZzZXQgOiBpLCBuID8gaSA6IG8ucGFnZVlPZmZzZXQpIDogZVtyXSA9IGkgfSwgZSwgciwgYXJndW1lbnRzLmxlbmd0aCkgfSB9KSwgdy5lYWNoKFtcInRvcFwiLCBcImxlZnRcIl0sIGZ1bmN0aW9uKGUsIHQpIHsgdy5jc3NIb29rc1t0XSA9IF9lKGgucGl4ZWxQb3NpdGlvbiwgZnVuY3Rpb24oZSwgbikgeyBpZiAobikgcmV0dXJuIG4gPSBGZShlLCB0KSwgV2UudGVzdChuKSA/IHcoZSkucG9zaXRpb24oKVt0XSArIFwicHhcIiA6IG4gfSkgfSksIHcuZWFjaCh7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbihlLCB0KSB7IHcuZWFjaCh7IHBhZGRpbmc6IFwiaW5uZXJcIiArIGUsIGNvbnRlbnQ6IHQsIFwiXCI6IFwib3V0ZXJcIiArIGUgfSwgZnVuY3Rpb24obiwgcikgeyB3LmZuW3JdID0gZnVuY3Rpb24oaSwgbykgeyB2YXIgYSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKG4gfHwgXCJib29sZWFuXCIgIT0gdHlwZW9mIGkpLFxuICAgICAgICAgICAgICAgICAgICBzID0gbiB8fCAoITAgPT09IGkgfHwgITAgPT09IG8gPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIik7IHJldHVybiB6KHRoaXMsIGZ1bmN0aW9uKHQsIG4sIGkpIHsgdmFyIG87IHJldHVybiB5KHQpID8gMCA9PT0gci5pbmRleE9mKFwib3V0ZXJcIikgPyB0W1wiaW5uZXJcIiArIGVdIDogdC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbXCJjbGllbnRcIiArIGVdIDogOSA9PT0gdC5ub2RlVHlwZSA/IChvID0gdC5kb2N1bWVudEVsZW1lbnQsIE1hdGgubWF4KHQuYm9keVtcInNjcm9sbFwiICsgZV0sIG9bXCJzY3JvbGxcIiArIGVdLCB0LmJvZHlbXCJvZmZzZXRcIiArIGVdLCBvW1wib2Zmc2V0XCIgKyBlXSwgb1tcImNsaWVudFwiICsgZV0pKSA6IHZvaWQgMCA9PT0gaSA/IHcuY3NzKHQsIG4sIHMpIDogdy5zdHlsZSh0LCBuLCBpLCBzKSB9LCB0LCBhID8gaSA6IHZvaWQgMCwgYSkgfSB9KSB9KSwgdy5lYWNoKFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBjb250ZXh0bWVudVwiLnNwbGl0KFwiIFwiKSwgZnVuY3Rpb24oZSwgdCkgeyB3LmZuW3RdID0gZnVuY3Rpb24oZSwgbikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgPyB0aGlzLm9uKHQsIG51bGwsIGUsIG4pIDogdGhpcy50cmlnZ2VyKHQpIH0gfSksIHcuZm4uZXh0ZW5kKHsgaG92ZXI6IGZ1bmN0aW9uKGUsIHQpIHsgcmV0dXJuIHRoaXMubW91c2VlbnRlcihlKS5tb3VzZWxlYXZlKHQgfHwgZSkgfSB9KSwgdy5mbi5leHRlbmQoeyBiaW5kOiBmdW5jdGlvbihlLCB0LCBuKSB7IHJldHVybiB0aGlzLm9uKGUsIG51bGwsIHQsIG4pIH0sIHVuYmluZDogZnVuY3Rpb24oZSwgdCkgeyByZXR1cm4gdGhpcy5vZmYoZSwgbnVsbCwgdCkgfSwgZGVsZWdhdGU6IGZ1bmN0aW9uKGUsIHQsIG4sIHIpIHsgcmV0dXJuIHRoaXMub24odCwgZSwgbiwgcikgfSwgdW5kZWxlZ2F0ZTogZnVuY3Rpb24oZSwgdCwgbikgeyByZXR1cm4gMSA9PT0gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMub2ZmKGUsIFwiKipcIikgOiB0aGlzLm9mZih0LCBlIHx8IFwiKipcIiwgbikgfSB9KSwgdy5wcm94eSA9IGZ1bmN0aW9uKGUsIHQpIHsgdmFyIG4sIHIsIGk7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiB0ICYmIChuID0gZVt0XSwgdCA9IGUsIGUgPSBuKSwgZyhlKSkgcmV0dXJuIHIgPSBvLmNhbGwoYXJndW1lbnRzLCAyKSwgaSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZS5hcHBseSh0IHx8IHRoaXMsIHIuY29uY2F0KG8uY2FsbChhcmd1bWVudHMpKSkgfSwgaS5ndWlkID0gZS5ndWlkID0gZS5ndWlkIHx8IHcuZ3VpZCsrLCBpIH0sIHcuaG9sZFJlYWR5ID0gZnVuY3Rpb24oZSkgeyBlID8gdy5yZWFkeVdhaXQrKyA6IHcucmVhZHkoITApIH0sIHcuaXNBcnJheSA9IEFycmF5LmlzQXJyYXksIHcucGFyc2VKU09OID0gSlNPTi5wYXJzZSwgdy5ub2RlTmFtZSA9IE4sIHcuaXNGdW5jdGlvbiA9IGcsIHcuaXNXaW5kb3cgPSB5LCB3LmNhbWVsQ2FzZSA9IEcsIHcudHlwZSA9IHgsIHcubm93ID0gRGF0ZS5ub3csIHcuaXNOdW1lcmljID0gZnVuY3Rpb24oZSkgeyB2YXIgdCA9IHcudHlwZShlKTsgcmV0dXJuIChcIm51bWJlclwiID09PSB0IHx8IFwic3RyaW5nXCIgPT09IHQpICYmICFpc05hTihlIC0gcGFyc2VGbG9hdChlKSkgfSwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBkZWZpbmUgJiYgZGVmaW5lLmFtZCAmJiBkZWZpbmUoXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkgeyByZXR1cm4gdyB9KTsgdmFyIEp0ID0gZS5qUXVlcnksXG4gICAgICAgIEt0ID0gZS4kOyByZXR1cm4gdy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24odCkgeyByZXR1cm4gZS4kID09PSB3ICYmIChlLiQgPSBLdCksIHQgJiYgZS5qUXVlcnkgPT09IHcgJiYgKGUualF1ZXJ5ID0gSnQpLCB3IH0sIHQgfHwgKGUualF1ZXJ5ID0gZS4kID0gdyksIHcgfSk7XG4iXSwiZmlsZSI6ImpxdWVyeS5qcyJ9
